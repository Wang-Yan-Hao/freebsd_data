
-    Part I. Basics
-    Chapter 1. Introduction
    -   1.1. Developing on FreeBSD
    -   1.2. The BSD Vision
    -   1.3. Architectural Guidelines
    -   1.4. The Layout of /usr/src
-    Chapter 2. Programming Tools
    -   2.1. Synopsis
    -   2.2. Introduction
    -   2.3. Introduction to Programming
    -   2.4. Compiling with cc
    -   2.5. Make
    -   2.6. Debugging
    -   2.7. Using Emacs as a Development Environment
    -   2.8. Further Reading
-    Chapter 3. Secure Programming
    -   3.1. Synopsis
    -   3.2. Secure Design Methodology
    -   3.3. Buffer Overflows
    -   3.4. SetUID issues
    -   3.5. Limiting your program’s environment
    -   3.6. Trust
    -   3.7. Race Conditions
-    Chapter 4. Localization and Internationalization - L10N and I18N
    -   4.1. Programming I18N Compliant Applications
    -   4.2. Localized Messages with POSIX.1 Native Language Support
        (NLS)
-    Chapter 5. Source Tree Guidelines and Policies
    -   5.1. Style Guidelines
    -   5.2. MAINTAINER on Makefiles
    -   5.3. Contributed Software
    -   5.4. Encumbered Files
    -   5.5. Shared Libraries
-    Chapter 6. Regression and Performance Testing
    -   6.1. Micro Benchmark Checklist
    -   6.2. The FreeBSD Source Tinderbox
    -   6.3. The index.cgi Script
    -   6.4. Official Build Servers
    -   6.5. Official Summary Site
-    Part II. Interprocess Communication
-    Chapter 7. Sockets
    -   7.1. Synopsis
    -   7.2. Networking and Diversity
    -   7.3. Protocols
    -   7.4. The Sockets Model
    -   7.5. Essential Socket Functions
    -   7.6. Helper Functions
    -   7.7. Concurrent Servers
-    Chapter 8. IPv6 Internals
    -   8.1. IPv6/IPsec Implementation
-    Part III. Kernel
-    Chapter 9. Building and Installing a FreeBSD Kernel
    -   9.1. Building the Faster but Brittle Way
-    Chapter 10. Kernel Debugging
    -   10.1. Obtaining a Kernel Crash Dump
    -   10.2. Debugging a Kernel Crash Dump with kgdb
    -   10.3. On-Line Kernel Debugging Using DDB
    -   10.4. On-Line Kernel Debugging Using Remote GDB
    -   10.5. Debugging a Console Driver
    -   10.6. Debugging Deadlocks
    -   10.7. Kernel debugging with Dcons
    -   10.8. Glossary of Kernel Options for Debugging
-    Part IV. Architectures
-    Chapter 11. x86 Assembly Language Programming
    -   A.1. Synopsis
    -   A.2. The Tools
    -   A.3. System Calls
    -   A.4. Return Values
    -   A.5. Creating Portable Code
    -   A.6. Our First Program
    -   A.7. Writing UNIX® Filters
    -   A.8. Buffered Input and Output
    -   A.9. Command Line Arguments
    -   A.10. UNIX® Environment
    -   A.11. Working with Files
    -   A.12. One-Pointed Mind
    -   A.13. Using the FPU
    -   A.14. Caveats
    -   A.15. Acknowledgements
-    Part V. Appendices
-    Appendices
-   

Book menu

Chapter 6. Regression and Performance Testing

Table of Contents

-   6.1. Micro Benchmark Checklist
-   6.2. The FreeBSD Source Tinderbox
-   6.3. The index.cgi Script
-   6.4. Official Build Servers
-   6.5. Official Summary Site

Regression tests are used to exercise a particular bit of the system to
check that it works as expected, and to make sure that old bugs are not
reintroduced.

The FreeBSD regression testing tools can be found in the FreeBSD source
tree in the directory src/tools/regression.

6.1. Micro Benchmark Checklist

This section contains hints for doing proper micro-benchmarking on
FreeBSD or of FreeBSD itself.

It is not possible to use all of the suggestions below every single
time, but the more used, the better the benchmark’s ability to test
small differences will be.

-   Disable APM and any other kind of clock fiddling (ACPI ?).

-   Run in single user mode. E.g., cron(8), and other daemons only add
    noise. The sshd(8) daemon can also cause problems. If ssh access is
    required during testing either disable the SSHv1 key regeneration,
    or kill the parent sshd daemon during the tests.

-   Do not run ntpd(8).

-   If syslog(3) events are generated, run syslogd(8) with an empty
    /etc/syslogd.conf, otherwise, do not run it.

-   Minimize disk-I/O, avoid it entirely if possible.

-   Do not mount file systems that are not needed.

-   Mount /, /usr, and any other file system as read-only if possible.
    This removes atime updates to disk (etc.) from the I/O picture.

-   Reinitialize the read/write test file system with newfs(8) and
    populate it from a tar(1) or dump(8) file before every run. Unmount
    and mount it before starting the test. This results in a consistent
    file system layout. For a worldstone test this would apply to
    /usr/obj (just reinitialize with newfs and mount). To get 100%
    reproducibility, populate the file system from a dd(1) file (i.e.:
    dd if=myimage of=/dev/ad0s1h bs=1m)

-   Use malloc backed or preloaded md(4) partitions.

-   Reboot between individual iterations of the test, this gives a more
    consistent state.

-   Remove all non-essential device drivers from the kernel. For
    instance if USB is not needed for the test, do not put USB in the
    kernel. Drivers which attach often have timeouts ticking away.

-   Unconfigure hardware that are not in use. Detach disks with
    atacontrol(8) and camcontrol(8) if the disks are not used for the
    test.

-   Do not configure the network unless it is being tested, or wait
    until after the test has been performed to ship the results off to
    another computer.

    If the system must be connected to a public network, watch out for
    spikes of broadcast traffic. Even though it is hardly noticeable, it
    will take up CPU cycles. Multicast has similar caveats.

-   Put each file system on its own disk. This minimizes jitter from
    head-seek optimizations.

-   Minimize output to serial or VGA consoles. Running output into files
    gives less jitter. (Serial consoles easily become a bottleneck.) Do
    not touch keyboard while the test is running, even space or
    back-space shows up in the numbers.

-   Make sure the test is long enough, but not too long. If the test is
    too short, timestamping is a problem. If it is too long temperature
    changes and drift will affect the frequency of the quartz crystals
    in the computer. Rule of thumb: more than a minute, less than an
    hour.

-   Try to keep the temperature as stable as possible around the
    machine. This affects both quartz crystals and disk drive
    algorithms. To get real stable clock, consider stabilized clock
    injection. E.g., get a OCXO + PLL, inject output into clock circuits
    instead of motherboard xtal. Contact Poul-Henning Kamp
    <phk@FreeBSD.org> for more information about this.

-   Run the test at least 3 times but it is better to run more than 20
    times both for "before" and "after" code. Try to interleave if
    possible (i.e.: do not run 20 times before then 20 times after),
    this makes it possible to spot environmental effects. Do not
    interleave 1:1, but 3:3, this makes it possible to spot interaction
    effects.

    A good pattern is: bababa{bbbaaa}*. This gives hint after the first
    1+1 runs (so it is possible to stop the test if it goes entirely the
    wrong way), a standard deviation after the first 3+3 (gives a good
    indication if it is going to be worth a long run) and trending and
    interaction numbers later on.

-   Use ministat(1) to see if the numbers are significant. Consider
    buying "Cartoon guide to statistics" ISBN: 0062731025, highly
    recommended, if you have forgotten or never learned about standard
    deviation and Student’s T.

-   Do not use background fsck(8) unless the test is a benchmark of
    background fsck. Also, disable background_fsck in /etc/rc.conf
    unless the benchmark is not started at least 60+"fsck runtime"
    seconds after the boot, as rc(8) wakes up and checks if fsck needs
    to run on any file systems when background fsck is enabled.
    Likewise, make sure there are no snapshots lying around unless the
    benchmark is a test with snapshots.

-   If the benchmark show unexpected bad performance, check for things
    like high interrupt volume from an unexpected source. Some versions
    of ACPI have been reported to "misbehave" and generate excess
    interrupts. To help diagnose odd test results, take a few snapshots
    of vmstat -i and look for anything unusual.

-   Make sure to be careful about optimization parameters for kernel and
    userspace, likewise debugging. It is easy to let something slip
    through and realize later the test was not comparing the same thing.

-   Do not ever benchmark with the WITNESS and INVARIANTS kernel options
    enabled unless the test is interested to benchmarking those
    features. WITNESS can cause 400%+ drops in performance. Likewise,
    userspace malloc(3) parameters default differently in -CURRENT from
    the way they ship in production releases.

6.2. The FreeBSD Source Tinderbox

The source Tinderbox consists of:

-   A build script, tinderbox, that automates checking out a specific
    version of the FreeBSD source tree and building it.

-   A supervisor script, tbmaster, that monitors individual Tinderbox
    instances, logs their output, and emails failure notices.

-   A CGI script named index.cgi that reads a set of tbmaster logs and
    presents an easy-to-read HTML summary of them.

-   A set of build servers that continually test the tip of the most
    important FreeBSD code branches.

-   A webserver that keeps a complete set of Tinderbox logs and displays
    an up-to-date summary.

The scripts are maintained and were developed by Dag-Erling Smørgrav
<des@FreeBSD.org>, and are now written in Perl, a move on from their
original incarnation as shell scripts. All scripts and configuration
files are kept in /projects/tinderbox/.

For more information about the tinderbox and tbmaster scripts at this
stage, see their respective man pages: tinderbox(1) and tbmaster(1).

6.3. The index.cgi Script

The index.cgi script generates the HTML summary of tinderbox and
tbmaster logs. Although originally intended to be used as a CGI script,
as indicated by its name, this script can also be run from the command
line or from a cron(8) job, in which case it will look for logs in the
directory where the script is located. It will automatically detect
context, generating HTTP headers when it is run as a CGI script. It
conforms to XHTML standards and is styled using CSS.

The script starts in the main() block by attempting to verify that it is
running on the official Tinderbox website. If it is not, a page
indicating it is not an official website is produced, and a URL to the
official site is provided.

Next, it scans the log directory to get an inventory of configurations,
branches and architectures for which log files exist, to avoid
hard-coding a list into the script and potentially ending up with blank
rows or columns. This information is derived from the names of the log
files matching the following pattern:

    tinderbox-$config-$branch-$arch-$machine.{brief,full}

The configurations used on the official Tinderbox build servers are
named for the branches they build. For example, the releng_8
configuration is used to build RELENG_8 as well as all still-supported
release branches.

Once all of this startup procedure has been successfully completed,
do_config() is called for each configuration.

The do_config() function generates HTML for a single Tinderbox
configuration.

It works by first generating a header row, then iterating over each
branch build with the specified configuration, producing a single row of
results for each in the following manner:

-   For each item:

    -   For each machine within that architecture:

        -   If a brief log file exists, then:

            -   Call success() to determine the outcome of the build.

            -   Output the modification size.

            -   Output the size of the brief log file with a link to the
                log file itself.

            -   If a full log file also exists, then:

                -   Output the size of the full log file with a link to
                    the log file itself.

        -   Otherwise:

            -   No output.

The success() function mentioned above scans a brief log file for the
string "tinderbox run completed" in order to determine whether the build
was successful.

Configurations and branches are sorted according to their branch rank.
This is computed as follows:

-   HEAD and CURRENT have rank 9999.

-   RELENG_x has rank xx99.

-   RELENG_x_y has rank xxyy.

This means that HEAD always ranks highest, and RELENG branches are
ranked in numerical order, with each STABLE branch ranking higher than
the release branches forked off of it. For instance, for FreeBSD 8, the
order from highest to lowest would be:

-   RELENG_8 (branch rank 899).

-   RELENG_8_3 (branch rank 803).

-   RELENG_8_2 (branch rank 802).

-   RELENG_8_1 (branch rank 801).

-   RELENG_8_0 (branch rank 800).

The colors that Tinderbox uses for each cell in the table are defined by
CSS. Successful builds are displayed with green text; unsuccessful
builds are displayed with red text. The color fades as time passes since
the corresponding build, with every half an hour bringing the color
closer to grey.

6.4. Official Build Servers

The official Tinderbox build servers are hosted by Sentex Data
Communications, who also host the FreeBSD Netperf Cluster.

Three build servers currently exist:

freebsd-current.sentex.ca builds:

-   HEAD for amd64, arm, i386, i386/pc98, ia64, mips, powerpc,
    powerpc64, and sparc64.

-   RELENG_9 and supported 9.X branches for amd64, arm, i386, i386/pc98,
    ia64, mips, powerpc, powerpc64, and sparc64.

freebsd-stable.sentex.ca builds:

-   RELENG_8 and supported 8.X branches for amd64, i386, i386/pc98,
    ia64, mips, powerpc and sparc64.

freebsd-legacy.sentex.ca builds:

-   RELENG_7 and supported 7.X branches for amd64, i386, i386/pc98,
    ia64, powerpc, and sparc64.

6.5. Official Summary Site

Summaries and logs from the official build servers are available online
at http://tinderbox.FreeBSD.org, hosted by Dag-Erling Smørgrav
<des@FreeBSD.org> and set up as follows:

-   A cron(8) job checks the build servers at regular intervals and
    downloads any new log files using rsync(1).

-   Apache is set up to use index.cgi as DirectoryIndex.

<<<<<<< HEAD
=======
------------------------------------------------------------------------
>>>>>>> b1bb5fd9 (Processing txt files in data/doc)

Last modified on: December 11, 2021 by Sergio Carlavilla Delgado

Prev

Home

Next

Table of Contents

-   6.1. Micro Benchmark Checklist
-   6.2. The FreeBSD Source Tinderbox
-   6.3. The index.cgi Script
-   6.4. Official Build Servers
-   6.5. Official Summary Site

<<<<<<< HEAD

=======
------------------------------------------------------------------------

Resources

-   Download PDF
-   Edit this page
>>>>>>> b1bb5fd9 (Processing txt files in data/doc)

