
-    Part I. Basics
-    Chapter 1. Introduction
    -   1.1. Developing on FreeBSD
    -   1.2. The BSD Vision
    -   1.3. Architectural Guidelines
    -   1.4. The Layout of /usr/src
-    Chapter 2. Programming Tools
    -   2.1. Synopsis
    -   2.2. Introduction
    -   2.3. Introduction to Programming
    -   2.4. Compiling with cc
    -   2.5. Make
    -   2.6. Debugging
    -   2.7. Using Emacs as a Development Environment
    -   2.8. Further Reading
-    Chapter 3. Secure Programming
    -   3.1. Synopsis
    -   3.2. Secure Design Methodology
    -   3.3. Buffer Overflows
    -   3.4. SetUID issues
    -   3.5. Limiting your program’s environment
    -   3.6. Trust
    -   3.7. Race Conditions
-    Chapter 4. Localization and Internationalization - L10N and I18N
    -   4.1. Programming I18N Compliant Applications
    -   4.2. Localized Messages with POSIX.1 Native Language Support
        (NLS)
-    Chapter 5. Source Tree Guidelines and Policies
    -   5.1. Style Guidelines
    -   5.2. MAINTAINER on Makefiles
    -   5.3. Contributed Software
    -   5.4. Encumbered Files
    -   5.5. Shared Libraries
-    Chapter 6. Regression and Performance Testing
    -   6.1. Micro Benchmark Checklist
    -   6.2. The FreeBSD Source Tinderbox
    -   6.3. The index.cgi Script
    -   6.4. Official Build Servers
    -   6.5. Official Summary Site
-    Part II. Interprocess Communication
-    Chapter 7. Sockets
    -   7.1. Synopsis
    -   7.2. Networking and Diversity
    -   7.3. Protocols
    -   7.4. The Sockets Model
    -   7.5. Essential Socket Functions
    -   7.6. Helper Functions
    -   7.7. Concurrent Servers
-    Chapter 8. IPv6 Internals
    -   8.1. IPv6/IPsec Implementation
-    Part III. Kernel
-    Chapter 9. Building and Installing a FreeBSD Kernel
    -   9.1. Building the Faster but Brittle Way
-    Chapter 10. Kernel Debugging
    -   10.1. Obtaining a Kernel Crash Dump
    -   10.2. Debugging a Kernel Crash Dump with kgdb
    -   10.3. On-Line Kernel Debugging Using DDB
    -   10.4. On-Line Kernel Debugging Using Remote GDB
    -   10.5. Debugging a Console Driver
    -   10.6. Debugging Deadlocks
    -   10.7. Kernel debugging with Dcons
    -   10.8. Glossary of Kernel Options for Debugging
-    Part IV. Architectures
-    Chapter 11. x86 Assembly Language Programming
    -   A.1. Synopsis
    -   A.2. The Tools
    -   A.3. System Calls
    -   A.4. Return Values
    -   A.5. Creating Portable Code
    -   A.6. Our First Program
    -   A.7. Writing UNIX® Filters
    -   A.8. Buffered Input and Output
    -   A.9. Command Line Arguments
    -   A.10. UNIX® Environment
    -   A.11. Working with Files
    -   A.12. One-Pointed Mind
    -   A.13. Using the FPU
    -   A.14. Caveats
    -   A.15. Acknowledgements
-    Part V. Appendices
-    Appendices
-   

Book menu

Chapter 4. Localization and Internationalization - L10N and I18N

Table of Contents

-   4.1. Programming I18N Compliant Applications
-   4.2. Localized Messages with POSIX.1 Native Language Support (NLS)

4.1. Programming I18N Compliant Applications

To make your application more useful for speakers of other languages, we
hope that you will program I18N compliant. The GNU gcc compiler and GUI
libraries like QT and GTK support I18N through special handling of
strings. Making a program I18N compliant is very easy. It allows
contributors to port your application to other languages quickly. Refer
to the library specific I18N documentation for more details.

In contrast with common perception, I18N compliant code is easy to
write. Usually, it only involves wrapping your strings with library
specific functions. In addition, please be sure to allow for wide or
multibyte character support.

4.1.1. A Call to Unify the I18N Effort

It has come to our attention that the individual I18N/L10N efforts for
each country has been repeating each others' efforts. Many of us have
been reinventing the wheel repeatedly and inefficiently. We hope that
the various major groups in I18N could congregate into a group effort
similar to the Core Team’s responsibility.

Currently, we hope that, when you write or port I18N programs, you would
send it out to each country’s related FreeBSD mailing list for testing.
In the future, we hope to create applications that work in all the
languages out-of-the-box without dirty hacks.

The FreeBSD internationalization mailing list has been established. If
you are an I18N/L10N developer, please send your comments, ideas,
questions, and anything you deem related to it.

4.1.2. Perl and Python

Perl and Python have I18N and wide character handling libraries. Please
use them for I18N compliance.

4.2. Localized Messages with POSIX.1 Native Language Support (NLS)

Beyond the basic I18N functions, like supporting various input encodings
or supporting national conventions, such as the different decimal
separators, at a higher level of I18N, it is possible to localize the
messages written to the output by the various programs. A common way of
doing this is using the POSIX.1 NLS functions, which are provided as a
part of the FreeBSD base system.

4.2.1. Organizing Localized Messages into Catalog Files

POSIX.1 NLS is based on catalog files, which contain the localized
messages in the desired encoding. The messages are organized into sets
and each message is identified by an integer number in the containing
set. The catalog files are conventionally named after the locale they
contain localized messages for, followed by the .msg extension. For
instance, the Hungarian messages for ISO8859-2 encoding should be stored
in a file called hu_HU.ISO8859-2.

These catalog files are common text files that contain the numbered
messages. It is possible to write comments by starting the line with a $
sign. Set boundaries are also separated by special comments, where the
keyword set must directly follow the $ sign. The set keyword is then
followed by the set number. For example:

    $set 1

The actual message entries start with the message number and followed by
the localized message. The well-known modifiers from printf(3) are
accepted:

    15 "File not found: %s\n"

The language catalog files have to be compiled into a binary form before
they can be opened from the program. This conversion is done with the
gencat(1) utility. Its first argument is the filename of the compiled
catalog and its further arguments are the input catalogs. The localized
messages can also be organized into more catalog files and then all of
them can be processed with gencat(1).

4.2.2. Using the Catalog Files from the Source Code

Using the catalog files is simple. To use the related functions,
nl_types.h must be included. Before using a catalog, it has to be opened
with catopen(3). The function takes two arguments. The first parameter
is the name of the installed and compiled catalog. Usually, the name of
the program is used, such as grep. This name will be used when looking
for the compiled catalog file. The catopen(3) call looks for this file
in /usr/share/nls/locale/catname and in
/usr/local/share/nls/locale/catname, where locale is the locale set and
catname is the catalog name being discussed. The second parameter is a
constant, which can have two values:

-   NL_CAT_LOCALE, which means that the used catalog file will be based
    on LC_MESSAGES.

-   0, which means that LANG has to be used to open the proper catalog.

The catopen(3) call returns a catalog identifier of type nl_catd. Please
refer to the manual page for a list of possible returned error codes.

After opening a catalog catgets(3) can be used to retrieve a message.
The first parameter is the catalog identifier returned by catopen(3),
the second one is the number of the set, the third one is the number of
the messages, and the fourth one is a fallback message, which will be
returned if the requested message cannot be retrieved from the catalog
file.

After using the catalog file, it must be closed by calling catclose(3),
which has one argument, the catalog id.

4.2.3. A Practical Example

The following example will demonstrate an easy solution on how to use
NLS catalogs in a flexible way.

The below lines need to be put into a common header file of the program,
which is included into all source files where localized messages are
necessary:

    #ifdef WITHOUT_NLS
    #define getstr(n)    nlsstr[n]
    #else
    #include nl_types.h

    extern nl_catd       catalog;
    #define getstr(n)    catgets(catalog, 1, n, nlsstr[n])
    #endif

    extern char     *nlsstr[];

Next, put these lines into the global declaration part of the main
source file:

    #ifndef WITHOUT_NLS
    #include nl_types.h
    nl_catd  catalog;
    #endif

    /*
     * Default messages to use when NLS is disabled or no catalog
     * is found.
     */
    char    *nlsstr[] = {
            "",
    /* 1*/  "some random message",
    /* 2*/  "some other message"
    };

Next come the real code snippets, which open, read, and close the
catalog:

    #ifndef WITHOUT_NLS
        catalog = catopen("myapp", NL_CAT_LOCALE);
    #endif

    ...

    printf(getstr(1));

    ...

    #ifndef WITHOUT_NLS
        catclose(catalog);
    #endif

4.2.3.1. Reducing Strings to Localize

There is a good way of reducing the strings that need to be localized by
using libc error messages. This is also useful to just avoid duplication
and provide consistent error messages for the common errors that can be
encountered by a great many of programs.

First, here is an example that does not use libc error messages:

    #include err.h
    ...
    if (!S_ISDIR(st.st_mode))
        errx(1, "argument is not a directory");

This can be transformed to print an error message by reading errno and
printing an error message accordingly:

    #include err.h
    #include errno.h
    ...
    if (!S_ISDIR(st.st_mode)) {
        errno = ENOTDIR;
        err(1, NULL);
    }

In this example, the custom string is eliminated, thus translators will
have less work when localizing the program and users will see the usual
"Not a directory" error message when they encounter this error. This
message will probably seem more familiar to them. Please note that it
was necessary to include errno.h in order to directly access errno.

It is worth to note that there are cases when errno is set automatically
by a preceding call, so it is not necessary to set it explicitly:

    #include err.h
    ...
    if ((p = malloc(size)) == NULL)
        err(1, NULL);

4.2.4. Making use of bsd.nls.mk

Using the catalog files requires few repeatable steps, such as compiling
the catalogs and installing them to the proper location. In order to
simplify this process even more, bsd.nls.mk introduces some macros. It
is not necessary to include bsd.nls.mk explicitly, it is pulled in from
the common Makefiles, such as bsd.prog.mk or bsd.lib.mk.

Usually it is enough to define NLSNAME, which should have the catalog
name mentioned as the first argument of catopen(3) and list the catalog
files in NLS without their .msg extension. Here is an example, which
makes it possible to to disable NLS when used with the code examples
before. The WITHOUT_NLS make(1) variable has to be defined in order to
build the program without NLS support.

    .if !defined(WITHOUT_NLS)
    NLS=    es_ES.ISO8859-1
    NLS+=   hu_HU.ISO8859-2
    NLS+=   pt_BR.ISO8859-1
    .else
    CFLAGS+=    -DWITHOUT_NLS
    .endif

Conventionally, the catalog files are placed under the nls subdirectory
and this is the default behavior of bsd.nls.mk. It is possible, though
to override the location of the catalogs with the NLSSRCDIR make(1)
variable. The default name of the precompiled catalog files also follow
the naming convention mentioned before. It can be overridden by setting
the NLSNAME variable. There are other options to fine tune the
processing of the catalog files but usually it is not needed, thus they
are not described here. For further information on bsd.nls.mk, please
refer to the file itself, it is short and easy to understand.

<<<<<<< HEAD
=======
------------------------------------------------------------------------
>>>>>>> b1bb5fd9 (Processing txt files in data/doc)

Last modified on: December 11, 2021 by Sergio Carlavilla Delgado

Prev

Home

Next

Table of Contents

-   4.1. Programming I18N Compliant Applications
-   4.2. Localized Messages with POSIX.1 Native Language Support (NLS)

<<<<<<< HEAD

=======
------------------------------------------------------------------------

Resources

-   Download PDF
-   Edit this page
>>>>>>> b1bb5fd9 (Processing txt files in data/doc)

