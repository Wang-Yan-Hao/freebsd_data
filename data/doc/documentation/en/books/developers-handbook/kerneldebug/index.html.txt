
-    Part I. Basics
-    Chapter 1. Introduction
    -   1.1. Developing on FreeBSD
    -   1.2. The BSD Vision
    -   1.3. Architectural Guidelines
    -   1.4. The Layout of /usr/src
-    Chapter 2. Programming Tools
    -   2.1. Synopsis
    -   2.2. Introduction
    -   2.3. Introduction to Programming
    -   2.4. Compiling with cc
    -   2.5. Make
    -   2.6. Debugging
    -   2.7. Using Emacs as a Development Environment
    -   2.8. Further Reading
-    Chapter 3. Secure Programming
    -   3.1. Synopsis
    -   3.2. Secure Design Methodology
    -   3.3. Buffer Overflows
    -   3.4. SetUID issues
    -   3.5. Limiting your program’s environment
    -   3.6. Trust
    -   3.7. Race Conditions
-    Chapter 4. Localization and Internationalization - L10N and I18N
    -   4.1. Programming I18N Compliant Applications
    -   4.2. Localized Messages with POSIX.1 Native Language Support
        (NLS)
-    Chapter 5. Source Tree Guidelines and Policies
    -   5.1. Style Guidelines
    -   5.2. MAINTAINER on Makefiles
    -   5.3. Contributed Software
    -   5.4. Encumbered Files
    -   5.5. Shared Libraries
-    Chapter 6. Regression and Performance Testing
    -   6.1. Micro Benchmark Checklist
    -   6.2. The FreeBSD Source Tinderbox
    -   6.3. The index.cgi Script
    -   6.4. Official Build Servers
    -   6.5. Official Summary Site
-    Part II. Interprocess Communication
-    Chapter 7. Sockets
    -   7.1. Synopsis
    -   7.2. Networking and Diversity
    -   7.3. Protocols
    -   7.4. The Sockets Model
    -   7.5. Essential Socket Functions
    -   7.6. Helper Functions
    -   7.7. Concurrent Servers
-    Chapter 8. IPv6 Internals
    -   8.1. IPv6/IPsec Implementation
-    Part III. Kernel
-    Chapter 9. Building and Installing a FreeBSD Kernel
    -   9.1. Building the Faster but Brittle Way
-    Chapter 10. Kernel Debugging
    -   10.1. Obtaining a Kernel Crash Dump
    -   10.2. Debugging a Kernel Crash Dump with kgdb
    -   10.3. On-Line Kernel Debugging Using DDB
    -   10.4. On-Line Kernel Debugging Using Remote GDB
    -   10.5. Debugging a Console Driver
    -   10.6. Debugging Deadlocks
    -   10.7. Kernel debugging with Dcons
    -   10.8. Glossary of Kernel Options for Debugging
-    Part IV. Architectures
-    Chapter 11. x86 Assembly Language Programming
    -   A.1. Synopsis
    -   A.2. The Tools
    -   A.3. System Calls
    -   A.4. Return Values
    -   A.5. Creating Portable Code
    -   A.6. Our First Program
    -   A.7. Writing UNIX® Filters
    -   A.8. Buffered Input and Output
    -   A.9. Command Line Arguments
    -   A.10. UNIX® Environment
    -   A.11. Working with Files
    -   A.12. One-Pointed Mind
    -   A.13. Using the FPU
    -   A.14. Caveats
    -   A.15. Acknowledgements
-    Part V. Appendices
-    Appendices
-   

Book menu

Chapter 10. Kernel Debugging

Table of Contents

-   10.1. Obtaining a Kernel Crash Dump
-   10.2. Debugging a Kernel Crash Dump with kgdb
-   10.3. On-Line Kernel Debugging Using DDB
-   10.4. On-Line Kernel Debugging Using Remote GDB
-   10.5. Debugging a Console Driver
-   10.6. Debugging Deadlocks
-   10.7. Kernel debugging with Dcons
-   10.8. Glossary of Kernel Options for Debugging

10.1. Obtaining a Kernel Crash Dump

When running a development kernel (e.g., FreeBSD-CURRENT), such as a
kernel under extreme conditions (e.g., very high load averages, tens of
thousands of connections, exceedingly high number of concurrent users,
hundreds of jail(8)s, etc.), or using a new feature or device driver on
FreeBSD-STABLE (e.g., PAE), sometimes a kernel will panic. In the event
that it does, this chapter will demonstrate how to extract useful
information out of a crash.

A system reboot is inevitable once a kernel panics. Once a system is
rebooted, the contents of a system’s physical memory (RAM) is lost, as
well as any bits that are on the swap device before the panic. To
preserve the bits in physical memory, the kernel makes use of the swap
device as a temporary place to store the bits that are in RAM across a
reboot after a crash. In doing this, when FreeBSD boots after a crash, a
kernel image can now be extracted and debugging can take place.

+-----------------------------------+-----------------------------------+
|                                   | A swap device that has been       |
|                                   | configured as a dump device still |
|                                   | acts as a swap device. Dumps to   |
|                                   | non-swap devices (such as tapes   |
|                                   | or CDRWs, for example) are not    |
|                                   | supported at this time. A "swap   |
|                                   | device" is synonymous with a      |
|                                   | "swap partition."                 |
+-----------------------------------+-----------------------------------+

Several types of kernel crash dumps are available:

Full memory dumps

    Hold the complete contents of physical memory.

Minidumps

    Hold only memory pages in use by the kernel (FreeBSD 6.2 and
    higher).

Textdumps

    Hold captured, scripted, or interactive debugger output (FreeBSD 7.1
    and higher).

Minidumps are the default dump type as of FreeBSD 7.0, and in most cases
will capture all necessary information present in a full memory dump, as
most problems can be isolated only using kernel state.

10.1.1. Configuring the Dump Device

Before the kernel will dump the contents of its physical memory to a
dump device, a dump device must be configured. A dump device is
specified by using the dumpon(8) command to tell the kernel where to
save kernel crash dumps. The dumpon(8) program must be called after the
swap partition has been configured with swapon(8). This is normally
handled by setting the dumpdev variable in rc.conf(5) to the path of the
swap device (the recommended way to extract a kernel dump) or AUTO to
use the first configured swap device. The default for dumpdev is AUTO in
HEAD, and changed to NO on RELENG_* branches (except for RELENG_7, which
was left set to AUTO). On FreeBSD 9.0-RELEASE and later versions,
bsdinstall will ask whether crash dumps should be enabled on the target
system during the install process.

+-----------------------------------+-----------------------------------+
|                                   | Check /etc/fstab or swapinfo(8)   |
|                                   | for a list of swap devices.       |
+-----------------------------------+-----------------------------------+

+-----------------------------------+-----------------------------------+
|                                   | Make sure the dumpdir specified   |
|                                   | in rc.conf(5) exists before a     |
|                                   | kernel crash!                     |
|                                   |                                   |
|                                   |     # mkdir /var/crash            |
|                                   |     # chmod 700 /var/crash        |
|                                   |                                   |
|                                   | Also, remember that the contents  |
|                                   | of /var/crash is sensitive and    |
|                                   | very likely contains confidential |
|                                   | information such as passwords.    |
+-----------------------------------+-----------------------------------+

10.1.2. Extracting a Kernel Dump

Once a dump has been written to a dump device, the dump must be
extracted before the swap device is mounted. To extract a dump from a
dump device, use the savecore(8) program. If dumpdev has been set in
rc.conf(5), savecore(8) will be called automatically on the first
multi-user boot after the crash and before the swap device is mounted.
The location of the extracted core is placed in the rc.conf(5) value
dumpdir, by default /var/crash and will be named vmcore.0.

In the event that there is already a file called vmcore.0 in /var/crash
(or whatever dumpdir is set to), the kernel will increment the trailing
number for every crash to avoid overwriting an existing vmcore (e.g.,
vmcore.1). savecore(8) will always create a symbolic link to named
vmcore.last in /var/crash after a dump is saved. This symbolic link can
be used to locate the name of the most recent dump.

The crashinfo(8) utility generates a text file containing a summary of
information from a full memory dump or minidump. If dumpdev has been set
in rc.conf(5), crashinfo(8) will be invoked automatically after
savecore(8). The output is saved to a file in dumpdir named core.txt.N.

+-----------------------------------+-----------------------------------+
|                                   | If you are testing a new kernel   |
|                                   | but need to boot a different one  |
|                                   | in order to get your system up    |
|                                   | and running again, boot it only   |
|                                   | into single user mode using the   |
|                                   | -s flag at the boot prompt, and   |
|                                   | then perform the following steps: |
|                                   |                                   |
|                                   |     # fsck -p                     |
|                                   |     # mount -a -t ufs       #     |
|                                   |  make sure /var/crash is writable |
|                                   |                                   |
|                                   | # savecore /var/crash /dev/ad0s1b |
|                                   |     # exit                        |
|                                   |              # exit to multi-user |
|                                   |                                   |
|                                   | This instructs savecore(8) to     |
|                                   | extract a kernel dump from        |
|                                   | /dev/ad0s1b and place the         |
|                                   | contents in /var/crash. Do not    |
|                                   | forget to make sure the           |
|                                   | destination directory /var/crash  |
|                                   | has enough space for the dump.    |
|                                   | Also, do not forget to specify    |
|                                   | the correct path to your swap     |
|                                   | device as it is likely different  |
|                                   | than /dev/ad0s1b!                 |
+-----------------------------------+-----------------------------------+

10.1.3. Testing Kernel Dump Configuration

The kernel includes a sysctl(8) node that requests a kernel panic. This
can be used to verify that your system is properly configured to save
kernel crash dumps. You may wish to remount existing file systems as
read-only in single user mode before triggering the crash to avoid data
loss.

    # shutdown now
    ...
    Enter full pathname of shell or RETURN for /bin/sh:
    # mount -a -u -r
    # sysctl debug.kdb.panic=1
    debug.kdb.panic:panic: kdb_sysctl_panic
    ...

After rebooting, your system should save a dump in /var/crash along with
a matching summary from crashinfo(8).

10.2. Debugging a Kernel Crash Dump with kgdb

+-----------------------------------+-----------------------------------+
|                                   | This section covers kgdb(1). The  |
|                                   | latest version is included in the |
|                                   | devel/gdb. An older version is    |
|                                   | also present in FreeBSD 11 and    |
|                                   | earlier.                          |
+-----------------------------------+-----------------------------------+

To enter into the debugger and begin getting information from the dump,
start kgdb:

    # kgdb -n N

Where N is the suffix of the vmcore.N to examine. To open the most
recent dump use:

    # kgdb -n last

Normally, kgdb(1) should be able to locate the kernel running at the
time the dump was generated. If it is not able to locate the correct
kernel, pass the pathname of the kernel and dump as two arguments to
kgdb:

    # kgdb /boot/kernel/kernel /var/crash/vmcore.0

You can debug the crash dump using the kernel sources just like you can
for any other program.

This dump is from a 5.2-BETA kernel and the crash comes from deep within
the kernel. The output below has been modified to include line numbers
on the left. This first trace inspects the instruction pointer and
obtains a back trace. The address that is used on line 41 for the list
command is the instruction pointer and can be found on line 17. Most
developers will request having at least this information sent to them if
you are unable to debug the problem yourself. If, however, you do solve
the problem, make sure that your patch winds its way into the source
tree via a problem report, mailing lists, or by being able to commit it!

     1:# cd /usr/obj/usr/src/sys/KERNCONF
     2:# kgdb kernel.debug /var/crash/vmcore.0
     3:GNU gdb 5.2.1 (FreeBSD)
     4:Copyright 2002 Free Software Foundation, Inc.
     5:GDB is free software, covered by the GNU General Public License, and you are
     6:welcome to change it and/or distribute copies of it under certain conditions.
     7:Type "show copying" to see the conditions.
     8:There is absolutely no warranty for GDB.  Type "show warranty" for details.
     9:This GDB was configured as "i386-undermydesk-freebsd"...
    10:panic: page fault
    11:panic messages:
    12:---
    13:Fatal trap 12: page fault while in kernel mode
    14:cpuid = 0; apic id = 00
    15:fault virtual address   = 0x300
    16:fault code:             = supervisor read, page not present
    17:instruction pointer     = 0x8:0xc0713860
    18:stack pointer           = 0x10:0xdc1d0b70
    19:frame pointer           = 0x10:0xdc1d0b7c
    20:code segment            = base 0x0, limit 0xfffff, type 0x1b
    21:                        = DPL 0, pres 1, def32 1, gran 1
    22:processor eflags        = resume, IOPL = 0
    23:current process         = 14394 (uname)
    24:trap number             = 12
    25:panic: page fault
    26      cpuid = 0;
    27:Stack backtrace:
    28
    29:syncing disks, buffers remaining... 2199 2199 panic: mi_switch: switch in a critical section
    30:cpuid = 0;
    31:Uptime: 2h43m19s
    32:Dumping 255 MB
    33: 16 32 48 64 80 96 112 128 144 160 176 192 208 224 240
    34:---
    35:Reading symbols from /boot/kernel/snd_maestro3.ko...done.
    36:Loaded symbols for /boot/kernel/snd_maestro3.ko
    37:Reading symbols from /boot/kernel/snd_pcm.ko...done.
    38:Loaded symbols for /boot/kernel/snd_pcm.ko
    39:#0  doadump () at /usr/src/sys/kern/kern_shutdown.c:240
    40:240             dumping++;
    41:(kgdb) list *0xc0713860
    42:0xc0713860 is in lapic_ipi_wait (/usr/src/sys/i386/i386/local_apic.c:663).
    43:658                     incr = 0;
    44:659                     delay = 1;
    45:660             } else
    46:661                     incr = 1;
    47:662             for (x = 0; x < delay; x += incr) {
    48:663                     if ((lapic->icr_lo & APIC_DELSTAT_MASK) == APIC_DELSTAT_IDLE)
    49:664                             return (1);
    50:665                     ia32_pause();
    51:666             }
    52:667             return (0);
    53:(kgdb) backtrace
    54:#0  doadump () at /usr/src/sys/kern/kern_shutdown.c:240
    55:#1  0xc055fd9b in boot (howto=260) at /usr/src/sys/kern/kern_shutdown.c:372
    56:#2  0xc056019d in panic () at /usr/src/sys/kern/kern_shutdown.c:550
    57:#3  0xc0567ef5 in mi_switch () at /usr/src/sys/kern/kern_synch.c:470
    58:#4  0xc055fa87 in boot (howto=256) at /usr/src/sys/kern/kern_shutdown.c:312
    59:#5  0xc056019d in panic () at /usr/src/sys/kern/kern_shutdown.c:550
    60:#6  0xc0720c66 in trap_fatal (frame=0xdc1d0b30, eva=0)
    61:    at /usr/src/sys/i386/i386/trap.c:821
    62:#7  0xc07202b3 in trap (frame=
    63:      {tf_fs = -1065484264, tf_es = -1065484272, tf_ds = -1065484272, tf_edi = 1, tf_esi = 0, tf_ebp = -602076292, tf_isp = -602076324, tf_ebx = 0, tf_edx = 0, tf_ecx = 1000000, tf_eax = 243, tf_trapno = 12, tf_err = 0, tf_eip = -1066321824, tf_cs = 8, tf_eflags = 65671, tf_esp = 243, tf_ss = 0})
    64:    at /usr/src/sys/i386/i386/trap.c:250
    65:#8  0xc070c9f8 in calltrap () at {standard input}:94
    66:#9  0xc07139f3 in lapic_ipi_vectored (vector=0, dest=0)
    67:    at /usr/src/sys/i386/i386/local_apic.c:733
    68:#10 0xc0718b23 in ipi_selected (cpus=1, ipi=1)
    69:    at /usr/src/sys/i386/i386/mp_machdep.c:1115
    70:#11 0xc057473e in kseq_notify (ke=0xcc05e360, cpu=0)
    71:    at /usr/src/sys/kern/sched_ule.c:520
    72:#12 0xc0575cad in sched_add (td=0xcbcf5c80)
    73:    at /usr/src/sys/kern/sched_ule.c:1366
    74:#13 0xc05666c6 in setrunqueue (td=0xcc05e360)
    75:    at /usr/src/sys/kern/kern_switch.c:422
    76:#14 0xc05752f4 in sched_wakeup (td=0xcbcf5c80)
    77:    at /usr/src/sys/kern/sched_ule.c:999
    78:#15 0xc056816c in setrunnable (td=0xcbcf5c80)
    79:    at /usr/src/sys/kern/kern_synch.c:570
    80:#16 0xc0567d53 in wakeup (ident=0xcbcf5c80)
    81:    at /usr/src/sys/kern/kern_synch.c:411
    82:#17 0xc05490a8 in exit1 (td=0xcbcf5b40, rv=0)
    83:    at /usr/src/sys/kern/kern_exit.c:509
    84:#18 0xc0548011 in sys_exit () at /usr/src/sys/kern/kern_exit.c:102
    85:#19 0xc0720fd0 in syscall (frame=
    86:      {tf_fs = 47, tf_es = 47, tf_ds = 47, tf_edi = 0, tf_esi = -1, tf_ebp = -1077940712, tf_isp = -602075788, tf_ebx = 672411944, tf_edx = 10, tf_ecx = 672411600, tf_eax = 1, tf_trapno = 12, tf_err = 2, tf_eip = 671899563, tf_cs = 31, tf_eflags = 642, tf_esp = -1077940740, tf_ss = 47})
    87:    at /usr/src/sys/i386/i386/trap.c:1010
    88:#20 0xc070ca4d in Xint0x80_syscall () at {standard input}:136
    89:---Can't read userspace from dump, or kernel process---
    90:(kgdb) quit

+-----------------------------------+-----------------------------------+
|                                   | If your system is crashing        |
|                                   | regularly and you are running out |
|                                   | of disk space, deleting old       |
|                                   | vmcore files in /var/crash could  |
|                                   | save a considerable amount of     |
|                                   | disk space!                       |
+-----------------------------------+-----------------------------------+

10.3. On-Line Kernel Debugging Using DDB

While kgdb as an off-line debugger provides a very high level of user
interface, there are some things it cannot do. The most important ones
being breakpointing and single-stepping kernel code.

If you need to do low-level debugging on your kernel, there is an
on-line debugger available called DDB. It allows setting of breakpoints,
single-stepping kernel functions, examining and changing kernel
variables, etc. However, it cannot access kernel source files, and only
has access to the global and static symbols, not to the full debug
information like kgdb does.

To configure your kernel to include DDB, add the options

    options KDB

    options DDB

to your config file, and rebuild. (See The FreeBSD Handbook for details
on configuring the FreeBSD kernel).

Once your DDB kernel is running, there are several ways to enter DDB.
The first, and earliest way is to use the boot flag -d. The kernel will
start up in debug mode and enter DDB prior to any device probing. Hence
you can even debug the device probe/attach functions. To use this, exit
the loader’s boot menu and enter boot -d at the loader prompt.

The second scenario is to drop to the debugger once the system has
booted. There are two simple ways to accomplish this. If you would like
to break to the debugger from the command prompt, simply type the
command:

    # sysctl debug.kdb.enter=1

Alternatively, if you are at the system console, you may use a hot-key
on the keyboard. The default break-to-debugger sequence is Ctrl+Alt+ESC.
For syscons, this sequence can be remapped and some of the distributed
maps out there do this, so check to make sure you know the right
sequence to use. There is an option available for serial consoles that
allows the use of a serial line BREAK on the console line to enter DDB
(options BREAK_TO_DEBUGGER in the kernel config file). It is not the
default since there are a lot of serial adapters around that
gratuitously generate a BREAK condition, for example when pulling the
cable.

The third way is that any panic condition will branch to DDB if the
kernel is configured to use it. For this reason, it is not wise to
configure a kernel with DDB for a machine running unattended.

To obtain the unattended functionality, add:

    options    KDB_UNATTENDED

to the kernel configuration file and rebuild/reinstall.

The DDB commands roughly resemble some gdb commands. The first thing you
probably need to do is to set a breakpoint:

     break function-name address

Numbers are taken hexadecimal by default, but to make them distinct from
symbol names; hexadecimal numbers starting with the letters a-f need to
be preceded with 0x (this is optional for other numbers). Simple
expressions are allowed, for example: function-name + 0x103.

To exit the debugger and continue execution, type:

     continue

To get a stack trace of the current thread, use:

     trace

To get a stack trace of an arbitrary thread, specify a process ID or
thread ID as a second argument to trace.

If you want to remove a breakpoint, use

     del
     del address-expression

The first form will be accepted immediately after a breakpoint hit, and
deletes the current breakpoint. The second form can remove any
breakpoint, but you need to specify the exact address; this can be
obtained from:

     show b

or:

     show break

To single-step the kernel, try:

     s

This will step into functions, but you can make DDB trace them until the
matching return statement is reached by:

     n

+-----------------------------------+-----------------------------------+
|                                   | This is different from gdb's next |
|                                   | statement; it is like gdb's       |
|                                   | finish. Pressing n more than once |
|                                   | will cause a continue.            |
+-----------------------------------+-----------------------------------+

To examine data from memory, use (for example):

     x/wx 0xf0133fe0,40
     x/hd db_symtab_space
     x/bc termbuf,10
     x/s stringbuf

for word/halfword/byte access, and hexadecimal/decimal/character/ string
display. The number after the comma is the object count. To display the
next 0x10 items, simply use:

     x ,10

Similarly, use

     x/ia foofunc,10

to disassemble the first 0x10 instructions of foofunc, and display them
along with their offset from the beginning of foofunc.

To modify memory, use the write command:

     w/b termbuf 0xa 0xb 0
     w/w 0xf0010030 0 0

The command modifier (b/h/w) specifies the size of the data to be
written, the first following expression is the address to write to and
the remainder is interpreted as data to write to successive memory
locations.

If you need to know the current registers, use:

     show reg

Alternatively, you can display a single register value by e.g.

     p $eax

and modify it by:

     set $eax new-value

Should you need to call some kernel functions from DDB, simply say:

     call func(arg1, arg2, ...)

The return value will be printed.

For a ps(1) style summary of all running processes, use:

     ps

Now you have examined why your kernel failed, and you wish to reboot.
Remember that, depending on the severity of previous malfunctioning, not
all parts of the kernel might still be working as expected. Perform one
of the following actions to shut down and reboot your system:

     panic

This will cause your kernel to dump core and reboot, so you can later
analyze the core on a higher level with kgdb(1).

     call boot(0)

Might be a good way to cleanly shut down the running system, sync() all
disks, and finally, in some cases, reboot. As long as the disk and
filesystem interfaces of the kernel are not damaged, this could be a
good way for an almost clean shutdown.

     reset

This is the final way out of disaster and almost the same as hitting the
Big Red Button.

If you need a short command summary, simply type:

     help

It is highly recommended to have a printed copy of the ddb(4) manual
page ready for a debugging session. Remember that it is hard to read the
on-line manual while single-stepping the kernel.

10.4. On-Line Kernel Debugging Using Remote GDB

The FreeBSD kernel provides a second KDB backend for on-line debugging:
gdb(4). This feature has been supported since FreeBSD 2.2, and it is
actually a very neat one.

GDB has supported remote debugging for a long time. This is done using a
very simple protocol along a serial line. Unlike the other debugging
methods described above, you will need two machines for doing this. One
is the host providing the debugging environment, including all the
sources, and a copy of the kernel binary with all the symbols in it. The
other is the target machine that runs a copy of the very same kernel
(optionally stripped of the debugging information).

In order to use remote GDB, ensure that the following options are
present in your kernel configuration:

    makeoptions     DEBUG=-g
    options         KDB
    options         GDB

Note that the GDB option is turned off by default in GENERIC kernels on
-STABLE and -RELEASE branches, but enabled on -CURRENT.

Once built, copy the kernel to the target machine, and boot it. Connect
the serial line of the target machine that has "flags 080" set on its
uart device to any serial line of the debugging host. See uart(4) for
information on how to set the flags on a uart device.

The target machine must be made to enter the GDB backend, either due to
a panic or by taking a purposeful trap into the debugger. Before doing
this, select the GDB debugger backend:

    # sysctl debug.kdb.current=gdb
    debug.kdb.current: ddb -> gdb

+-----------------------------------+-----------------------------------+
|                                   | The supported backends can be     |
|                                   | listed by the debug.kdb.available |
|                                   | sysctl. If the kernel             |
|                                   | configuration includes            |
|                                   | options DDB, then ddb(4) will be  |
|                                   | selected by default. If gdb does  |
|                                   | not appear in the list of         |
|                                   | available backends, then the      |
|                                   | debug serial port may not have    |
|                                   | been configured correctly.        |
+-----------------------------------+-----------------------------------+

Then, force entry to the debugger:

    # sysctl debug.kdb.enter=1
    debug.kdb.enter: 0KDB: enter: sysctl debug.kdb.enter

The target machine now awaits connection from a remote GDB client. On
the debugging machine, go to the compile directory of the target kernel,
and start gdb:

    # cd /usr/obj/usr/src/amd64.amd64/sys/GENERIC/
    # kgdb kernel
    GNU gdb (GDB) 10.2 [GDB v10.2 for FreeBSD]
    Copyright (C) 2021 Free Software Foundation, Inc.
    ...
    Reading symbols from kernel...
    Reading symbols from /usr/obj/usr/src/amd64.amd64/sys/GENERIC/kernel.debug...
    (kgdb)

Initialize the remote debugging session (assuming the first serial port
is being used) by:

    (kgdb) target remote /dev/cuau0

Your hosting GDB will now gain control over the target kernel:

    Remote debugging using /dev/cuau0
    kdb_enter (why=<optimized out>, msg=<optimized out>) at /usr/src/sys/kern/subr_kdb.c:506
    506                     kdb_why = KDB_WHY_UNSET;
    (kgdb)

+-----------------------------------+-----------------------------------+
|                                   | Depending on the compiler used,   |
|                                   | some local variables may appear   |
|                                   | as <optimized out>, preventing    |
|                                   | them from being inspected         |
|                                   | directly by gdb. If this causes   |
|                                   | problems while debugging, it is   |
|                                   | possible to build the kernel at a |
|                                   | decreased optimization level,     |
|                                   | which may improve the visibility  |
|                                   | of some variables. This can be    |
|                                   | done by passing COPTFLAGS=-O1 to  |
|                                   | make(1). However, certain classes |
|                                   | of kernel bugs may manifest       |
|                                   | differently (or not at all) when  |
|                                   | the optimization level is         |
|                                   | changed.                          |
+-----------------------------------+-----------------------------------+

You can use this session almost as any other GDB session, including full
access to the source, running it in gud-mode inside an Emacs window
(which gives you an automatic source code display in another Emacs
window), etc.

10.5. Debugging a Console Driver

Since you need a console driver to run DDB on, things are more
complicated if the console driver itself is failing. You might remember
the use of a serial console (either with modified boot blocks, or by
specifying -h at the Boot: prompt), and hook up a standard terminal onto
your first serial port. DDB works on any configured console driver,
including a serial console.

10.6. Debugging Deadlocks

You may experience so called deadlocks, a situation where a system stops
doing useful work. To provide a helpful bug report in this situation,
use ddb(4) as described in the previous section. Include the output of
ps and trace for suspected processes in the report.

If possible, consider doing further investigation. The recipe below is
especially useful if you suspect that a deadlock occurs in the VFS
layer. Add these options to the kernel configuration file.

    makeoptions   DEBUG=-g
    options     INVARIANTS
    options     INVARIANT_SUPPORT
    options     WITNESS
    options     WITNESS_SKIPSPIN
    options     DEBUG_LOCKS
    options     DEBUG_VFS_LOCKS
    options     DIAGNOSTIC

When a deadlock occurs, in addition to the output of the ps command,
provide information from the show pcpu, show allpcpu, show locks,
show alllocks, show lockedvnods and alltrace.

To obtain meaningful backtraces for threaded processes, use
thread thread-id to switch to the thread stack, and do a backtrace with
where.

10.7. Kernel debugging with Dcons

dcons(4) is a very simple console driver that is not directly connected
with any physical devices. It just reads and writes characters from and
to a buffer in a kernel or loader. Due to its simple nature, it is very
useful for kernel debugging, especially with a FireWire® device.
Currently, FreeBSD provides two ways to interact with the buffer from
outside of the kernel using dconschat(8).

10.7.1. Dcons over FireWire®

Most FireWire® (IEEE1394) host controllers are based on the OHCI
specification that supports physical access to the host memory. This
means that once the host controller is initialized, we can access the
host memory without the help of software (kernel). We can exploit this
facility for interaction with dcons(4). dcons(4) provides similar
functionality as a serial console. It emulates two serial ports, one for
the console and DDB, the other for GDB. Since remote memory access is
fully handled by the hardware, the dcons(4) buffer is accessible even
when the system crashes.

FireWire® devices are not limited to those integrated into motherboards.
PCI cards exist for desktops, and a cardbus interface can be purchased
for laptops.

10.7.1.1. Enabling FireWire® and Dcons support on the target machine

To enable FireWire® and Dcons support in the kernel of the target
machine:

-   Make sure your kernel supports dcons, dcons_crom and firewire. Dcons
    should be statically linked with the kernel. For dcons_crom and
    firewire, modules should be OK.

-   Make sure physical DMA is enabled. You may need to add
    hw.firewire.phydma_enable=1 to /boot/loader.conf.

-   Add options for debugging.

-   Add dcons_gdb=1 in /boot/loader.conf if you use GDB over FireWire®.

-   Enable dcons in /etc/ttys.

-   Optionally, to force dcons to be the high-level console, add
    hw.firewire.dcons_crom.force_console=1 to loader.conf.

To enable FireWire® and Dcons support in loader(8) on i386 or amd64:

Add LOADER_FIREWIRE_SUPPORT=YES in /etc/make.conf and rebuild loader(8):

    # cd /sys/boot/i386 && make clean && make && make install

To enable dcons(4) as an active low-level console, add
boot_multicons="YES" to /boot/loader.conf.

Here are a few configuration examples. A sample kernel configuration
file would contain:

    device dcons
    device dcons_crom
    options KDB
    options DDB
    options GDB
    options ALT_BREAK_TO_DEBUGGER

And a sample /boot/loader.conf would contain:

    dcons_crom_load="YES"
    dcons_gdb=1
    boot_multicons="YES"
    hw.firewire.phydma_enable=1
    hw.firewire.dcons_crom.force_console=1

10.7.1.2. Enabling FireWire® and Dcons support on the host machine

To enable FireWire® support in the kernel on the host machine:

    # kldload firewire

Find out the EUI64 (the unique 64 bit identifier) of the FireWire® host
controller, and use fwcontrol(8) or dmesg to find the EUI64 of the
target machine.

Run dconschat(8), with:

    # dconschat -e \# -br -G 12345 -t 00-11-22-33-44-55-66-77

The following key combinations can be used once dconschat(8) is running:

+-----------------------------------+-----------------------------------+
| ~+.                               | Disconnect                        |
+-----------------------------------+-----------------------------------+
| ~                                 | ALT BREAK                         |
+-----------------------------------+-----------------------------------+
| ~                                 | RESET target                      |
+-----------------------------------+-----------------------------------+
| ~                                 | Suspend dconschat                 |
+-----------------------------------+-----------------------------------+

Attach remote GDB by starting kgdb(1) with a remote debugging session:

     kgdb -r :12345 kernel

10.7.1.3. Some general tips

Here are some general tips:

To take full advantage of the speed of FireWire®, disable other slow
console drivers:

    # conscontrol delete ttyd0       # serial console
    # conscontrol delete consolectl   # video/keyboard

There exists a GDB mode for emacs(1); this is what you will need to add
to your .emacs:

    (setq gud-gdba-command-name "kgdb -a -a -a -r :12345")
    (setq gdb-many-windows t)
    (xterm-mouse-mode 1)
    M-x gdba

And for DDD (devel/ddd):

    # remote serial protocol
    LANG=C ddd --debugger kgdb -r :12345 kernel
    # live core debug
    LANG=C ddd --debugger kgdb kernel /dev/fwmem0.2

10.7.2. Dcons with KVM

We can directly read the dcons(4) buffer via /dev/mem for live systems,
and in the core dump for crashed systems. These give you similar output
to dmesg -a, but the dcons(4) buffer includes more information.

10.7.2.1. Using Dcons with KVM

To use dcons(4) with KVM:

Dump a dcons(4) buffer of a live system:

    # dconschat -1

Dump a dcons(4) buffer of a crash dump:

    # dconschat -1 -M vmcore.XX

Live core debugging can be done via:

    # fwcontrol -m target_eui64
    # kgdb kernel /dev/fwmem0.2

10.8. Glossary of Kernel Options for Debugging

This section provides a brief glossary of compile-time kernel options
used for debugging:

-   options KDB: compiles in the kernel debugger framework. Required for
    options DDB and options GDB. Little or no performance overhead. By
    default, the debugger will be entered on panic instead of an
    automatic reboot.

-   options KDB_UNATTENDED: change the default value of the
    debug.debugger_on_panic sysctl to 0, which controls whether the
    debugger is entered on panic. When options KDB is not compiled into
    the kernel, the behavior is to automatically reboot on panic; when
    it is compiled into the kernel, the default behavior is to drop into
    the debugger unless options KDB_UNATTENDED is compiled in. If you
    want to leave the kernel debugger compiled into the kernel but want
    the system to come back up unless you’re on-hand to use the debugger
    for diagnostics, use this option.

-   options KDB_TRACE: change the default value of the
    debug.trace_on_panic sysctl to 1, which controls whether the
    debugger automatically prints a stack trace on panic. Especially if
    running with options KDB_UNATTENDED, this can be helpful to gather
    basic debugging information on the serial or firewire console while
    still rebooting to recover.

-   options DDB: compile in support for the console debugger, DDB. This
    interactive debugger runs on whatever the active low-level console
    of the system is, which includes the video console, serial console,
    or firewire console. It provides basic integrated debugging
    facilities, such as stack tracing, process and thread listing,
    dumping of lock state, VM state, file system state, and kernel
    memory management. DDB does not require software running on a second
    machine or being able to generate a core dump or full debugging
    kernel symbols, and provides detailed diagnostics of the kernel at
    run-time. Many bugs can be fully diagnosed using only DDB output.
    This option depends on options KDB.

-   options GDB: compile in support for the remote debugger, GDB, which
    can operate over serial cable or firewire. When the debugger is
    entered, GDB may be attached to inspect structure contents, generate
    stack traces, etc. Some kernel state is more awkward to access than
    in DDB, which is able to generate useful summaries of kernel state
    automatically, such as automatically walking lock debugging or
    kernel memory management structures, and a second machine running
    the debugger is required. On the other hand, GDB combines
    information from the kernel source and full debugging symbols, and
    is aware of full data structure definitions, local variables, and is
    scriptable. This option is not required to run GDB on a kernel core
    dump. This option depends on options KDB.

-   options BREAK_TO_DEBUGGER, options ALT_BREAK_TO_DEBUGGER: allow a
    break signal or alternative signal on the console to enter the
    debugger. If the system hangs without a panic, this is a useful way
    to reach the debugger. Due to the current kernel locking, a break
    signal generated on a serial console is significantly more reliable
    at getting into the debugger, and is generally recommended. This
    option has little or no performance impact.

-   options INVARIANTS: compile into the kernel a large number of
    run-time assertion checks and tests, which constantly test the
    integrity of kernel data structures and the invariants of kernel
    algorithms. These tests can be expensive, so are not compiled in by
    default, but help provide useful "fail stop" behavior, in which
    certain classes of undesired behavior enter the debugger before
    kernel data corruption occurs, making them easier to debug. Tests
    include memory scrubbing and use-after-free testing, which is one of
    the more significant sources of overhead. This option depends on
    options INVARIANT_SUPPORT.

-   options INVARIANT_SUPPORT: many of the tests present in
    options INVARIANTS require modified data structures or additional
    kernel symbols to be defined.

-   options WITNESS: this option enables run-time lock order tracking
    and verification, and is an invaluable tool for deadlock diagnosis.
    WITNESS maintains a graph of acquired lock orders by lock type, and
    checks the graph at each acquire for cycles (implicit or explicit).
    If a cycle is detected, a warning and stack trace are generated to
    the console, indicating that a potential deadlock might have
    occurred. WITNESS is required in order to use the show locks,
    show witness and show alllocks DDB commands. This debug option has
    significant performance overhead, which may be somewhat mitigated
    through the use of options WITNESS_SKIPSPIN. Detailed documentation
    may be found in witness(4).

-   options WITNESS_SKIPSPIN: disable run-time checking of spinlock lock
    order with WITNESS. As spin locks are acquired most frequently in
    the scheduler, and scheduler events occur often, this option can
    significantly speed up systems running with WITNESS. This option
    depends on options WITNESS.

-   options WITNESS_KDB: change the default value of the
    debug.witness.kdb sysctl to 1, which causes WITNESS to enter the
    debugger when a lock order violation is detected, rather than simply
    printing a warning. This option depends on options WITNESS.

-   options SOCKBUF_DEBUG: perform extensive run-time consistency
    checking on socket buffers, which can be useful for debugging both
    socket bugs and race conditions in protocols and device drivers that
    interact with sockets. This option significantly impacts network
    performance, and may change the timing in device driver races.

-   options DEBUG_VFS_LOCKS: track lock acquisition points for
    lockmgr/vnode locks, expanding the amount of information displayed
    by show lockedvnods in DDB. This option has a measurable performance
    impact.

-   options DEBUG_MEMGUARD: a replacement for the malloc(9) kernel
    memory allocator that uses the VM system to detect reads or writes
    from allocated memory after free. Details may be found in
    memguard(9). This option has a significant performance impact, but
    can be very helpful in debugging kernel memory corruption bugs.

-   options DIAGNOSTIC: enable additional, more expensive diagnostic
    tests along the lines of options INVARIANTS.

-   options KASAN: enable the Kernel Address Sanitizer. This enables
    compiler instrumentation which can be used to detect invalid memory
    accesses in the kernel, such as use-after-frees and buffer
    overflows. This largely supersedes options DEBUG_MEMGUARD. See
    kasan(9) for details, and for the currently supported platforms.

-   options KMSAN: enable the Kernel Memory Sanitizer. This enables
    compiler instrumentation which can be used to detect uses of
    uninitialized memory. See kmsan(9) for details, and for the
    currently supported platforms.

<<<<<<< HEAD
=======
------------------------------------------------------------------------
>>>>>>> b1bb5fd9 (Processing txt files in data/doc)

Last modified on: December 11, 2021 by Sergio Carlavilla Delgado

Prev

Home

Next

Table of Contents

-   10.1. Obtaining a Kernel Crash Dump
-   10.2. Debugging a Kernel Crash Dump with kgdb
-   10.3. On-Line Kernel Debugging Using DDB
-   10.4. On-Line Kernel Debugging Using Remote GDB
-   10.5. Debugging a Console Driver
-   10.6. Debugging Deadlocks
-   10.7. Kernel debugging with Dcons
-   10.8. Glossary of Kernel Options for Debugging

<<<<<<< HEAD

=======
------------------------------------------------------------------------

Resources

-   Download PDF
-   Edit this page
>>>>>>> b1bb5fd9 (Processing txt files in data/doc)

