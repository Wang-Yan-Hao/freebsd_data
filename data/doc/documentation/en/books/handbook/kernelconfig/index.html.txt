
-    Preface
    -   Intended Audience
    -   Fourth Edition
    -   Third Edition
    -   Second Edition (2004)
    -   First Edition (2001)
    -   Organization of This Book
    -   Conventions used in this book
    -   Acknowledgments
-    Part I. Getting Started
-    Chapter 1. Introduction
    -   1.1. Synopsis
    -   1.2. Welcome to FreeBSD!
    -   1.3. About the FreeBSD Project
-    Chapter 2. Installing FreeBSD
    -   2.1. Synopsis
    -   2.2. Minimum Hardware Requirements
    -   2.3. Pre-Installation Tasks
    -   2.4. Starting the Installation
    -   2.5. Using bsdinstall
    -   2.6. Allocating Disk Space
    -   2.7. Fetching Distribution Files
    -   2.8. Network Interfaces, Accounts, Time Zone, Services and
        Hardening
    -   2.9. Troubleshooting
    -   2.10. Using the Live CD
-    Chapter 3. FreeBSD Basics
    -   3.1. Synopsis
    -   3.2. Virtual Consoles and Terminals
    -   3.3. Users and Basic Account Management
    -   3.4. Permissions
    -   3.5. Directory Structure
    -   3.6. Disk Organization
    -   3.7. Mounting and Unmounting File Systems
    -   3.8. Processes and Daemons
    -   3.9. Shells
    -   3.10. Text Editors
    -   3.11. Devices and Device Nodes
    -   3.12. Manual Pages
-    Chapter 4. Installing Applications: Packages and Ports
    -   4.1. Synopsis
    -   4.2. Overview of Software Installation
    -   4.3. Finding Software
    -   4.4. Using pkg for Binary Package Management
    -   4.5. Using the Ports Collection
    -   4.6. Building Packages with Poudriere
    -   4.7. Post-Installation Considerations
    -   4.8. Dealing with Broken Ports
-    Chapter 5. The X Window System
    -   5.1. Synopsis
    -   5.2. Installing Xorg
    -   5.3. Graphic card drivers
    -   5.4. Xorg Configuration
    -   5.5. Using Fonts in Xorg
-    Chapter 6. Wayland
    -   6.1. Wayland Synopsis
    -   6.2. The Wayfire Compositor
    -   6.3. The Hikari Compositor
    -   6.4. The Sway Compositor
    -   6.5. Using Xwayland
    -   6.6. Remote Desktop Using VNC
    -   6.7. Wayland Login Manager
    -   6.8. Useful Utilities
-    Chapter 7. Network
    -   7.1. Synopsis
    -   7.2. Setting up the Network
    -   7.3. Wired Networks
    -   7.4. Wireless Networks
    -   7.5. Hostname
    -   7.6. DNS
    -   7.7. Troubleshooting
-    Part II. Common Tasks
-    Chapter 8. Desktop Environments
    -   8.1. Synopsis
    -   8.2. Desktop Environments
    -   8.3. Browsers
    -   8.4. Development tools
    -   8.5. Desktop office productivity
    -   8.6. Document Viewers
    -   8.7. Finance
-    Chapter 9. Multimedia
    -   9.1. Synopsis
    -   9.2. Setting Up the Sound Card
    -   9.3. Audio players
    -   9.4. Video players
    -   9.5. Conferencing and Meetings
    -   9.6. Image Scanners
-    Chapter 10. Configuring the FreeBSD Kernel
    -   10.1. Synopsis
    -   10.2. Why Build a Custom Kernel?
    -   10.3. Finding the System Hardware
    -   10.4. The Configuration File
    -   10.5. Building and Installing a Custom Kernel
    -   10.6. If Something Goes Wrong
-    Chapter 11. Printing
    -   11.1. Quick Start
    -   11.2. Printer Connections
    -   11.3. Common Page Description Languages
    -   11.4. Direct Printing
    -   11.5. LPD (Line Printer Daemon)
    -   11.6. Other Printing Systems
-    Chapter 12. Linux Binary Compatibility
    -   12.1. Synopsis
    -   12.2. Configuring Linux Binary Compatibility
    -   12.3. Linux userlands
    -   12.4. Advanced Topics
-    Chapter 13. WINE
    -   13.1. Synopsis
    -   13.2. WINE Overview & Concepts
    -   13.3. Installing WINE on FreeBSD
    -   13.4. Running a First WINE Program on FreeBSD
    -   13.5. Configuring WINE Installation
    -   13.6. WINE Management GUIs
    -   13.7. WINE in Multi-User FreeBSD Installations
    -   13.8. WINE on FreeBSD FAQ
-    Part III. System Administration
-    Chapter 14. Configuration and Tuning
    -   14.1. Synopsis
    -   14.2. Starting Services
    -   14.3. Configuring cron(8)
    -   14.4. Managing Services in FreeBSD
    -   14.5. Configuring System Logging
    -   14.6. Configuration Files
    -   14.7. Tuning with sysctl(8)
    -   14.8. Tuning Disks
    -   14.9. Tuning Kernel Limits
    -   14.10. Adding Swap Space
    -   14.11. Power and Resource Management
-    Chapter 15. The FreeBSD Booting Process
    -   15.1. Synopsis
    -   15.2. FreeBSD Boot Process
    -   15.3. Device Hints
    -   15.4. Shutdown Sequence
-    Chapter 16. Security
    -   16.1. Synopsis
    -   16.2. Introduction
    -   16.3. One-time Passwords
    -   16.4. TCP Wrapper
    -   16.5. Kerberos
    -   16.6. OpenSSL
    -   16.7. VPN over IPsec
    -   16.8. OpenSSH
    -   16.9. Access Control Lists
    -   16.10. Monitoring Third Party Security Issues
    -   16.11. FreeBSD Security Advisories
    -   16.12. Process Accounting
    -   16.13. Resource Limits
    -   16.14. Shared Administration with Sudo
    -   16.15. Using doas as an alternative to sudo
-    Chapter 17. Jails
    -   17.1. Synopsis
    -   17.2. Terms Related to Jails
    -   17.3. Creating and Controlling Jails
    -   17.4. Fine Tuning and Administration
    -   17.5. Updating Multiple Jails
    -   17.6. Managing Jails with ezjail
-    Chapter 18. Mandatory Access Control
    -   18.1. Synopsis
    -   18.2. Key Terms
    -   18.3. Understanding MAC Labels
    -   18.4. Planning the Security Configuration
    -   18.5. Available MAC Policies
    -   18.6. User Lock Down
    -   18.7. Nagios in a MAC Jail
    -   18.8. Troubleshooting the MAC Framework
-    Chapter 19. Security Event Auditing
    -   19.1. Synopsis
    -   19.2. Key Terms
    -   19.3. Audit Configuration
    -   19.4. Working with Audit Trails
-    Chapter 20. Storage
    -   20.1. Synopsis
    -   20.2. Adding Disks
    -   20.3. Resizing and Growing Disks
    -   20.4. USB Storage Devices
    -   20.5. Creating and Using CD Media
    -   20.6. Creating and Using DVD Media
    -   20.7. Creating and Using Floppy Disks
    -   20.8. Using NTFS Disks
    -   20.9. Backup Basics
    -   20.10. Memory Disks
    -   20.11. File System Snapshots
    -   20.12. Disk Quotas
    -   20.13. Encrypting Disk Partitions
    -   20.14. Encrypting Swap
    -   20.15. Highly Available Storage (HAST)
-    Chapter 21. GEOM: Modular Disk Transformation Framework
    -   21.1. Synopsis
    -   21.2. RAID0 - Striping
    -   21.3. RAID1 - Mirroring
    -   21.4. RAID3 - Byte-level Striping with Dedicated Parity
    -   21.5. Software RAID Devices
    -   21.6. GEOM Gate Network
    -   21.7. Labeling Disk Devices
    -   21.8. UFS Journaling Through GEOM
-    Chapter 22. The Z File System (ZFS)
    -   22.1. What Makes ZFS Different
    -   22.2. Quick Start Guide
    -   22.3. zpool Administration
    -   22.4. zfs Administration
    -   22.5. Delegated Administration
    -   22.6. Advanced Topics
<<<<<<< HEAD
=======
    -   22.7. Further Resources
    -   22.8. ZFS Features and Terminology
-    Chapter 23. Other File Systems
    -   23.1. Synopsis
    -   23.2. Linux® File Systems
-    Chapter 24. Virtualization
    -   24.1. Synopsis
    -   24.2. FreeBSD as a Guest on Parallels Desktop for macOS®
    -   24.3. FreeBSD as a Guest on VMware Fusion for macOS®
    -   24.4. FreeBSD as a Guest on VirtualBox™
    -   24.5. FreeBSD as a Host with VirtualBox™
    -   24.6. FreeBSD as a Host with bhyve
    -   24.7. FreeBSD as a Xen™-Host
-    Chapter 25. Localization - i18n/L10n Usage and Setup
    -   25.1. Synopsis
    -   25.2. Using Localization
    -   25.3. Finding i18n Applications
    -   25.4. Locale Configuration for Specific Languages
-    Chapter 26. Updating and Upgrading FreeBSD
    -   26.1. Synopsis
    -   26.2. FreeBSD Update
    -   26.3. Updating Bootcode
    -   26.4. Updating the Documentation Set
    -   26.5. Tracking a Development Branch
    -   26.6. Updating FreeBSD from Source
    -   26.7. Tracking for Multiple Machines
-    Chapter 27. DTrace
    -   27.1. Synopsis
    -   27.2. Implementation Differences
    -   27.3. Enabling DTrace Support
    -   27.4. Using DTrace
-    Chapter 28. USB Device Mode / USB OTG
    -   28.1. Synopsis
    -   28.2. USB Virtual Serial Ports
    -   28.3. USB Device Mode Network Interfaces
    -   28.4. USB Virtual Storage Device
-    Part IV. Network Communication
-    Chapter 29. Serial Communications
    -   29.1. Synopsis
    -   29.2. Serial Terminology and Hardware
    -   29.3. Terminals
    -   29.4. Dial-in Service
    -   29.5. Dial-out Service
    -   29.6. Setting Up the Serial Console
-    Chapter 30. PPP
    -   30.1. Synopsis
    -   30.2. Configuring PPP
    -   30.3. Troubleshooting PPP Connections
    -   30.4. Using PPP over Ethernet (PPPoE)
    -   30.5. Using PPP over ATM (PPPoA)
-    Chapter 31. Electronic Mail
    -   31.1. Synopsis
    -   31.2. Mail Components
    -   31.3. Sendmail Configuration Files
    -   31.4. Changing the Mail Transfer Agent
    -   31.5. Troubleshooting
    -   31.6. Advanced Topics
    -   31.7. Setting Up to Send Only
    -   31.8. Using Mail with a Dialup Connection
    -   31.9. SMTP Authentication
    -   31.10. Mail User Agents
    -   31.11. Using fetchmail
    -   31.12. Using procmail
-    Chapter 32. Network Servers
    -   32.1. Synopsis
    -   32.2. The inetd Super-Server
    -   32.3. Network File System (NFS)
    -   32.4. Network Information System (NIS)
    -   32.5. Lightweight Directory Access Protocol (LDAP)
    -   32.6. Dynamic Host Configuration Protocol (DHCP)
    -   32.7. Domain Name System (DNS)
    -   32.8. Apache HTTP Server
    -   32.9. File Transfer Protocol (FTP)
    -   32.10. File and Print Services for Microsoft® Windows® Clients
        (Samba)
    -   32.11. Clock Synchronization with NTP
    -   32.12. iSCSI Initiator and Target Configuration
-    Chapter 33. Firewalls
    -   33.1. Synopsis
    -   33.2. Firewall Concepts
    -   33.3. PF
    -   33.4. IPFW
    -   33.5. IPFILTER (IPF)
    -   33.6. Blacklistd
-    Chapter 34. Advanced Networking
    -   34.1. Synopsis
    -   34.2. Gateways and Routes
    -   34.3. Virtual Hosts
    -   34.4. Wireless Advanced Authentication
    -   34.5. Wireless Ad-hoc Mode
    -   34.6. USB Tethering
    -   34.7. Bluetooth
    -   34.8. Bridging
    -   34.9. Link Aggregation and Failover
    -   34.10. Diskless Operation with PXE
    -   34.11. Common Address Redundancy Protocol (CARP)
    -   34.12. VLANs
-    Part V. Appendices
-    Appendix A. Obtaining FreeBSD
    -   A.1. Mirrors
    -   A.2. Using Git
    -   A.3. Using Subversion
    -   A.4. CD and DVD Sets
-    Appendix B. Bibliography
    -   B.1. FreeBSD Bibliography
    -   B.2. Security Reference
    -   B.3. UNIX® History
    -   B.4. Periodicals, Journals, and Magazines
-    Appendix C. Resources on the Internet
    -   C.1. Websites
    -   C.2. Mailing Lists
    -   C.3. Usenet Newsgroups
-    Appendix D. OpenPGP Keys
    -   D.1. Officers
-    FreeBSD Glossary
-    Colophon
-   
-   

Book menu

Chapter 10. Configuring the FreeBSD Kernel

Table of Contents

-   10.1. Synopsis
-   10.2. Why Build a Custom Kernel?
-   10.3. Finding the System Hardware
-   10.4. The Configuration File
-   10.5. Building and Installing a Custom Kernel
-   10.6. If Something Goes Wrong

10.1. Synopsis

The kernel is the core of the FreeBSD operating system. It is
responsible for managing memory, enforcing security controls,
networking, disk access, and much more. While much of FreeBSD is
dynamically configurable, it is still occasionally necessary to
configure and compile a custom kernel.

After reading this chapter, you will know:

-   When to build a custom kernel.

-   How to take a hardware inventory.

-   How to customize a kernel configuration file.

-   How to use the kernel configuration file to create and build a new
    kernel.

-   How to install the new kernel.

-   How to troubleshoot if things go wrong.

All of the commands listed in the examples in this chapter should be
executed as root.

10.2. Why Build a Custom Kernel?

Traditionally, FreeBSD used a monolithic kernel. The kernel was one
large program, supported a fixed list of devices, and in order to change
the kernel’s behavior, one had to compile and then reboot into a new
kernel.

Today, most of the functionality in the FreeBSD kernel is contained in
modules which can be dynamically loaded and unloaded from the kernel as
necessary. This allows the running kernel to adapt immediately to new
hardware and for new functionality to be brought into the kernel. This
is known as a modular kernel.

Occasionally, it is still necessary to perform static kernel
configuration. Sometimes the needed functionality is so tied to the
kernel that it can not be made dynamically loadable. Some security
environments prevent the loading and unloading of kernel modules and
require that only needed functionality is statically compiled into the
kernel.

Building a custom kernel is often a rite of passage for advanced BSD
users. This process, while time consuming, can provide benefits to the
FreeBSD system. Unlike the GENERIC kernel, which must support a wide
range of hardware, a custom kernel can be stripped down to only provide
support for that computer’s hardware. This has a number of benefits,
such as:

-   Faster boot time. Since the kernel will only probe the hardware on
    the system, the time it takes the system to boot can decrease.

-   Lower memory usage. A custom kernel often uses less memory than the
    GENERIC kernel by omitting unused features and device drivers. This
    is important because the kernel code remains resident in physical
    memory at all times, preventing that memory from being used by
    applications. For this reason, a custom kernel is useful on a system
    with a small amount of RAM.

-   Additional hardware support. A custom kernel can add support for
    devices which are not present in the GENERIC kernel.

Before building a custom kernel, consider the reason for doing so. If
there is a need for specific hardware support, it may already exist as a
module.

Kernel modules exist in /boot/kernel and may be dynamically loaded into
the running kernel using kldload(8). Most kernel drivers have a loadable
module and manual page. For example, the ath(4) wireless network driver
has the following information in its manual page:

    Alternatively, to load the driver as a module at boot time, place the
    following line in loader.conf(5):

        if_ath_load="YES"

Adding if_ath_load="YES" to /boot/loader.conf will load this module
dynamically at boot time.

In some cases, there is no associated module in /boot/kernel. This is
mostly true for certain subsystems.

10.3. Finding the System Hardware

Before editing the kernel configuration file, it is recommended to
perform an inventory of the machine’s hardware. On a dual-boot system,
the inventory can be created from the other operating system. For
example, Microsoft®'s Device Manager contains information about
installed devices.

+-----------------------------------+-----------------------------------+
|                                   | Some versions of Microsoft®       |
|                                   | Windows® have a System icon which |
|                                   | can be used to access Device      |
|                                   | Manager.                          |
+-----------------------------------+-----------------------------------+

If FreeBSD is the only installed operating system, use dmesg(8) to
determine the hardware that was found and listed during the boot probe.
Most device drivers on FreeBSD have a manual page which lists the
hardware supported by that driver. For example, the following lines
indicate that the psm(4) driver found a mouse:

    psm0: <PS/2 Mouse> irq 12 on atkbdc0
    psm0: [GIANT-LOCKED]
    psm0: [ITHREAD]
    psm0: model Generic PS/2 mouse, device ID 0

Since this hardware exists, this driver should not be removed from a
custom kernel configuration file.

If the output of dmesg does not display the results of the boot probe
output, instead read the contents of /var/run/dmesg.boot.

Another tool for finding hardware is pciconf(8), which provides more
verbose output. For example:

    % pciconf -lv
    ath0@pci0:3:0:0:        class=0x020000 card=0x058a1014 chip=0x1014168c rev=0x01 hdr=0x00
        vendor     = 'Atheros Communications Inc.'
        device     = 'AR5212 Atheros AR5212 802.11abg wireless'
        class      = network
        subclass   = ethernet

This output shows that the ath driver located a wireless Ethernet
device.

The -k flag of man(1) can be used to provide useful information. For
example, it can be used to display a list of manual pages which contain
a particular device brand or name:

    # man -k Atheros
    ath(4)                   - Atheros IEEE 802.11 wireless network driver
    ath_hal(4)               - Atheros Hardware Access Layer (HAL)

Once the hardware inventory list is created, refer to it to ensure that
drivers for installed hardware are not removed as the custom kernel
configuration is edited.

10.4. The Configuration File

In order to create a custom kernel configuration file and build a custom
kernel, the full FreeBSD source tree must first be installed.

If /usr/src/ does not exist or it is empty, source has not been
installed. Source can be installed with Git using the instructions in
“Using Git”.

Once source is installed, review the contents of /usr/src/sys. This
directory contains a number of subdirectories, including those which
represent the following supported architectures: amd64, i386, powerpc,
and sparc64. Everything inside a particular architecture’s directory
deals with that architecture only and the rest of the code is machine
independent code common to all platforms. Each supported architecture
has a conf subdirectory which contains the GENERIC kernel configuration
file for that architecture.

Do not make edits to GENERIC. Instead, copy the file to a different name
and make edits to the copy. The convention is to use a name with all
capital letters. When maintaining multiple FreeBSD machines with
different hardware, it is a good idea to name it after the machine’s
hostname. This example creates a copy, named MYKERNEL, of the GENERIC
configuration file for the amd64 architecture:

    # cd /usr/src/sys/amd64/conf
    # cp GENERIC MYKERNEL

MYKERNEL can now be customized with any ASCII text editor. The default
editor is vi, though an easier editor for beginners, called ee, is also
installed with FreeBSD.

The format of the kernel configuration file is simple. Each line
contains a keyword that represents a device or subsystem, an argument,
and a brief description. Any text after a # is considered a comment and
ignored. To remove kernel support for a device or subsystem, put a # at
the beginning of the line representing that device or subsystem. Do not
add or remove a # for any line that you do not understand.

+-----------------------------------+-----------------------------------+
|                                   | It is easy to remove support for  |
|                                   | a device or option and end up     |
|                                   | with a broken kernel. For         |
|                                   | example, if the ata(4) driver is  |
|                                   | removed from the kernel           |
|                                   | configuration file, a system      |
|                                   | using ATA disk drivers may not    |
|                                   | boot. When in doubt, just leave   |
|                                   | support in the kernel.            |
+-----------------------------------+-----------------------------------+

In addition to the brief descriptions provided in this file, additional
descriptions are contained in NOTES, which can be found in the same
directory as GENERIC for that architecture. For architecture independent
options, refer to /usr/src/sys/conf/NOTES.

+-----------------------------------+-----------------------------------+
|                                   | When finished customizing the     |
|                                   | kernel configuration file, save a |
|                                   | backup copy to a location outside |
|                                   | of /usr/src.                      |
|                                   |                                   |
|                                   | Alternately, keep the kernel      |
|                                   | configuration file elsewhere and  |
|                                   | create a symbolic link to the     |
|                                   | file:                             |
|                                   |                                   |
|                                   |     # cd /usr/src/sys/amd64/conf  |
|                                   |     # mkdir /root/kernels         |
|                                   |     #                             |
|                                   | cp GENERIC /root/kernels/MYKERNEL |
|                                   |                                   |
|                                   |    # ln -s /root/kernels/MYKERNEL |
+-----------------------------------+-----------------------------------+

An include directive is available for use in configuration files. This
allows another configuration file to be included in the current one,
making it easy to maintain small changes relative to an existing file.
If only a small number of additional options or drivers are required,
this allows a delta to be maintained with respect to GENERIC, as seen in
this example:

    include GENERIC
    ident MYKERNEL

    options         IPFIREWALL
    options         DUMMYNET
    options         IPFIREWALL_DEFAULT_TO_ACCEPT
    options         IPDIVERT

Using this method, the local configuration file expresses local
differences from a GENERIC kernel. As upgrades are performed, new
features added to GENERIC will also be added to the local kernel unless
they are specifically prevented using nooptions or nodevice. A
comprehensive list of configuration directives and their descriptions
may be found in config(5).

+-----------------------------------+-----------------------------------+
|                                   | To build a file which contains    |
|                                   | all available options, run the    |
|                                   | following command as root:        |
|                                   |                                   |
|                                   |     # cd /u                       |
|                                   | sr/src/sys/arch/conf && make LINT |
+-----------------------------------+-----------------------------------+

10.5. Building and Installing a Custom Kernel

Once the edits to the custom configuration file have been saved, the
source code for the kernel can be compiled using the following steps:

Procedure: Building a Kernel

1.  Change to this directory:

        # cd /usr/src

2.  Compile the new kernel by specifying the name of the custom kernel
    configuration file:

        # make buildkernel KERNCONF=MYKERNEL

3.  Install the new kernel associated with the specified kernel
    configuration file. This command will copy the new kernel to
    /boot/kernel/kernel and save the old kernel to
    /boot/kernel.old/kernel:

        # make installkernel KERNCONF=MYKERNEL

4.  Shutdown the system and reboot into the new kernel. If something
    goes wrong, refer to The kernel does not boot.

By default, when a custom kernel is compiled, all kernel modules are
rebuilt. To update a kernel faster or to build only custom modules, edit
/etc/make.conf before starting to build the kernel.

For example, this variable specifies the list of modules to build
instead of using the default of building all modules:

    MODULES_OVERRIDE = linux acpi

Alternately, this variable lists which modules to exclude from the build
process:

    WITHOUT_MODULES = linux acpi sound

Additional variables are available. Refer to make.conf(5) for details.

10.6. If Something Goes Wrong

There are four categories of trouble that can occur when building a
custom kernel:

config fails

    If config fails, it will print the line number that is incorrect. As
    an example, for the following message, make sure that line 17 is
    typed correctly by comparing it to GENERIC or NOTES:

        config: line 17: syntax error

make fails

    If make fails, it is usually due to an error in the kernel
    configuration file which is not severe enough for config to catch.
    Review the configuration, and if the problem is not apparent, send
    an email to the FreeBSD general questions mailing list which
    contains the kernel configuration file.

The kernel does not boot

    If the new kernel does not boot or fails to recognize devices, do
    not panic! Fortunately, FreeBSD has an excellent mechanism for
    recovering from incompatible kernels. Simply choose the kernel to
    boot from at the FreeBSD boot loader. This can be accessed when the
    system boot menu appears by selecting the "Escape to a loader
    prompt" option. At the prompt, type boot kernel.old, or the name of
    any other kernel that is known to boot properly.

    After booting with a good kernel, check over the configuration file
    and try to build it again. One helpful resource is /var/log/messages
    which records the kernel messages from every successful boot. Also,
    dmesg(8) will print the kernel messages from the current boot.

    +-----------------------------------+-----------------------------------+
    |                                   | When troubleshooting a kernel     |
    |                                   | make sure to keep a copy of a     |
    |                                   | kernel that is known to work,     |
    |                                   | such as GENERIC. This is          |
    |                                   | important because every time a    |
    |                                   | new kernel is installed,          |
    |                                   | kernel.old is overwritten with    |
    |                                   | the last installed kernel, which  |
    |                                   | may or may not be bootable. As    |
    |                                   | soon as possible, move the        |
    |                                   | working kernel by renaming the    |
    |                                   | directory containing the good     |
    |                                   | kernel:                           |
    |                                   |                                   |
    |                                   |     #                             |
    |                                   |  mv /boot/kernel /boot/kernel.bad |
    |                                   |     #                             |
    |                                   | mv /boot/kernel.good /boot/kernel |
    +-----------------------------------+-----------------------------------+

The kernel works, but ps(1) does not

    If the kernel version differs from the one that the system utilities
    have been built with, for example, a kernel built from -CURRENT
    sources is installed on a -RELEASE system, many system status
    commands like ps(1) and vmstat(8) will not work. To fix this,
    recompile and install a world built with the same version of the
    source tree as the kernel. It is never a good idea to use a
    different version of the kernel than the rest of the operating
    system.

------------------------------------------------------------------------

Last modified on: July 6, 2023 by Sergio Carlavilla Delgado

Prev

Home

Next

Table of Contents

-   10.1. Synopsis
-   10.2. Why Build a Custom Kernel?
-   10.3. Finding the System Hardware
-   10.4. The Configuration File
-   10.5. Building and Installing a Custom Kernel
-   10.6. If Something Goes Wrong

------------------------------------------------------------------------

Resources

-   Download PDF
-   Edit this page
>>>>>>> b1bb5fd9 (Processing txt files in data/doc)

