
-    Preface
    -   Intended Audience
    -   Fourth Edition
    -   Third Edition
    -   Second Edition (2004)
    -   First Edition (2001)
    -   Organization of This Book
    -   Conventions used in this book
    -   Acknowledgments
-    Part I. Getting Started
-    Chapter 1. Introduction
    -   1.1. Synopsis
    -   1.2. Welcome to FreeBSD!
    -   1.3. About the FreeBSD Project
-    Chapter 2. Installing FreeBSD
    -   2.1. Synopsis
    -   2.2. Minimum Hardware Requirements
    -   2.3. Pre-Installation Tasks
    -   2.4. Starting the Installation
    -   2.5. Using bsdinstall
    -   2.6. Allocating Disk Space
    -   2.7. Fetching Distribution Files
    -   2.8. Network Interfaces, Accounts, Time Zone, Services and
        Hardening
    -   2.9. Troubleshooting
    -   2.10. Using the Live CD
-    Chapter 3. FreeBSD Basics
    -   3.1. Synopsis
    -   3.2. Virtual Consoles and Terminals
    -   3.3. Users and Basic Account Management
    -   3.4. Permissions
    -   3.5. Directory Structure
    -   3.6. Disk Organization
    -   3.7. Mounting and Unmounting File Systems
    -   3.8. Processes and Daemons
    -   3.9. Shells
    -   3.10. Text Editors
    -   3.11. Devices and Device Nodes
    -   3.12. Manual Pages
-    Chapter 4. Installing Applications: Packages and Ports
    -   4.1. Synopsis
    -   4.2. Overview of Software Installation
    -   4.3. Finding Software
    -   4.4. Using pkg for Binary Package Management
    -   4.5. Using the Ports Collection
    -   4.6. Building Packages with Poudriere
    -   4.7. Post-Installation Considerations
    -   4.8. Dealing with Broken Ports
-    Chapter 5. The X Window System
    -   5.1. Synopsis
    -   5.2. Installing Xorg
    -   5.3. Graphic card drivers
    -   5.4. Xorg Configuration
    -   5.5. Using Fonts in Xorg
-    Chapter 6. Wayland
    -   6.1. Wayland Synopsis
    -   6.2. The Wayfire Compositor
    -   6.3. The Hikari Compositor
    -   6.4. The Sway Compositor
    -   6.5. Using Xwayland
    -   6.6. Remote Desktop Using VNC
    -   6.7. Wayland Login Manager
    -   6.8. Useful Utilities
-    Chapter 7. Network
    -   7.1. Synopsis
    -   7.2. Setting up the Network
    -   7.3. Wired Networks
    -   7.4. Wireless Networks
    -   7.5. Hostname
    -   7.6. DNS
    -   7.7. Troubleshooting
-    Part II. Common Tasks
-    Chapter 8. Desktop Environments
    -   8.1. Synopsis
    -   8.2. Desktop Environments
    -   8.3. Browsers
    -   8.4. Development tools
    -   8.5. Desktop office productivity
    -   8.6. Document Viewers
    -   8.7. Finance
-    Chapter 9. Multimedia
    -   9.1. Synopsis
    -   9.2. Setting Up the Sound Card
    -   9.3. Audio players
    -   9.4. Video players
    -   9.5. Conferencing and Meetings
    -   9.6. Image Scanners
-    Chapter 10. Configuring the FreeBSD Kernel
    -   10.1. Synopsis
    -   10.2. Why Build a Custom Kernel?
    -   10.3. Finding the System Hardware
    -   10.4. The Configuration File
    -   10.5. Building and Installing a Custom Kernel
    -   10.6. If Something Goes Wrong
-    Chapter 11. Printing
    -   11.1. Quick Start
    -   11.2. Printer Connections
    -   11.3. Common Page Description Languages
    -   11.4. Direct Printing
    -   11.5. LPD (Line Printer Daemon)
    -   11.6. Other Printing Systems
-    Chapter 12. Linux Binary Compatibility
    -   12.1. Synopsis
    -   12.2. Configuring Linux Binary Compatibility
    -   12.3. Linux userlands
    -   12.4. Advanced Topics
-    Chapter 13. WINE
    -   13.1. Synopsis
    -   13.2. WINE Overview & Concepts
    -   13.3. Installing WINE on FreeBSD
    -   13.4. Running a First WINE Program on FreeBSD
    -   13.5. Configuring WINE Installation
    -   13.6. WINE Management GUIs
    -   13.7. WINE in Multi-User FreeBSD Installations
    -   13.8. WINE on FreeBSD FAQ
-    Part III. System Administration
-    Chapter 14. Configuration and Tuning
    -   14.1. Synopsis
    -   14.2. Starting Services
    -   14.3. Configuring cron(8)
    -   14.4. Managing Services in FreeBSD
    -   14.5. Configuring System Logging
    -   14.6. Configuration Files
    -   14.7. Tuning with sysctl(8)
    -   14.8. Tuning Disks
    -   14.9. Tuning Kernel Limits
    -   14.10. Adding Swap Space
    -   14.11. Power and Resource Management
-    Chapter 15. The FreeBSD Booting Process
    -   15.1. Synopsis
    -   15.2. FreeBSD Boot Process
    -   15.3. Device Hints
    -   15.4. Shutdown Sequence
-    Chapter 16. Security
    -   16.1. Synopsis
    -   16.2. Introduction
    -   16.3. One-time Passwords
    -   16.4. TCP Wrapper
    -   16.5. Kerberos
    -   16.6. OpenSSL
    -   16.7. VPN over IPsec
    -   16.8. OpenSSH
    -   16.9. Access Control Lists
    -   16.10. Monitoring Third Party Security Issues
    -   16.11. FreeBSD Security Advisories
    -   16.12. Process Accounting
    -   16.13. Resource Limits
    -   16.14. Shared Administration with Sudo
    -   16.15. Using doas as an alternative to sudo
-    Chapter 17. Jails
    -   17.1. Synopsis
    -   17.2. Terms Related to Jails
    -   17.3. Creating and Controlling Jails
    -   17.4. Fine Tuning and Administration
    -   17.5. Updating Multiple Jails
    -   17.6. Managing Jails with ezjail
-    Chapter 18. Mandatory Access Control
    -   18.1. Synopsis
    -   18.2. Key Terms
    -   18.3. Understanding MAC Labels
    -   18.4. Planning the Security Configuration
    -   18.5. Available MAC Policies
    -   18.6. User Lock Down
    -   18.7. Nagios in a MAC Jail
    -   18.8. Troubleshooting the MAC Framework
-    Chapter 19. Security Event Auditing
    -   19.1. Synopsis
    -   19.2. Key Terms
    -   19.3. Audit Configuration
    -   19.4. Working with Audit Trails
-    Chapter 20. Storage
    -   20.1. Synopsis
    -   20.2. Adding Disks
    -   20.3. Resizing and Growing Disks
    -   20.4. USB Storage Devices
    -   20.5. Creating and Using CD Media
    -   20.6. Creating and Using DVD Media
    -   20.7. Creating and Using Floppy Disks
    -   20.8. Using NTFS Disks
    -   20.9. Backup Basics
    -   20.10. Memory Disks
    -   20.11. File System Snapshots
    -   20.12. Disk Quotas
    -   20.13. Encrypting Disk Partitions
    -   20.14. Encrypting Swap
    -   20.15. Highly Available Storage (HAST)
-    Chapter 21. GEOM: Modular Disk Transformation Framework
    -   21.1. Synopsis
    -   21.2. RAID0 - Striping
    -   21.3. RAID1 - Mirroring
    -   21.4. RAID3 - Byte-level Striping with Dedicated Parity
    -   21.5. Software RAID Devices
    -   21.6. GEOM Gate Network
    -   21.7. Labeling Disk Devices
    -   21.8. UFS Journaling Through GEOM
-    Chapter 22. The Z File System (ZFS)
    -   22.1. What Makes ZFS Different
    -   22.2. Quick Start Guide
    -   22.3. zpool Administration
    -   22.4. zfs Administration
    -   22.5. Delegated Administration
    -   22.6. Advanced Topics
<<<<<<< HEAD
=======
    -   22.7. Further Resources
    -   22.8. ZFS Features and Terminology
-    Chapter 23. Other File Systems
    -   23.1. Synopsis
    -   23.2. Linux® File Systems
-    Chapter 24. Virtualization
    -   24.1. Synopsis
    -   24.2. FreeBSD as a Guest on Parallels Desktop for macOS®
    -   24.3. FreeBSD as a Guest on VMware Fusion for macOS®
    -   24.4. FreeBSD as a Guest on VirtualBox™
    -   24.5. FreeBSD as a Host with VirtualBox™
    -   24.6. FreeBSD as a Host with bhyve
    -   24.7. FreeBSD as a Xen™-Host
-    Chapter 25. Localization - i18n/L10n Usage and Setup
    -   25.1. Synopsis
    -   25.2. Using Localization
    -   25.3. Finding i18n Applications
    -   25.4. Locale Configuration for Specific Languages
-    Chapter 26. Updating and Upgrading FreeBSD
    -   26.1. Synopsis
    -   26.2. FreeBSD Update
    -   26.3. Updating Bootcode
    -   26.4. Updating the Documentation Set
    -   26.5. Tracking a Development Branch
    -   26.6. Updating FreeBSD from Source
    -   26.7. Tracking for Multiple Machines
-    Chapter 27. DTrace
    -   27.1. Synopsis
    -   27.2. Implementation Differences
    -   27.3. Enabling DTrace Support
    -   27.4. Using DTrace
-    Chapter 28. USB Device Mode / USB OTG
    -   28.1. Synopsis
    -   28.2. USB Virtual Serial Ports
    -   28.3. USB Device Mode Network Interfaces
    -   28.4. USB Virtual Storage Device
-    Part IV. Network Communication
-    Chapter 29. Serial Communications
    -   29.1. Synopsis
    -   29.2. Serial Terminology and Hardware
    -   29.3. Terminals
    -   29.4. Dial-in Service
    -   29.5. Dial-out Service
    -   29.6. Setting Up the Serial Console
-    Chapter 30. PPP
    -   30.1. Synopsis
    -   30.2. Configuring PPP
    -   30.3. Troubleshooting PPP Connections
    -   30.4. Using PPP over Ethernet (PPPoE)
    -   30.5. Using PPP over ATM (PPPoA)
-    Chapter 31. Electronic Mail
    -   31.1. Synopsis
    -   31.2. Mail Components
    -   31.3. Sendmail Configuration Files
    -   31.4. Changing the Mail Transfer Agent
    -   31.5. Troubleshooting
    -   31.6. Advanced Topics
    -   31.7. Setting Up to Send Only
    -   31.8. Using Mail with a Dialup Connection
    -   31.9. SMTP Authentication
    -   31.10. Mail User Agents
    -   31.11. Using fetchmail
    -   31.12. Using procmail
-    Chapter 32. Network Servers
    -   32.1. Synopsis
    -   32.2. The inetd Super-Server
    -   32.3. Network File System (NFS)
    -   32.4. Network Information System (NIS)
    -   32.5. Lightweight Directory Access Protocol (LDAP)
    -   32.6. Dynamic Host Configuration Protocol (DHCP)
    -   32.7. Domain Name System (DNS)
    -   32.8. Apache HTTP Server
    -   32.9. File Transfer Protocol (FTP)
    -   32.10. File and Print Services for Microsoft® Windows® Clients
        (Samba)
    -   32.11. Clock Synchronization with NTP
    -   32.12. iSCSI Initiator and Target Configuration
-    Chapter 33. Firewalls
    -   33.1. Synopsis
    -   33.2. Firewall Concepts
    -   33.3. PF
    -   33.4. IPFW
    -   33.5. IPFILTER (IPF)
    -   33.6. Blacklistd
-    Chapter 34. Advanced Networking
    -   34.1. Synopsis
    -   34.2. Gateways and Routes
    -   34.3. Virtual Hosts
    -   34.4. Wireless Advanced Authentication
    -   34.5. Wireless Ad-hoc Mode
    -   34.6. USB Tethering
    -   34.7. Bluetooth
    -   34.8. Bridging
    -   34.9. Link Aggregation and Failover
    -   34.10. Diskless Operation with PXE
    -   34.11. Common Address Redundancy Protocol (CARP)
    -   34.12. VLANs
-    Part V. Appendices
-    Appendix A. Obtaining FreeBSD
    -   A.1. Mirrors
    -   A.2. Using Git
    -   A.3. Using Subversion
    -   A.4. CD and DVD Sets
-    Appendix B. Bibliography
    -   B.1. FreeBSD Bibliography
    -   B.2. Security Reference
    -   B.3. UNIX® History
    -   B.4. Periodicals, Journals, and Magazines
-    Appendix C. Resources on the Internet
    -   C.1. Websites
    -   C.2. Mailing Lists
    -   C.3. Usenet Newsgroups
-    Appendix D. OpenPGP Keys
    -   D.1. Officers
-    FreeBSD Glossary
-    Colophon
-   
-   

Book menu

Chapter 27. DTrace

Table of Contents

-   27.1. Synopsis
-   27.2. Implementation Differences
-   27.3. Enabling DTrace Support
-   27.4. Using DTrace

27.1. Synopsis

DTrace, also known as Dynamic Tracing, was developed by Sun™ as a tool
for locating performance bottlenecks in production and pre-production
systems. In addition to diagnosing performance problems, DTrace can be
used to help investigate and debug unexpected behavior in both the
FreeBSD kernel and in userland programs.

DTrace is a remarkable profiling tool, with an impressive array of
features for diagnosing system issues. It may also be used to run
pre-written scripts to take advantage of its capabilities. Users can
author their own utilities using the DTrace D Language, allowing them to
customize their profiling based on specific needs.

The FreeBSD implementation provides full support for kernel DTrace and
experimental support for userland DTrace. Userland DTrace allows users
to perform function boundary tracing for userland programs using the pid
provider, and to insert static probes into userland programs for later
tracing. Some ports, such as databases/postgresql12-server and
lang/php74 have a DTrace option to enable static probes.

The official guide to DTrace is maintained by the Illumos project at
DTrace Guide.

After reading this chapter, you will know:

-   What DTrace is and what features it provides.

-   Differences between the Solaris™ DTrace implementation and the one
    provided by FreeBSD.

-   How to enable and use DTrace on FreeBSD.

Before reading this chapter, you should:

-   Understand UNIX® and FreeBSD basics (FreeBSD Basics).

-   Have some familiarity with security and how it pertains to FreeBSD
    (Security).

27.2. Implementation Differences

While the DTrace in FreeBSD is similar to that found in Solaris™,
differences do exist. The primary difference is that in FreeBSD, DTrace
is implemented as a set of kernel modules and DTrace can not be used
until the modules are loaded. To load all of the necessary modules:

    # kldload dtraceall

Beginning with FreeBSD 10.0-RELEASE, the modules are automatically
loaded when dtrace is run.

FreeBSD uses the DDB_CTF kernel option to enable support for loading CTF
data from kernel modules and the kernel itself. CTF is the Solaris™
Compact C Type Format which encapsulates a reduced form of debugging
information similar to DWARF and the venerable stabs. CTF data is added
to binaries by the ctfconvert and ctfmerge build tools. The ctfconvert
utility parses
DWARFELF debug sections created by the compiler and ctfmerge merges CTFELF
sections from objects into either executables or shared libraries.

Some different providers exist for FreeBSD than for Solaris™. Most
notable is the dtmalloc provider, which allows tracing malloc() by type
in the FreeBSD kernel. Some of the providers found in Solaris™, such as
cpc and mib, are not present in FreeBSD. These may appear in future
versions of FreeBSD. Moreover, some of the providers available in both
operating systems are not compatible, in the sense that their probes
have different argument types. Thus, D scripts written on Solaris™ may
or may not work unmodified on FreeBSD, and vice versa.

Due to security differences, only root may use DTrace on FreeBSD.
Solaris™ has a few low level security checks which do not yet exist in
FreeBSD. As such, the /dev/dtrace/dtrace is strictly limited to root.

DTrace falls under the Common Development and Distribution License
(CDDL) license. To view this license on FreeBSD, see
/usr/src/cddl/contrib/opensolaris/OPENSOLARIS.LICENSE or view it online
at http://opensource.org/licenses/CDDL-1.0. While a FreeBSD kernel with
DTrace support is BSD licensed, the CDDL is used when the modules are
distributed in binary form or the binaries are loaded.

27.3. Enabling DTrace Support

In FreeBSD 9.2 and 10.0, DTrace support is built into the GENERIC
kernel. Users of earlier versions of FreeBSD or who prefer to statically
compile in DTrace support should add the following lines to a custom
kernel configuration file and recompile the kernel using the
instructions in Configuring the FreeBSD Kernel:

    options         KDTRACE_HOOKS
    options         DDB_CTF
    makeoptions DEBUG=-g
    makeoptions WITH_CTF=1

Users of the AMD64 architecture should also add this line:

    options         KDTRACE_FRAME

This option provides support for FBT. While DTrace will work without
this option, there will be limited support for function boundary
tracing.

Once the FreeBSD system has rebooted into the new kernel, or the DTrace
kernel modules have been loaded using kldload dtraceall, the system will
need support for the Korn shell as the DTrace Toolkit has several
utilities written in ksh. Make sure that the shells/ksh93 package or
port is installed. It is also possible to run these tools under
shells/pdksh or shells/mksh.

Finally, install the current DTrace Toolkit, a collection of ready-made
scripts for collecting system information. There are scripts to check
open files, memory, CPU usage, and a lot more. FreeBSD 10 installs a few
of these scripts into /usr/share/dtrace. On other FreeBSD versions, or
to install the full DTrace Toolkit, use the sysutils/dtrace-toolkit
package or port.

+-----------------------------------+-----------------------------------+
|                                   | The scripts found in              |
|                                   | /usr/share/dtrace have been       |
|                                   | specifically ported to FreeBSD.   |
|                                   | Not all of the scripts found in   |
|                                   | the DTrace Toolkit will work      |
|                                   | as-is on FreeBSD and some scripts |
|                                   | may require some effort in order  |
|                                   | for them to work on FreeBSD.      |
+-----------------------------------+-----------------------------------+

The DTrace Toolkit includes many scripts in the special language of
DTrace. This language is called the D language and it is very similar to
C++. An in depth discussion of the language is beyond the scope of this
document. It is covered extensively in the Illumos Dynamic Tracing
Guide.

27.4. Using DTrace

DTrace scripts consist of a list of one or more probes, or
instrumentation points, where each probe is associated with an action.
Whenever the condition for a probe is met, the associated action is
executed. For example, an action may occur when a file is opened, a
process is started, or a line of code is executed. The action might be
to log some information or to modify context variables. The reading and
writing of context variables allows probes to share information and to
cooperatively analyze the correlation of different events.

To view all probes, the administrator can execute the following command:

    # dtrace -l | more

Each probe has an ID, a PROVIDER (dtrace or fbt), a MODULE, and a
FUNCTION NAME. Refer to dtrace(1) for more information about this
command.

The examples in this section provide an overview of how to use two of
the fully supported scripts from the DTrace Toolkit: the hotkernel and
procsystime scripts.

The hotkernel script is designed to identify which function is using the
most kernel time. It will produce output similar to the following:

    # cd /usr/local/share/dtrace-toolkit
    # ./hotkernel
    Sampling... Hit Ctrl-C to end.

As instructed, use the Ctrl+C key combination to stop the process. Upon
termination, the script will display a list of kernel functions and
timing information, sorting the output in increasing order of time:

    kernel`_thread_lock_flags                                   2   0.0%
    0xc1097063                                                  2   0.0%
    kernel`sched_userret                                        2   0.0%
    kernel`kern_select                                          2   0.0%
    kernel`generic_copyin                                       3   0.0%
    kernel`_mtx_assert                                          3   0.0%
    kernel`vm_fault                                             3   0.0%
    kernel`sopoll_generic                                       3   0.0%
    kernel`fixup_filename                                       4   0.0%
    kernel`_isitmyx                                             4   0.0%
    kernel`find_instance                                        4   0.0%
    kernel`_mtx_unlock_flags                                    5   0.0%
    kernel`syscall                                              5   0.0%
    kernel`DELAY                                                5   0.0%
    0xc108a253                                                  6   0.0%
    kernel`witness_lock                                         7   0.0%
    kernel`read_aux_data_no_wait                                7   0.0%
    kernel`Xint0x80_syscall                                     7   0.0%
    kernel`witness_checkorder                                   7   0.0%
    kernel`sse2_pagezero                                        8   0.0%
    kernel`strncmp                                              9   0.0%
    kernel`spinlock_exit                                       10   0.0%
    kernel`_mtx_lock_flags                                     11   0.0%
    kernel`witness_unlock                                      15   0.0%
    kernel`sched_idletd                                       137   0.3%
    0xc10981a5                                              42139  99.3%

This script will also work with kernel modules. To use this feature, run
the script with -m:

    # ./hotkernel -m
    Sampling... Hit Ctrl-C to end.
    ^C
    MODULE                                                  COUNT   PCNT
    0xc107882e                                                  1   0.0%
    0xc10e6aa4                                                  1   0.0%
    0xc1076983                                                  1   0.0%
    0xc109708a                                                  1   0.0%
    0xc1075a5d                                                  1   0.0%
    0xc1077325                                                  1   0.0%
    0xc108a245                                                  1   0.0%
    0xc107730d                                                  1   0.0%
    0xc1097063                                                  2   0.0%
    0xc108a253                                                 73   0.0%
    kernel                                                    874   0.4%
    0xc10981a5                                             213781  99.6%

The procsystime script captures and prints the system call time usage
for a given process ID (PID) or process name. In the following example,
a new instance of /bin/csh was spawned. Then, procsystime was executed
and remained waiting while a few commands were typed on the other
incarnation of csh. These are the results of this test:

    # ./procsystime -n csh
    Tracing... Hit Ctrl-C to end...
    ^C

    Elapsed Times for processes csh,

             SYSCALL          TIME (ns)
              getpid               6131
           sigreturn               8121
               close              19127
               fcntl              19959
                 dup              26955
             setpgid              28070
                stat              31899
           setitimer              40938
               wait4              62717
           sigaction              67372
         sigprocmask             119091
        gettimeofday             183710
               write             263242
              execve             492547
               ioctl             770073
               vfork            3258923
          sigsuspend            6985124
                read         3988049784

As shown, the read() system call used the most time in nanoseconds while
the getpid() system call used the least amount of time.

------------------------------------------------------------------------

Last modified on: July 6, 2023 by Sergio Carlavilla Delgado

Prev

Home

Next

Table of Contents

-   27.1. Synopsis
-   27.2. Implementation Differences
-   27.3. Enabling DTrace Support
-   27.4. Using DTrace

------------------------------------------------------------------------

Resources

-   Download PDF
-   Edit this page
>>>>>>> b1bb5fd9 (Processing txt files in data/doc)

