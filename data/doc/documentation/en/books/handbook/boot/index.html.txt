
-    Preface
    -   Intended Audience
    -   Fourth Edition
    -   Third Edition
    -   Second Edition (2004)
    -   First Edition (2001)
    -   Organization of This Book
    -   Conventions used in this book
    -   Acknowledgments
-    Part I. Getting Started
-    Chapter 1. Introduction
    -   1.1. Synopsis
    -   1.2. Welcome to FreeBSD!
    -   1.3. About the FreeBSD Project
-    Chapter 2. Installing FreeBSD
    -   2.1. Synopsis
    -   2.2. Minimum Hardware Requirements
    -   2.3. Pre-Installation Tasks
    -   2.4. Starting the Installation
    -   2.5. Using bsdinstall
    -   2.6. Allocating Disk Space
    -   2.7. Fetching Distribution Files
    -   2.8. Network Interfaces, Accounts, Time Zone, Services and
        Hardening
    -   2.9. Troubleshooting
    -   2.10. Using the Live CD
-    Chapter 3. FreeBSD Basics
    -   3.1. Synopsis
    -   3.2. Virtual Consoles and Terminals
    -   3.3. Users and Basic Account Management
    -   3.4. Permissions
    -   3.5. Directory Structure
    -   3.6. Disk Organization
    -   3.7. Mounting and Unmounting File Systems
    -   3.8. Processes and Daemons
    -   3.9. Shells
    -   3.10. Text Editors
    -   3.11. Devices and Device Nodes
    -   3.12. Manual Pages
-    Chapter 4. Installing Applications: Packages and Ports
    -   4.1. Synopsis
    -   4.2. Overview of Software Installation
    -   4.3. Finding Software
    -   4.4. Using pkg for Binary Package Management
    -   4.5. Using the Ports Collection
    -   4.6. Building Packages with Poudriere
    -   4.7. Post-Installation Considerations
    -   4.8. Dealing with Broken Ports
-    Chapter 5. The X Window System
    -   5.1. Synopsis
    -   5.2. Installing Xorg
    -   5.3. Graphic card drivers
    -   5.4. Xorg Configuration
    -   5.5. Using Fonts in Xorg
-    Chapter 6. Wayland
    -   6.1. Wayland Synopsis
    -   6.2. The Wayfire Compositor
    -   6.3. The Hikari Compositor
    -   6.4. The Sway Compositor
    -   6.5. Using Xwayland
    -   6.6. Remote Desktop Using VNC
    -   6.7. Wayland Login Manager
    -   6.8. Useful Utilities
-    Chapter 7. Network
    -   7.1. Synopsis
    -   7.2. Setting up the Network
    -   7.3. Wired Networks
    -   7.4. Wireless Networks
    -   7.5. Hostname
    -   7.6. DNS
    -   7.7. Troubleshooting
-    Part II. Common Tasks
-    Chapter 8. Desktop Environments
    -   8.1. Synopsis
    -   8.2. Desktop Environments
    -   8.3. Browsers
    -   8.4. Development tools
    -   8.5. Desktop office productivity
    -   8.6. Document Viewers
    -   8.7. Finance
-    Chapter 9. Multimedia
    -   9.1. Synopsis
    -   9.2. Setting Up the Sound Card
    -   9.3. Audio players
    -   9.4. Video players
    -   9.5. Conferencing and Meetings
    -   9.6. Image Scanners
-    Chapter 10. Configuring the FreeBSD Kernel
    -   10.1. Synopsis
    -   10.2. Why Build a Custom Kernel?
    -   10.3. Finding the System Hardware
    -   10.4. The Configuration File
    -   10.5. Building and Installing a Custom Kernel
    -   10.6. If Something Goes Wrong
-    Chapter 11. Printing
    -   11.1. Quick Start
    -   11.2. Printer Connections
    -   11.3. Common Page Description Languages
    -   11.4. Direct Printing
    -   11.5. LPD (Line Printer Daemon)
    -   11.6. Other Printing Systems
-    Chapter 12. Linux Binary Compatibility
    -   12.1. Synopsis
    -   12.2. Configuring Linux Binary Compatibility
    -   12.3. Linux userlands
    -   12.4. Advanced Topics
-    Chapter 13. WINE
    -   13.1. Synopsis
    -   13.2. WINE Overview & Concepts
    -   13.3. Installing WINE on FreeBSD
    -   13.4. Running a First WINE Program on FreeBSD
    -   13.5. Configuring WINE Installation
    -   13.6. WINE Management GUIs
    -   13.7. WINE in Multi-User FreeBSD Installations
    -   13.8. WINE on FreeBSD FAQ
-    Part III. System Administration
-    Chapter 14. Configuration and Tuning
    -   14.1. Synopsis
    -   14.2. Starting Services
    -   14.3. Configuring cron(8)
    -   14.4. Managing Services in FreeBSD
    -   14.5. Configuring System Logging
    -   14.6. Configuration Files
    -   14.7. Tuning with sysctl(8)
    -   14.8. Tuning Disks
    -   14.9. Tuning Kernel Limits
    -   14.10. Adding Swap Space
    -   14.11. Power and Resource Management
-    Chapter 15. The FreeBSD Booting Process
    -   15.1. Synopsis
    -   15.2. FreeBSD Boot Process
    -   15.3. Device Hints
    -   15.4. Shutdown Sequence
-    Chapter 16. Security
    -   16.1. Synopsis
    -   16.2. Introduction
    -   16.3. One-time Passwords
    -   16.4. TCP Wrapper
    -   16.5. Kerberos
    -   16.6. OpenSSL
    -   16.7. VPN over IPsec
    -   16.8. OpenSSH
    -   16.9. Access Control Lists
    -   16.10. Monitoring Third Party Security Issues
    -   16.11. FreeBSD Security Advisories
    -   16.12. Process Accounting
    -   16.13. Resource Limits
    -   16.14. Shared Administration with Sudo
    -   16.15. Using doas as an alternative to sudo
-    Chapter 17. Jails
    -   17.1. Synopsis
    -   17.2. Terms Related to Jails
    -   17.3. Creating and Controlling Jails
    -   17.4. Fine Tuning and Administration
    -   17.5. Updating Multiple Jails
    -   17.6. Managing Jails with ezjail
-    Chapter 18. Mandatory Access Control
    -   18.1. Synopsis
    -   18.2. Key Terms
    -   18.3. Understanding MAC Labels
    -   18.4. Planning the Security Configuration
    -   18.5. Available MAC Policies
    -   18.6. User Lock Down
    -   18.7. Nagios in a MAC Jail
    -   18.8. Troubleshooting the MAC Framework
-    Chapter 19. Security Event Auditing
    -   19.1. Synopsis
    -   19.2. Key Terms
    -   19.3. Audit Configuration
    -   19.4. Working with Audit Trails
-    Chapter 20. Storage
    -   20.1. Synopsis
    -   20.2. Adding Disks
    -   20.3. Resizing and Growing Disks
    -   20.4. USB Storage Devices
    -   20.5. Creating and Using CD Media
    -   20.6. Creating and Using DVD Media
    -   20.7. Creating and Using Floppy Disks
    -   20.8. Using NTFS Disks
    -   20.9. Backup Basics
    -   20.10. Memory Disks
    -   20.11. File System Snapshots
    -   20.12. Disk Quotas
    -   20.13. Encrypting Disk Partitions
    -   20.14. Encrypting Swap
    -   20.15. Highly Available Storage (HAST)
-    Chapter 21. GEOM: Modular Disk Transformation Framework
    -   21.1. Synopsis
    -   21.2. RAID0 - Striping
    -   21.3. RAID1 - Mirroring
    -   21.4. RAID3 - Byte-level Striping with Dedicated Parity
    -   21.5. Software RAID Devices
    -   21.6. GEOM Gate Network
    -   21.7. Labeling Disk Devices
    -   21.8. UFS Journaling Through GEOM
-    Chapter 22. The Z File System (ZFS)
    -   22.1. What Makes ZFS Different
    -   22.2. Quick Start Guide
    -   22.3. zpool Administration
    -   22.4. zfs Administration
    -   22.5. Delegated Administration
    -   22.6. Advanced Topics
<<<<<<< HEAD
=======
    -   22.7. Further Resources
    -   22.8. ZFS Features and Terminology
-    Chapter 23. Other File Systems
    -   23.1. Synopsis
    -   23.2. Linux® File Systems
-    Chapter 24. Virtualization
    -   24.1. Synopsis
    -   24.2. FreeBSD as a Guest on Parallels Desktop for macOS®
    -   24.3. FreeBSD as a Guest on VMware Fusion for macOS®
    -   24.4. FreeBSD as a Guest on VirtualBox™
    -   24.5. FreeBSD as a Host with VirtualBox™
    -   24.6. FreeBSD as a Host with bhyve
    -   24.7. FreeBSD as a Xen™-Host
-    Chapter 25. Localization - i18n/L10n Usage and Setup
    -   25.1. Synopsis
    -   25.2. Using Localization
    -   25.3. Finding i18n Applications
    -   25.4. Locale Configuration for Specific Languages
-    Chapter 26. Updating and Upgrading FreeBSD
    -   26.1. Synopsis
    -   26.2. FreeBSD Update
    -   26.3. Updating Bootcode
    -   26.4. Updating the Documentation Set
    -   26.5. Tracking a Development Branch
    -   26.6. Updating FreeBSD from Source
    -   26.7. Tracking for Multiple Machines
-    Chapter 27. DTrace
    -   27.1. Synopsis
    -   27.2. Implementation Differences
    -   27.3. Enabling DTrace Support
    -   27.4. Using DTrace
-    Chapter 28. USB Device Mode / USB OTG
    -   28.1. Synopsis
    -   28.2. USB Virtual Serial Ports
    -   28.3. USB Device Mode Network Interfaces
    -   28.4. USB Virtual Storage Device
-    Part IV. Network Communication
-    Chapter 29. Serial Communications
    -   29.1. Synopsis
    -   29.2. Serial Terminology and Hardware
    -   29.3. Terminals
    -   29.4. Dial-in Service
    -   29.5. Dial-out Service
    -   29.6. Setting Up the Serial Console
-    Chapter 30. PPP
    -   30.1. Synopsis
    -   30.2. Configuring PPP
    -   30.3. Troubleshooting PPP Connections
    -   30.4. Using PPP over Ethernet (PPPoE)
    -   30.5. Using PPP over ATM (PPPoA)
-    Chapter 31. Electronic Mail
    -   31.1. Synopsis
    -   31.2. Mail Components
    -   31.3. Sendmail Configuration Files
    -   31.4. Changing the Mail Transfer Agent
    -   31.5. Troubleshooting
    -   31.6. Advanced Topics
    -   31.7. Setting Up to Send Only
    -   31.8. Using Mail with a Dialup Connection
    -   31.9. SMTP Authentication
    -   31.10. Mail User Agents
    -   31.11. Using fetchmail
    -   31.12. Using procmail
-    Chapter 32. Network Servers
    -   32.1. Synopsis
    -   32.2. The inetd Super-Server
    -   32.3. Network File System (NFS)
    -   32.4. Network Information System (NIS)
    -   32.5. Lightweight Directory Access Protocol (LDAP)
    -   32.6. Dynamic Host Configuration Protocol (DHCP)
    -   32.7. Domain Name System (DNS)
    -   32.8. Apache HTTP Server
    -   32.9. File Transfer Protocol (FTP)
    -   32.10. File and Print Services for Microsoft® Windows® Clients
        (Samba)
    -   32.11. Clock Synchronization with NTP
    -   32.12. iSCSI Initiator and Target Configuration
-    Chapter 33. Firewalls
    -   33.1. Synopsis
    -   33.2. Firewall Concepts
    -   33.3. PF
    -   33.4. IPFW
    -   33.5. IPFILTER (IPF)
    -   33.6. Blacklistd
-    Chapter 34. Advanced Networking
    -   34.1. Synopsis
    -   34.2. Gateways and Routes
    -   34.3. Virtual Hosts
    -   34.4. Wireless Advanced Authentication
    -   34.5. Wireless Ad-hoc Mode
    -   34.6. USB Tethering
    -   34.7. Bluetooth
    -   34.8. Bridging
    -   34.9. Link Aggregation and Failover
    -   34.10. Diskless Operation with PXE
    -   34.11. Common Address Redundancy Protocol (CARP)
    -   34.12. VLANs
-    Part V. Appendices
-    Appendix A. Obtaining FreeBSD
    -   A.1. Mirrors
    -   A.2. Using Git
    -   A.3. Using Subversion
    -   A.4. CD and DVD Sets
-    Appendix B. Bibliography
    -   B.1. FreeBSD Bibliography
    -   B.2. Security Reference
    -   B.3. UNIX® History
    -   B.4. Periodicals, Journals, and Magazines
-    Appendix C. Resources on the Internet
    -   C.1. Websites
    -   C.2. Mailing Lists
    -   C.3. Usenet Newsgroups
-    Appendix D. OpenPGP Keys
    -   D.1. Officers
-    FreeBSD Glossary
-    Colophon
-   
-   

Book menu

Chapter 15. The FreeBSD Booting Process

Table of Contents

-   15.1. Synopsis
-   15.2. FreeBSD Boot Process
-   15.3. Device Hints
-   15.4. Shutdown Sequence

15.1. Synopsis

The process of starting a computer and loading the operating system is
referred to as "the bootstrap process", or "booting". FreeBSD’s boot
process provides a great deal of flexibility in customizing what happens
when the system starts, including the ability to select from different
operating systems installed on the same computer, different versions of
the same operating system, or a different installed kernel.

This chapter details the configuration options that can be set. It
demonstrates how to customize the FreeBSD boot process, including
everything that happens until the FreeBSD kernel has started, probed for
devices, and started init(8). This occurs when the text color of the
boot messages changes from bright white to grey.

After reading this chapter, you will recognize:

-   The components of the FreeBSD bootstrap system and how they
    interact.

-   The options that can be passed to the components in the FreeBSD
    bootstrap in order to control the boot process.

-   The basics of setting device hints.

-   How to boot into single- and multi-user mode and how to properly
    shut down a FreeBSD system.

+-----------------------------------+-----------------------------------+
|                                   | This chapter only describes the   |
|                                   | boot process for FreeBSD running  |
|                                   | on x86 and amd64 systems.         |
+-----------------------------------+-----------------------------------+

15.2. FreeBSD Boot Process

Turning on a computer and starting the operating system poses an
interesting dilemma. By definition, the computer does not know how to do
anything until the operating system is started. This includes running
programs from the disk. If the computer can not run a program from the
disk without the operating system, and the operating system programs are
on the disk, how is the operating system started?

This problem parallels one in the book The Adventures of Baron
Munchausen. A character had fallen part way down a manhole, and pulled
himself out by grabbing his bootstraps and lifting. In the early days of
computing, the term bootstrap was applied to the mechanism used to load
the operating system. It has since become shortened to "booting".

On x86 hardware, the Basic Input/Output System (BIOS) is responsible for
loading the operating system. The BIOS looks on the hard disk for the
Master Boot Record (MBR), which must be located in a specific place on
the disk. The BIOS has enough knowledge to load and run the MBR, and
assumes that the MBR can then carry out the rest of the tasks involved
in loading the operating system, possibly with the help of the BIOS.

+-----------------------------------+-----------------------------------+
|                                   | FreeBSD provides for booting from |
|                                   | both the older MBR standard, and  |
|                                   | the newer GUID Partition Table    |
|                                   | (GPT). GPT partitioning is often  |
|                                   | found on computers with the       |
|                                   | Unified Extensible Firmware       |
|                                   | Interface (UEFI). However,        |
|                                   | FreeBSD can boot from GPT         |
|                                   | partitions even on machines with  |
|                                   | only a legacy BIOS with           |
|                                   | gptboot(8). Work is under way to  |
|                                   | provide direct UEFI booting.      |
+-----------------------------------+-----------------------------------+

The code within the MBR is typically referred to as a boot manager,
especially when it interacts with the user. The boot manager usually has
more code in the first track of the disk or within the file system.
Examples of boot managers include the standard FreeBSD boot manager
boot0, also called Boot Easy, and GNU GRUB, which is used by many Linux®
distributions.

+-----------------------------------+-----------------------------------+
|                                   | Users of GRUB should refer to     |
|                                   | GNU-provided documentation.       |
+-----------------------------------+-----------------------------------+

If only one operating system is installed, the MBR searches for the
first bootable (active) slice on the disk, and then runs the code on
that slice to load the remainder of the operating system. When multiple
operating systems are present, a different boot manager can be installed
to display a list of operating systems so the user can select one to
boot.

The remainder of the FreeBSD bootstrap system is divided into three
stages. The first stage knows just enough to get the computer into a
specific state and run the second stage. The second stage can do a
little bit more, before running the third stage. The third stage
finishes the task of loading the operating system. The work is split
into three stages because the MBR puts limits on the size of the
programs that can be run at stages one and two. Chaining the tasks
together allows FreeBSD to provide a more flexible loader.

The kernel is then started and begins to probe for devices and
initialize them for use. Once the kernel boot process is finished, the
kernel passes control to the user process init(8), which makes sure the
disks are in a usable state, starts the user-level resource
configuration which mounts file systems, sets up network cards to
communicate on the network, and starts the processes which have been
configured to run at startup.

This section describes these stages in more detail and demonstrates how
to interact with the FreeBSD boot process.

15.2.1. The Boot Manager

The boot manager code in the MBR is sometimes referred to as stage zero
of the boot process. By default, FreeBSD uses the boot0 boot manager.

The MBR installed by the FreeBSD installer is based on /boot/boot0. The
size and capability of boot0 is restricted to 446 bytes due to the slice
table and 0x55AA identifier at the end of the MBR. If boot0 and multiple
operating systems are installed, a message similar to this example will
be displayed at boot time:

Example 1. boot0 Screenshot

    F1 Win
    F2 FreeBSD

    Default: F2

Other operating systems will overwrite an existing MBR if they are
installed after FreeBSD. If this happens, or to replace the existing MBR
with the FreeBSD MBR, use the following command:

    # fdisk -B -b /boot/boot0 device

where device is the boot disk, such as ad0 for the first IDE disk, ad2
for the first IDE disk on a second IDE controller, or da0 for the first
SCSI disk. To create a custom configuration of the MBR, refer to
boot0cfg(8).

15.2.2. Stage One and Stage Two

Conceptually, the first and second stages are part of the same program
on the same area of the disk. Due to space constraints, they have been
split into two, but are always installed together. They are copied from
the combined /boot/boot by the FreeBSD installer or bsdlabel.

These two stages are located outside file systems, in the first track of
the boot slice, starting with the first sector. This is where boot0, or
any other boot manager, expects to find a program to run which will
continue the boot process.

The first stage, boot1, is very simple, since it can only be 512 bytes
in size. It knows just enough about the FreeBSD bsdlabel, which stores
information about the slice, to find and execute boot2.

Stage two, boot2, is slightly more sophisticated, and understands the
FreeBSD file system enough to find files. It can provide a simple
interface to choose the kernel or loader to run. It runs loader, which
is much more sophisticated and provides a boot configuration file. If
the boot process is interrupted at stage two, the following interactive
screen is displayed:

Example 2. boot2 Screenshot

    >> FreeBSD/i386 BOOT
    Default: 0:ad(0,a)/boot/loader
    boot:

To replace the installed boot1 and boot2, use bsdlabel, where diskslice
is the disk and slice to boot from, such as ad0s1 for the first slice on
the first IDE disk:

    # bsdlabel -B diskslice

+-----------------------------------+-----------------------------------+
|                                   | If just the disk name is used,    |
|                                   | such as ad0, bsdlabel will create |
|                                   | the disk in "dangerously          |
|                                   | dedicated mode", without slices.  |
|                                   | This is probably not the desired  |
|                                   | action, so double check the       |
|                                   | diskslice before pressing Return. |
+-----------------------------------+-----------------------------------+

15.2.3. Stage Three

The loader is the final stage of the three-stage bootstrap process. It
is located on the file system, usually as /boot/loader.

The loader is intended as an interactive method for configuration, using
a built-in command set, backed up by a more powerful interpreter which
has a more complex command set.

During initialization, loader will probe for a console and for disks,
and figure out which disk it is booting from. It will set variables
accordingly, and an interpreter is started where user commands can be
passed from a script or interactively.

The loader will then read /boot/loader.rc, which by default reads in
/boot/defaults/loader.conf which sets reasonable defaults for variables
and reads /boot/loader.conf for local changes to those variables.
loader.rc then acts on these variables, loading whichever modules and
kernel are selected.

Finally, by default, loader issues a 10 second wait for key presses, and
boots the kernel if it is not interrupted. If interrupted, the user is
presented with a prompt which understands the command set, where the
user may adjust variables, unload all modules, load modules, and then
finally boot or reboot. Loader Built-In Commands lists the most commonly
used loader commands. For a complete discussion of all available
commands, refer to loader(8).

+-------------+--------------------------------------------------------+
| Variable    | Description                                            |
+=============+========================================================+
| autoboot    | Proceeds to boot the kernel if not interrupted within  |
| seconds     | the time span given, in seconds. It displays a         |
|             | countdown, and the default time span is 10 seconds.    |
+-------------+--------------------------------------------------------+
| boot        | Immediately proceeds to boot the kernel, with any      |
| [-options]  | specified options or kernel name. Providing a kernel   |
| [           | name on the command-line is only applicable after an   |
| kernelname] | unload has been issued. Otherwise, the                 |
|             | previously-loaded kernel will be used. If kernelname   |
|             | is not qualified, it will be searched under            |
|             | /boot/kernel and /boot/modules.                        |
+-------------+--------------------------------------------------------+
| boot-conf   | Goes through the same automatic configuration of       |
|             | modules based on specified variables, most commonly    |
|             | kernel. This only makes sense if unload is used first, |
|             | before changing some variables.                        |
+-------------+--------------------------------------------------------+
| help        | Shows help messages read from /boot/loader.help. If    |
| [topic]     | the topic given is index, the list of available topics |
|             | is displayed.                                          |
+-------------+--------------------------------------------------------+
| include     | Reads the specified file and interprets it line by     |
| filename …​  | line. An error immediately stops the include.          |
+-------------+--------------------------------------------------------+
| load [-t    | Loads the kernel, kernel module, or file of the type   |
| type]       | given, with the specified filename. Any arguments      |
| filename    | after filename are passed to the file. If filename is  |
|             | not qualified, it will be searched under /boot/kernel  |
|             | and /boot/modules.                                     |
+-------------+--------------------------------------------------------+
| ls [-l]     | Displays a listing of files in the given path, or the  |
| [path]      | root directory, if the path is not specified. If -l is |
|             | specified, file sizes will also be shown.              |
+-------------+--------------------------------------------------------+
| lsdev [-v]  | Lists all of the devices from which it may be possible |
|             | to load modules. If -v is specified, more details are  |
|             | printed.                                               |
+-------------+--------------------------------------------------------+
| lsmod [-v]  | Displays loaded modules. If -v is specified, more      |
|             | details are shown.                                     |
+-------------+--------------------------------------------------------+
| more        | Displays the files specified, with a pause at each     |
| filename    | LINES displayed.                                       |
+-------------+--------------------------------------------------------+
| reboot      | Immediately reboots the system.                        |
+-------------+--------------------------------------------------------+
| set         | Sets the specified environment variables.              |
| variable,   |                                                        |
| set         |                                                        |
| var         |                                                        |
| iable=value |                                                        |
+-------------+--------------------------------------------------------+
| unload      | Removes all loaded modules.                            |
+-------------+--------------------------------------------------------+

: Table 1. Loader Built-In Commands

Here are some practical examples of loader usage. To boot the usual
kernel in single-user mode:

     boot -s

To unload the usual kernel and modules and then load the previous or
another, specified kernel:

     unload
     load /path/to/kernelfile

Use the qualified /boot/GENERIC/kernel to refer to the default kernel
that comes with an installation, or /boot/kernel.old/kernel, to refer to
the previously installed kernel before a system upgrade or before
configuring a custom kernel.

Use the following to load the usual modules with another kernel. Note
that in this case it is not necessary the qualified name:

    unload
    set kernel="mykernel"
    boot-conf

To load an automated kernel configuration script:

     load -t userconfig_script /boot/kernel.conf

15.2.4. Last Stage

Once the kernel is loaded by either loader or by boot2, which bypasses
loader, it examines any boot flags and adjusts its behavior as
necessary. Kernel Interaction During Boot lists the commonly used boot
flags. Refer to boot(8) for more information on the other boot flags.

+-----------------------------------+-----------------------------------+
| Option                            | Description                       |
+===================================+===================================+
| -a                                | During kernel initialization, ask |
|                                   | for the device to mount as the    |
|                                   | root file system.                 |
+-----------------------------------+-----------------------------------+
| -C                                | Boot the root file system from a  |
|                                   | CDROM.                            |
+-----------------------------------+-----------------------------------+
| -s                                | Boot into single-user mode.       |
+-----------------------------------+-----------------------------------+
| -v                                | Be more verbose during kernel     |
|                                   | startup.                          |
+-----------------------------------+-----------------------------------+

: Table 2. Kernel Interaction During Boot

Once the kernel has finished booting, it passes control to the user
process init(8), which is located at /sbin/init, or the program path
specified in the init_path variable in loader. This is the last stage of
the boot process.

The boot sequence makes sure that the file systems available on the
system are consistent. If a UFS file system is not, and fsck cannot fix
the inconsistencies, init drops the system into single-user mode so that
the system administrator can resolve the problem directly. Otherwise,
the system boots into multi-user mode.

15.2.4.1. Single-User Mode

A user can specify this mode by booting with -s or by setting the
boot_single variable in loader. It can also be reached by running
shutdown now from multi-user mode. Single-user mode begins with this
message:

    Enter full pathname of shell or RETURN for /bin/sh:

If the user presses Enter, the system will enter the default Bourne
shell. To specify a different shell, input the full path to the shell.

Single-user mode is usually used to repair a system that will not boot
due to an inconsistent file system or an error in a boot configuration
file. It can also be used to reset the root password when it is unknown.
These actions are possible as the single-user mode prompt gives full,
local access to the system and its configuration files. There is no
networking in this mode.

While single-user mode is useful for repairing a system, it poses a
security risk unless the system is in a physically secure location. By
default, any user who can gain physical access to a system will have
full control of that system after booting into single-user mode.

If the system console is changed to insecure in /etc/ttys, the system
will first prompt for the root password before initiating single-user
mode. This adds a measure of security while removing the ability to
reset the root password when it is unknown.

Example 3. Configuring an Insecure Console in /etc/ttys

    # name  getty                           type    status          comments
    #
    # If console is marked "insecure", then init will ask for the root password
    # when going to single-user mode.
    console none                            unknown off insecure

An insecure console means that physical security to the console is
considered to be insecure, so only someone who knows the root password
may use single-user mode.

15.2.4.2. Multi-User Mode

If init finds the file systems to be in order, or once the user has
finished their commands in single-user mode and has typed exit to leave
single-user mode, the system enters multi-user mode, in which it starts
the resource configuration of the system.

The resource configuration system reads in configuration defaults from
/etc/defaults/rc.conf and system-specific details from /etc/rc.conf. It
then proceeds to mount the system file systems listed in /etc/fstab. It
starts up networking services, miscellaneous system daemons, then the
startup scripts of locally installed packages.

To learn more about the resource configuration system, refer to rc(8)
and examine the scripts located in /etc/rc.d.

15.3. Device Hints

During initial system startup, the boot loader(8) reads device.hints(5).
This file stores kernel boot information known as variables, sometimes
referred to as "device hints". These "device hints" are used by device
drivers for device configuration.

Device hints may also be specified at the Stage 3 boot loader prompt, as
demonstrated in Stage Three. Variables can be added using set, removed
with unset, and viewed show. Variables set in /boot/device.hints can
also be overridden. Device hints entered at the boot loader are not
permanent and will not be applied on the next reboot.

Once the system is booted, kenv(1) can be used to dump all of the
variables.

The syntax for /boot/device.hints is one variable per line, using the
hash "#" as comment markers. Lines are constructed as follows:

     hint.driver.unit.keyword="value"

The syntax for the Stage 3 boot loader is:

     set hint.driver.unit.keyword=value

where driver is the device driver name, unit is the device driver unit
number, and keyword is the hint keyword. The keyword may consist of the
following options:

-   at: specifies the bus which the device is attached to.

-   port: specifies the start address of the I/O to be used.

-   irq: specifies the interrupt request number to be used.

-   drq: specifies the DMA channel number.

-   maddr: specifies the physical memory address occupied by the device.

-   flags: sets various flag bits for the device.

-   disabled: if set to 1 the device is disabled.

Since device drivers may accept or require more hints not listed here,
viewing a driver’s manual page is recommended. For more information,
refer to device.hints(5), kenv(1), loader.conf(5), and loader(8).

15.4. Shutdown Sequence

Upon controlled shutdown using shutdown(8), init(8) will attempt to run
the script /etc/rc.shutdown, and then proceed to send all processes the
TERM signal, and subsequently the KILL signal to any that do not
terminate in a timely manner.

To power down a FreeBSD machine on architectures and systems that
support power management, use shutdown -p now to turn the power off
immediately. To reboot a FreeBSD system, use shutdown -r now. One must
be root or a member of operator in order to run shutdown(8). One can
also use halt(8) and reboot(8). Refer to their manual pages and to
shutdown(8) for more information.

Modify group membership by referring to “Users and Basic Account
Management”.

+-----------------------------------+-----------------------------------+
|                                   | Power management requires acpi(4) |
|                                   | to be loaded as a module or       |
|                                   | statically compiled into a custom |
|                                   | kernel.                           |
+-----------------------------------+-----------------------------------+

------------------------------------------------------------------------

Last modified on: July 6, 2023 by Sergio Carlavilla Delgado

Prev

Home

Next

Table of Contents

-   15.1. Synopsis
-   15.2. FreeBSD Boot Process
-   15.3. Device Hints
-   15.4. Shutdown Sequence

------------------------------------------------------------------------

Resources

-   Download PDF
-   Edit this page
>>>>>>> b1bb5fd9 (Processing txt files in data/doc)

