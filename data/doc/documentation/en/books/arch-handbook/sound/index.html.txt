
-    Part I. Kernel
-    Chapter 1. Bootstrapping and Kernel Initialization
    -   1.1. Synopsis
    -   1.2. Overview
    -   1.3. The BIOS
    -   1.4. The Master Boot Record (boot0)
    -   1.5. boot1 Stage
    -   1.6. The BTX Server
    -   1.7. boot2 Stage
    -   1.8. loader Stage
    -   1.9. Kernel Initialization
-    Chapter 2. Locking Notes
    -   2.1. Mutexes
    -   2.2. Shared Exclusive Locks
    -   2.3. Atomically Protected Variables
-    Chapter 3. Kernel Objects
    -   3.1. Terminology
    -   3.2. Kobj Operation
    -   3.3. Using Kobj
-    Chapter 4. The Jail Subsystem
    -   4.1. Architecture
    -   4.2. Restrictions
-    Chapter 5. The SYSINIT Framework
    -   5.1. Terminology
    -   5.2. SYSINIT Operation
    -   5.3. Using SYSINIT
-    Chapter 6. The TrustedBSD MAC Framework
    -   6.1. MAC Documentation Copyright
    -   6.2. Synopsis
    -   6.3. Introduction
    -   6.4. Policy Background
    -   6.5. MAC Framework Kernel Architecture
    -   6.6. MAC Policy Architecture
    -   6.7. MAC Policy Entry Point Reference
    -   6.8. Userland Architecture
    -   6.9. Conclusion
-    Chapter 7. Virtual Memory System
    -   7.1. Management of Physical Memory vm_page_t
    -   7.2. The Unified Buffer Cache vm_object_t
    -   7.3. Filesystem I/O struct buf
    -   7.4. Mapping Page Tables vm_map_t, vm_entry_t
    -   7.5. KVM Memory Mapping
    -   7.6. Tuning the FreeBSD VM System
-    Chapter 8. SMPng Design Document
    -   8.1. Introduction
    -   8.2. Basic Tools and Locking Fundamentals
    -   8.3. General Architecture and Design
    -   8.4. Specific Locking Strategies
    -   8.5. Implementation Notes
    -   8.6. Miscellaneous Topics
    -   Glossary
-    Part II. Device Drivers
-    Chapter 9. Writing FreeBSD Device Drivers
    -   9.1. Introduction
    -   9.2. Dynamic Kernel Linker Facility - KLD
    -   9.3. Character Devices
    -   9.4. Block Devices (Are Gone)
    -   9.5. Network Drivers
-    Chapter 10. ISA Device Drivers
    -   10.1. Synopsis
    -   10.2. Basic Information
    -   10.3. device_t Pointer
    -   10.4. Configuration File and the Order of Identifying and
        Probing During Auto-Configuration
<<<<<<< HEAD
=======
    -   10.5. Resources
    -   10.6. Bus Memory Mapping
    -   10.7. DMA
    -   10.8. xxx_isa_probe
    -   10.9. xxx_isa_attach
    -   10.10. xxx_isa_detach
    -   10.11. xxx_isa_shutdown
    -   10.12. xxx_intr
-    Chapter 11. PCI Devices
    -   11.1. Probe and Attach
    -   11.2. Bus Resources
-    Chapter 12. Common Access Method SCSI Controllers
    -   12.1. Synopsis
    -   12.2. General Architecture
    -   12.3. Globals and Boilerplate
    -   12.4. Device configuration: xxx_attach
    -   12.5. Processing CAM messages: xxx_action
    -   12.6. Polling xxx_poll
    -   12.7. Asynchronous Events
    -   12.8. Interrupts
    -   12.9. Errors Summary
    -   12.10. Timeout Handling
-    Chapter 13. USB Devices
    -   13.1. Introduction
    -   13.2. Host Controllers
    -   13.3. USB Device Information
    -   13.4. Device Probe and Attach
    -   13.5. USB Drivers Protocol Information
-    Chapter 14. Newbus
    -   14.1. Device Drivers
    -   14.2. Overview of Newbus
    -   14.3. Newbus API
-    Chapter 15. Sound Subsystem
    -   15.1. Introduction
    -   15.2. Files
    -   15.3. Probing, Attaching, etc.
    -   15.4. Interfaces
-    Chapter 16. PC Card
    -   16.1. Adding a Device
-    Part III. Appendices
-    Bibliography
-   

Book menu

Chapter 15. Sound Subsystem

Table of Contents

-   15.1. Introduction
-   15.2. Files
-   15.3. Probing, Attaching, etc.
-   15.4. Interfaces

15.1. Introduction

The FreeBSD sound subsystem cleanly separates generic sound handling
issues from device-specific ones. This makes it easier to add support
for new hardware.

The pcm(4) framework is the central piece of the sound subsystem. It
mainly implements the following elements:

-   A system call interface (read, write, ioctls) to digitized sound and
    mixer functions. The ioctl command set is compatible with the legacy
    OSS or Voxware interface, allowing common multimedia applications to
    be ported without modification.

-   Common code for processing sound data (format conversions, virtual
    channels).

-   A uniform software interface to hardware-specific audio interface
    modules.

-   Additional support for some common hardware interfaces (ac97), or
    shared hardware-specific code (ex: ISA DMA routines).

The support for specific sound cards is implemented by hardware-specific
drivers, which provide channel and mixer interfaces to plug into the
generic pcm code.

In this chapter, the term pcm will refer to the central, common part of
the sound driver, as opposed to the hardware-specific modules.

The prospective driver writer will of course want to start from an
existing module and use the code as the ultimate reference. But, while
the sound code is nice and clean, it is also mostly devoid of comments.
This document tries to give an overview of the framework interface and
answer some questions that may arise while adapting the existing code.

As an alternative, or in addition to starting from a working example,
you can find a commented driver template at
https://people.FreeBSD.org/~cg/template.c

15.2. Files

All the relevant code lives in /usr/src/sys/dev/sound/, except for the
public ioctl interface definitions, found in
/usr/src/sys/sys/soundcard.h

Under /usr/src/sys/dev/sound/, the pcm/ directory holds the central
code, while the pci/, isa/ and usb/ directories have the drivers for PCI
and ISA boards, and for USB audio devices.

15.3. Probing, Attaching, etc.

Sound drivers probe and attach in almost the same way as any hardware
driver module. You might want to look at the ISA or PCI specific
sections of the handbook for more information.

However, sound drivers differ in some ways:

-   They declare themselves as pcm class devices, with a
    struct snddev_info device private structure:

                  static driver_t xxx_driver = {
                      "pcm",
                      xxx_methods,
                      sizeof(struct snddev_info)
                  };

                  DRIVER_MODULE(snd_xxxpci, pci, xxx_driver, pcm_devclass, 0, 0);
                  MODULE_DEPEND(snd_xxxpci, snd_pcm, PCM_MINVER, PCM_PREFVER,PCM_MAXVER);

    Most sound drivers need to store additional private information
    about their device. A private data structure is usually allocated in
    the attach routine. Its address is passed to pcm by the calls to
    pcm_register() and mixer_init(). pcm later passes back this address
    as a parameter in calls to the sound driver interfaces.

-   The sound driver attach routine should declare its MIXER or AC97
    interface to pcm by calling mixer_init(). For a MIXER interface,
    this causes in turn a call to xxxmixer_init().

-   The sound driver attach routine declares its general CHANNEL
    configuration to pcm by calling pcm_register(dev, sc, nplay, nrec),
    where sc is the address for the device data structure, used in
    further calls from pcm, and nplay and nrec are the number of play
    and record channels.

-   The sound driver attach routine declares each of its channel objects
    by calls to pcm_addchan(). This sets up the channel glue in pcm and
    causes in turn a call to xxxchannel_init().

-   The sound driver detach routine should call pcm_unregister() before
    releasing its resources.

There are two possible methods to handle non-PnP devices:

-   Use a device_identify() method (example: sound/isa/es1888.c). The
    device_identify() method probes for the hardware at known addresses
    and, if it finds a supported device, creates a new pcm device which
    is then passed to probe/attach.

-   Use a custom kernel configuration with appropriate hints for pcm
    devices (example: sound/isa/mss.c).

pcm drivers should implement device_suspend, device_resume and
device_shutdown routines, so that power management and module unloading
function correctly.

15.4. Interfaces

The interface between the pcm core and the sound drivers is defined in
terms of kernel objects.

There are two main interfaces that a sound driver will usually provide:
CHANNEL and either MIXER or AC97.

The AC97 interface is a very small hardware access (register read/write)
interface, implemented by drivers for hardware with an AC97 codec. In
this case, the actual MIXER interface is provided by the shared AC97
code in pcm.

15.4.1. The CHANNEL Interface

15.4.1.1. Common Notes for Function Parameters

Sound drivers usually have a private data structure to describe their
device, and one structure for each play and record data channel that it
supports.

For all CHANNEL interface functions, the first parameter is an opaque
pointer.

The second parameter is a pointer to the private channel data structure,
except for channel_init() which has a pointer to the private device
structure (and returns the channel pointer for further use by pcm).

15.4.1.2. Overview of Data Transfer Operations

For sound data transfers, the pcm core and the sound drivers communicate
through a shared memory area, described by a struct snd_dbuf.

struct snd_dbuf is private to pcm, and sound drivers obtain values of
interest by calls to accessor functions (sndbuf_getxxx()).

The shared memory area has a size of sndbuf_getsize() and is divided
into fixed size blocks of sndbuf_getblksz() bytes.

When playing, the general transfer mechanism is as follows (reverse the
idea for recording):

-   pcm initially fills up the buffer, then calls the sound driverâ€™s
    xxxchannel_trigger() function with a parameter of PCMTRIG_START.

-   The sound driver then arranges to repeatedly transfer the whole
    memory area (sndbuf_getbuf(), sndbuf_getsize()) to the device, in
    blocks of sndbuf_getblksz() bytes. It calls back the chn_intr()pcm
    function for each transferred block (this will typically happen at
    interrupt time).

-   chn_intr() arranges to copy new data to the area that was
    transferred to the device (now free), and make appropriate updates
    to the snd_dbuf structure.

15.4.1.3. channel_init

xxxchannel_init() is called to initialize each of the play or record
channels. The calls are initiated from the sound driver attach routine.
(See the probe and attach section).

              static void *
              xxxchannel_init(kobj_t obj, void *data,
                 struct snd_dbuf *b, struct pcm_channel *c, int dir) (1)
              {
                  struct xxx_info *sc = data;
                  struct xxx_chinfo *ch;
                   ...
                  return ch; (2)
               }

  --- ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  1   b is the address for the channel struct snd_dbuf. It should be initialized in the function by calling sndbuf_alloc(). The buffer size to use is normally a small multiple of the 'typical' unit transfer size for your device.c is the pcm channel control structure pointer. This is an opaque object. The function should store it in the local channel structure, to be used in later calls to pcm (ie: chn_intr(c)).dir indicates the channel direction (PCMDIR_PLAY or PCMDIR_REC).
  2   The function should return a pointer to the private area used to control this channel. This will be passed as a parameter to other channel interface calls.
  --- ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

15.4.1.4. channel_setformat

xxxchannel_setformat() should set up the hardware for the specified
channel for the specified sound format.

              static int
              xxxchannel_setformat(kobj_t obj, void *data, u_int32_t format) (1)
              {
                  struct xxx_chinfo *ch = data;
                   ...
                  return 0;
               }

  --- ---------------------------------------------------------
  1   format is specified as an AFMT_XXX value (soundcard.h).
  --- ---------------------------------------------------------

15.4.1.5. channel_setspeed

xxxchannel_setspeed() sets up the channel hardware for the specified
sampling speed, and returns the possibly adjusted speed.

              static int
              xxxchannel_setspeed(kobj_t obj, void *data, u_int32_t speed)
              {
                  struct xxx_chinfo *ch = data;
                   ...
                  return speed;
               }

15.4.1.6. channel_setblocksize

xxxchannel_setblocksize() sets the block size, which is the size of unit
transactions between pcm and the sound driver, and between the sound
driver and the device. Typically, this would be the number of bytes
transferred before an interrupt occurs. During a transfer, the sound
driver should call pcm's chn_intr() every time this size has been
transferred.

Most sound drivers only take note of the block size here, to be used
when an actual transfer will be started.

              static int
              xxxchannel_setblocksize(kobj_t obj, void *data, u_int32_t blocksize)
              {
                  struct xxx_chinfo *ch = data;
                    ...
                  return blocksize; (1)
               }

  --- ---------------------------------------------------------------------------------------------------------------------------------------------------------
  1   The function returns the possibly adjusted block size. In case the block size is indeed changed, sndbuf_resize() should be called to adjust the buffer.
  --- ---------------------------------------------------------------------------------------------------------------------------------------------------------

15.4.1.7. channel_trigger

xxxchannel_trigger() is called by pcm to control data transfer
operations in the driver.

              static int
              xxxchannel_trigger(kobj_t obj, void *data, int go) (1)
              {
                  struct xxx_chinfo *ch = data;
                   ...
                  return 0;
               }

  --- ----------------------------------------------------------------------
  1   go defines the action for the current call. The possible values are:
  --- ----------------------------------------------------------------------

+-----------------------------------+-----------------------------------+
|                                   | If the driver uses ISA DMA,       |
|                                   | sndbuf_isadma() should be called  |
|                                   | before performing actions on the  |
|                                   | device, and will take care of the |
|                                   | DMA chip side of things.          |
+-----------------------------------+-----------------------------------+

15.4.1.8. channel_getptr

xxxchannel_getptr() returns the current offset in the transfer buffer.
This will typically be called by chn_intr(), and this is how pcm knows
where it can transfer new data.

15.4.1.9. channel_free

xxxchannel_free() is called to free up channel resources, for example
when the driver is unloaded, and should be implemented if the channel
data structures are dynamically allocated or if sndbuf_alloc() was not
used for buffer allocation.

15.4.1.10. channel_getcaps

              struct pcmchan_caps *
              xxxchannel_getcaps(kobj_t obj, void *data)
              {
                  return &xxx_caps; (1)
               }

  --- --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  1   The routine returns a pointer to a (usually statically-defined) pcmchan_caps structure (defined in sound/pcm/channel.h. The structure holds the minimum and maximum sampling frequencies, and the accepted sound formats. Look at any sound driver for an example.
  --- --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

15.4.1.11. More Functions

channel_reset(), channel_resetdone(), and channel_notify() are for
special purposes and should not be implemented in a driver without
discussing it on the FreeBSD multimedia mailing list.

channel_setdir() is deprecated.

15.4.2. The MIXER Interface

15.4.2.1. mixer_init

xxxmixer_init() initializes the hardware and tells pcm what mixer
devices are available for playing and recording

              static int
              xxxmixer_init(struct snd_mixer *m)
              {
                  struct xxx_info   *sc = mix_getdevinfo(m);
                  u_int32_t v;

                  [Initialize hardware]

                  [Set appropriate bits in v for play mixers] (1)
                  mix_setdevs(m, v);
                  [Set appropriate bits in v for record mixers]
                  mix_setrecdevs(m, v)

                  return 0;
              }

  --- ----------------------------------------------------------------------------------------------------------
  1   Set bits in an integer value and call mix_setdevs() and mix_setrecdevs() to tell pcm what devices exist.
  --- ----------------------------------------------------------------------------------------------------------

Mixer bits definitions can be found in soundcard.h (SOUND_MASK_XXX
values and SOUND_MIXER_XXX bit shifts).

15.4.2.2. mixer_set

xxxmixer_set() sets the volume level for one mixer device.

              static int
              xxxmixer_set(struct snd_mixer *m, unsigned dev,
                               unsigned left, unsigned right) (1)
              {
                  struct sc_info *sc = mix_getdevinfo(m);
                  [set volume level]
                  return left | (right << 8); (2)
              }

  --- ----------------------------------------------------------------------------------------------------------------------------------------------------------------------
  1   The device is specified as a SOUND_MIXER_XXX value. The volume values are specified in range [0-100]. A value of zero should mute the device.
  2   As the hardware levels probably will not match the input scale, and some rounding will occur, the routine returns the actual level values (in range 0-100) as shown.
  --- ----------------------------------------------------------------------------------------------------------------------------------------------------------------------

15.4.2.3. mixer_setrecsrc

xxxmixer_setrecsrc() sets the recording source device.

              static int
              xxxmixer_setrecsrc(struct snd_mixer *m, u_int32_t src) (1)
              {
                  struct xxx_info *sc = mix_getdevinfo(m);

                  [look for non zero bit(s) in src, set up hardware]

                  [update src to reflect actual action]
                  return src; (2)
               }

  --- ----------------------------------------------------------------------------------------------------------------------------------------------------------
  1   The desired recording devices are specified as a bit field
  2   The actual devices set for recording are returned. Some drivers can only set one device for recording. The function should return -1 if an error occurs.
  --- ----------------------------------------------------------------------------------------------------------------------------------------------------------

15.4.2.4. mixer_uninit, mixer_reinit

xxxmixer_uninit() should ensure that all sound is muted and if possible
mixer hardware should be powered down.

xxxmixer_reinit() should ensure that the mixer hardware is powered up
and any settings not controlled by mixer_set() or mixer_setrecsrc() are
restored.

15.4.3. The AC97 Interface

The AC97 interface is implemented by drivers with an AC97 codec. It only
has three methods:

-   xxxac97_init() returns the number of ac97 codecs found.

-   ac97_read() and ac97_write() read or write a specified register.

The AC97 interface is used by the AC97 code in pcm to perform higher
level operations. Look at sound/pci/maestro3.c or many others under
sound/pci/ for an example.

------------------------------------------------------------------------

Last modified on: December 11, 2021 by Sergio Carlavilla Delgado

Prev

Home

Next

Table of Contents

-   15.1. Introduction
-   15.2. Files
-   15.3. Probing, Attaching, etc.
-   15.4. Interfaces

------------------------------------------------------------------------

Resources

-   Download PDF
-   Edit this page
>>>>>>> b1bb5fd9 (Processing txt files in data/doc)

