
-    Part I. Kernel
-    Chapter 1. Bootstrapping and Kernel Initialization
    -   1.1. Synopsis
    -   1.2. Overview
    -   1.3. The BIOS
    -   1.4. The Master Boot Record (boot0)
    -   1.5. boot1 Stage
    -   1.6. The BTX Server
    -   1.7. boot2 Stage
    -   1.8. loader Stage
    -   1.9. Kernel Initialization
-    Chapter 2. Locking Notes
    -   2.1. Mutexes
    -   2.2. Shared Exclusive Locks
    -   2.3. Atomically Protected Variables
-    Chapter 3. Kernel Objects
    -   3.1. Terminology
    -   3.2. Kobj Operation
    -   3.3. Using Kobj
-    Chapter 4. The Jail Subsystem
    -   4.1. Architecture
    -   4.2. Restrictions
-    Chapter 5. The SYSINIT Framework
    -   5.1. Terminology
    -   5.2. SYSINIT Operation
    -   5.3. Using SYSINIT
-    Chapter 6. The TrustedBSD MAC Framework
    -   6.1. MAC Documentation Copyright
    -   6.2. Synopsis
    -   6.3. Introduction
    -   6.4. Policy Background
    -   6.5. MAC Framework Kernel Architecture
    -   6.6. MAC Policy Architecture
    -   6.7. MAC Policy Entry Point Reference
    -   6.8. Userland Architecture
    -   6.9. Conclusion
-    Chapter 7. Virtual Memory System
    -   7.1. Management of Physical Memory vm_page_t
    -   7.2. The Unified Buffer Cache vm_object_t
    -   7.3. Filesystem I/O struct buf
    -   7.4. Mapping Page Tables vm_map_t, vm_entry_t
    -   7.5. KVM Memory Mapping
    -   7.6. Tuning the FreeBSD VM System
-    Chapter 8. SMPng Design Document
    -   8.1. Introduction
    -   8.2. Basic Tools and Locking Fundamentals
    -   8.3. General Architecture and Design
    -   8.4. Specific Locking Strategies
    -   8.5. Implementation Notes
    -   8.6. Miscellaneous Topics
    -   Glossary
-    Part II. Device Drivers
-    Chapter 9. Writing FreeBSD Device Drivers
    -   9.1. Introduction
    -   9.2. Dynamic Kernel Linker Facility - KLD
    -   9.3. Character Devices
    -   9.4. Block Devices (Are Gone)
    -   9.5. Network Drivers
-    Chapter 10. ISA Device Drivers
    -   10.1. Synopsis
    -   10.2. Basic Information
    -   10.3. device_t Pointer
    -   10.4. Configuration File and the Order of Identifying and
        Probing During Auto-Configuration
<<<<<<< HEAD
=======
    -   10.5. Resources
    -   10.6. Bus Memory Mapping
    -   10.7. DMA
    -   10.8. xxx_isa_probe
    -   10.9. xxx_isa_attach
    -   10.10. xxx_isa_detach
    -   10.11. xxx_isa_shutdown
    -   10.12. xxx_intr
-    Chapter 11. PCI Devices
    -   11.1. Probe and Attach
    -   11.2. Bus Resources
-    Chapter 12. Common Access Method SCSI Controllers
    -   12.1. Synopsis
    -   12.2. General Architecture
    -   12.3. Globals and Boilerplate
    -   12.4. Device configuration: xxx_attach
    -   12.5. Processing CAM messages: xxx_action
    -   12.6. Polling xxx_poll
    -   12.7. Asynchronous Events
    -   12.8. Interrupts
    -   12.9. Errors Summary
    -   12.10. Timeout Handling
-    Chapter 13. USB Devices
    -   13.1. Introduction
    -   13.2. Host Controllers
    -   13.3. USB Device Information
    -   13.4. Device Probe and Attach
    -   13.5. USB Drivers Protocol Information
-    Chapter 14. Newbus
    -   14.1. Device Drivers
    -   14.2. Overview of Newbus
    -   14.3. Newbus API
-    Chapter 15. Sound Subsystem
    -   15.1. Introduction
    -   15.2. Files
    -   15.3. Probing, Attaching, etc.
    -   15.4. Interfaces
-    Chapter 16. PC Card
    -   16.1. Adding a Device
-    Part III. Appendices
-    Bibliography
-   

Book menu

Chapter 3. Kernel Objects

Table of Contents

-   3.1. Terminology
-   3.2. Kobj Operation
-   3.3. Using Kobj

Kernel Objects, or Kobj provides an object-oriented C programming system
for the kernel. As such the data being operated on carries the
description of how to operate on it. This allows operations to be added
and removed from an interface at run time and without breaking binary
compatibility.

3.1. Terminology

Object

    A set of data - data structure - data allocation.

Method

    An operation - function.

Class

    One or more methods.

Interface

    A standard set of one or more methods.

3.2. Kobj Operation

Kobj works by generating descriptions of methods. Each description holds
a unique id as well as a default function. The description’s address is
used to uniquely identify the method within a class' method table.

A class is built by creating a method table associating one or more
functions with method descriptions. Before use the class is compiled.
The compilation allocates a cache and associates it with the class. A
unique id is assigned to each method description within the method table
of the class if not already done so by another referencing class
compilation. For every method to be used a function is generated by
script to qualify arguments and automatically reference the method
description for a lookup. The generated function looks up the method by
using the unique id associated with the method description as a hash
into the cache associated with the object’s class. If the method is not
cached the generated function proceeds to use the class' table to find
the method. If the method is found then the associated function within
the class is used; otherwise, the default function associated with the
method description is used.

These indirections can be visualized as the following:

    object->cache<->class

3.3. Using Kobj

3.3.1. Structures

    struct kobj_method

3.3.2. Functions

    void kobj_class_compile(kobj_class_t cls);
    void kobj_class_compile_static(kobj_class_t cls, kobj_ops_t ops);
    void kobj_class_free(kobj_class_t cls);
    kobj_t kobj_create(kobj_class_t cls, struct malloc_type *mtype, int mflags);
    void kobj_init(kobj_t obj, kobj_class_t cls);
    void kobj_delete(kobj_t obj, struct malloc_type *mtype);

3.3.3. Macros

    KOBJ_CLASS_FIELDS
    KOBJ_FIELDS
    DEFINE_CLASS(name, methods, size)
    KOBJMETHOD(NAME, FUNC)

3.3.4. Headers

    <sys/param.h>
    <sys/kobj.h>

3.3.5. Creating an Interface Template

The first step in using Kobj is to create an Interface. Creating the
interface involves creating a template that the script
src/sys/kern/makeobjops.pl can use to generate the header and code for
the method declarations and method lookup functions.

Within this template the following keywords are used: #include,
INTERFACE, CODE, EPILOG, HEADER, METHOD, PROLOG, STATICMETHOD, and
DEFAULT.

The #include statement and what follows it is copied verbatim to the
head of the generated code file.

For example:

    #include <sys/foo.h>

The INTERFACE keyword is used to define the interface name. This name is
concatenated with each method name as [interface name]_[method name].
Its syntax is INTERFACE [interface name];.

For example:

    INTERFACE foo;

The CODE keyword copies its arguments verbatim into the code file. Its
syntax is CODE { [whatever] };

For example:

    CODE {
        struct foo * foo_alloc_null(struct bar *)
        {
            return NULL;
        }
    };

The HEADER keyword copies its arguments verbatim into the header file.
Its syntax is HEADER { [whatever] };

For example:

    HEADER {
            struct mumble;
            struct grumble;
    };

The METHOD keyword describes a method. Its syntax is
METHOD [return type] [method name] { [object [, arguments]] };

For example:

    METHOD int bar {
        struct object *;
        struct foo *;
        struct bar;
    };

The DEFAULT keyword may follow the METHOD keyword. It extends the METHOD
key word to include the default function for method. The extended syntax
is
METHOD [return type] [method name] { [object; [other arguments]] }DEFAULT [default function];

For example:

    METHOD int bar {
        struct object *;
        struct foo *;
        int bar;
    } DEFAULT foo_hack;

The STATICMETHOD keyword is used like the METHOD keyword except the kobj
data is not at the head of the object structure so casting to kobj_t
would be incorrect. Instead STATICMETHOD relies on the Kobj data being
referenced as 'ops'. This is also useful for calling methods directly
out of a class’s method table.

The PROLOG and EPILOG keywords sets inserts code immediately before or
directly after the METHOD they are attached to. This feature is used
primarily for profiling situations where it’s difficult to obtain the
information in another way.

Other complete examples:

    src/sys/kern/bus_if.m
    src/sys/kern/device_if.m

3.3.6. Creating a Class

The second step in using Kobj is to create a class. A class consists of
a name, a table of methods, and the size of objects if Kobj’s object
handling facilities are used. To create the class use the macro
DEFINE_CLASS(). To create the method table create an array of
kobj_method_t terminated by a NULL entry. Each non-NULL entry may be
created using the macro KOBJMETHOD().

For example:

    DEFINE_CLASS(fooclass, foomethods, sizeof(struct foodata));

    kobj_method_t foomethods[] = {
        KOBJMETHOD(bar_doo, foo_doo),
        KOBJMETHOD(bar_foo, foo_foo),
        { NULL, NULL}
    };

The class must be "compiled". Depending on the state of the system at
the time that the class is to be initialized a statically allocated
cache, "ops table" have to be used. This can be accomplished by
declaring a struct kobj_ops and using kobj_class_compile_static();
otherwise, kobj_class_compile() should be used.

3.3.7. Creating an Object

The third step in using Kobj involves how to define the object. Kobj
object creation routines assume that Kobj data is at the head of an
object. If this in not appropriate you will have to allocate the object
yourself and then use kobj_init() on the Kobj portion of it; otherwise,
you may use kobj_create() to allocate and initialize the Kobj portion of
the object automatically. kobj_init() may also be used to change the
class that an object uses.

To integrate Kobj into the object you should use the macro KOBJ_FIELDS.

For example

    struct foo_data {
        KOBJ_FIELDS;
        foo_foo;
        foo_bar;
    };

3.3.8. Calling Methods

The last step in using Kobj is to simply use the generated functions to
use the desired method within the object’s class. This is as simple as
using the interface name and the method name with a few modifications.
The interface name should be concatenated with the method name using a
'_' between them, all in upper case.

For example, if the interface name was foo and the method was bar then
the call would be:

    [return value = ] FOO_BAR(object [, other parameters]);

3.3.9. Cleaning Up

When an object allocated through kobj_create() is no longer needed
kobj_delete() may be called on it, and when a class is no longer being
used kobj_class_free() may be called on it.

------------------------------------------------------------------------

Last modified on: December 11, 2021 by Sergio Carlavilla Delgado

Prev

Home

Next

Table of Contents

-   3.1. Terminology
-   3.2. Kobj Operation
-   3.3. Using Kobj

------------------------------------------------------------------------

Resources

-   Download PDF
-   Edit this page
>>>>>>> b1bb5fd9 (Processing txt files in data/doc)

