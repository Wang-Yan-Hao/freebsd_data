
-    Part I. Kernel
-    Chapter 1. Bootstrapping and Kernel Initialization
    -   1.1. Synopsis
    -   1.2. Overview
    -   1.3. The BIOS
    -   1.4. The Master Boot Record (boot0)
    -   1.5. boot1 Stage
    -   1.6. The BTX Server
    -   1.7. boot2 Stage
    -   1.8. loader Stage
    -   1.9. Kernel Initialization
-    Chapter 2. Locking Notes
    -   2.1. Mutexes
    -   2.2. Shared Exclusive Locks
    -   2.3. Atomically Protected Variables
-    Chapter 3. Kernel Objects
    -   3.1. Terminology
    -   3.2. Kobj Operation
    -   3.3. Using Kobj
-    Chapter 4. The Jail Subsystem
    -   4.1. Architecture
    -   4.2. Restrictions
-    Chapter 5. The SYSINIT Framework
    -   5.1. Terminology
    -   5.2. SYSINIT Operation
    -   5.3. Using SYSINIT
-    Chapter 6. The TrustedBSD MAC Framework
    -   6.1. MAC Documentation Copyright
    -   6.2. Synopsis
    -   6.3. Introduction
    -   6.4. Policy Background
    -   6.5. MAC Framework Kernel Architecture
    -   6.6. MAC Policy Architecture
    -   6.7. MAC Policy Entry Point Reference
    -   6.8. Userland Architecture
    -   6.9. Conclusion
-    Chapter 7. Virtual Memory System
    -   7.1. Management of Physical Memory vm_page_t
    -   7.2. The Unified Buffer Cache vm_object_t
    -   7.3. Filesystem I/O struct buf
    -   7.4. Mapping Page Tables vm_map_t, vm_entry_t
    -   7.5. KVM Memory Mapping
    -   7.6. Tuning the FreeBSD VM System
-    Chapter 8. SMPng Design Document
    -   8.1. Introduction
    -   8.2. Basic Tools and Locking Fundamentals
    -   8.3. General Architecture and Design
    -   8.4. Specific Locking Strategies
    -   8.5. Implementation Notes
    -   8.6. Miscellaneous Topics
    -   Glossary
-    Part II. Device Drivers
-    Chapter 9. Writing FreeBSD Device Drivers
    -   9.1. Introduction
    -   9.2. Dynamic Kernel Linker Facility - KLD
    -   9.3. Character Devices
    -   9.4. Block Devices (Are Gone)
    -   9.5. Network Drivers
-    Chapter 10. ISA Device Drivers
    -   10.1. Synopsis
    -   10.2. Basic Information
    -   10.3. device_t Pointer
    -   10.4. Configuration File and the Order of Identifying and
        Probing During Auto-Configuration
<<<<<<< HEAD
=======
    -   10.5. Resources
    -   10.6. Bus Memory Mapping
    -   10.7. DMA
    -   10.8. xxx_isa_probe
    -   10.9. xxx_isa_attach
    -   10.10. xxx_isa_detach
    -   10.11. xxx_isa_shutdown
    -   10.12. xxx_intr
-    Chapter 11. PCI Devices
    -   11.1. Probe and Attach
    -   11.2. Bus Resources
-    Chapter 12. Common Access Method SCSI Controllers
    -   12.1. Synopsis
    -   12.2. General Architecture
    -   12.3. Globals and Boilerplate
    -   12.4. Device configuration: xxx_attach
    -   12.5. Processing CAM messages: xxx_action
    -   12.6. Polling xxx_poll
    -   12.7. Asynchronous Events
    -   12.8. Interrupts
    -   12.9. Errors Summary
    -   12.10. Timeout Handling
-    Chapter 13. USB Devices
    -   13.1. Introduction
    -   13.2. Host Controllers
    -   13.3. USB Device Information
    -   13.4. Device Probe and Attach
    -   13.5. USB Drivers Protocol Information
-    Chapter 14. Newbus
    -   14.1. Device Drivers
    -   14.2. Overview of Newbus
    -   14.3. Newbus API
-    Chapter 15. Sound Subsystem
    -   15.1. Introduction
    -   15.2. Files
    -   15.3. Probing, Attaching, etc.
    -   15.4. Interfaces
-    Chapter 16. PC Card
    -   16.1. Adding a Device
-    Part III. Appendices
-    Bibliography
-   

Book menu

Chapter 5. The SYSINIT Framework

Table of Contents

-   5.1. Terminology
-   5.2. SYSINIT Operation
-   5.3. Using SYSINIT

SYSINIT is the framework for a generic call sort and dispatch mechanism.
FreeBSD currently uses it for the dynamic initialization of the kernel.
SYSINIT allows FreeBSD’s kernel subsystems to be reordered, and added,
removed, and replaced at kernel link time when the kernel or one of its
modules is loaded without having to edit a statically ordered
initialization routing and recompile the kernel. This system also allows
kernel modules, currently called KLD’s, to be separately compiled,
linked, and initialized at boot time and loaded even later while the
system is already running. This is accomplished using the "kernel
linker" and "linker sets".

5.1. Terminology

Linker Set

    A linker technique in which the linker gathers statically declared
    data throughout a program’s source files into a single contiguously
    addressable unit of data.

5.2. SYSINIT Operation

SYSINIT relies on the ability of the linker to take static data declared
at multiple locations throughout a program’s source and group it
together as a single contiguous chunk of data. This linker technique is
called a "linker set". SYSINIT uses two linker sets to maintain two data
sets containing each consumer’s call order, function, and a pointer to
the data to pass to that function.

SYSINIT uses two priorities when ordering the functions for execution.
The first priority is a subsystem ID giving an overall order for
SYSINIT’s dispatch of functions. Current predeclared ID’s are in
<sys/kernel.h> in the enum list sysinit_sub_id. The second priority used
is an element order within the subsystem. Current predeclared subsystem
element orders are in <sys/kernel.h> in the enum list
sysinit_elem_order.

There are currently two uses for SYSINIT. Function dispatch at system
startup and kernel module loads, and function dispatch at system
shutdown and kernel module unload. Kernel subsystems often use system
startup SYSINIT’s to initialize data structures, for example the process
scheduling subsystem uses a SYSINIT to initialize the run queue data
structure. Device drivers should avoid using SYSINIT() directly. Instead
drivers for real devices that are part of a bus structure should use
DRIVER_MODULE() to provide a function that detects the device and, if it
is present, initializes the device. It will do a few things specific to
devices and then call SYSINIT() itself. For pseudo-devices, which are
not part of a bus structure, use DEV_MODULE().

5.3. Using SYSINIT

5.3.1. Interface

5.3.1.1. Headers

    <sys/kernel.h>

5.3.1.2. Macros

    SYSINIT(uniquifier, subsystem, order, func, ident)
    SYSUNINIT(uniquifier, subsystem, order, func, ident)

5.3.2. Startup

The SYSINIT() macro creates the necessary SYSINIT data in SYSINIT’s
startup data set for SYSINIT to sort and dispatch a function at system
startup and module load. SYSINIT() takes a uniquifier that SYSINIT uses
to identify the particular function dispatch data, the subsystem order,
the subsystem element order, the function to call, and the data to pass
the function. All functions must take a constant pointer argument.

Example 1. Example of a SYSINIT()

    #include <sys/kernel.h>

    void foo_null(void *unused)
    {
            foo_doo();
    }
    SYSINIT(foo, SI_SUB_FOO, SI_ORDER_FOO, foo_null, NULL);

    struct foo foo_voodoo = {
            FOO_VOODOO;
    }

    void foo_arg(void *vdata)
    {
            struct foo *foo = (struct foo *)vdata;
            foo_data(foo);
    }
    SYSINIT(bar, SI_SUB_FOO, SI_ORDER_FOO, foo_arg, &foo_voodoo);

Note that SI_SUB_FOO and SI_ORDER_FOO need to be in the sysinit_sub_id
and sysinit_elem_order enum’s as mentioned above. Either use existing
ones or add your own to the enum’s. You can also use math for
fine-tuning the order a SYSINIT will run in. This example shows a
SYSINIT that needs to be run just barely before the SYSINIT’s that
handle tuning kernel parameters.

Example 2. Example of Adjusting SYSINIT() Order

    static void
    mptable_register(void *dummy __unused)
    {

        apic_register_enumerator(&mptable_enumerator);
    }

    SYSINIT(mptable_register, SI_SUB_TUNABLES - 1, SI_ORDER_FIRST,
        mptable_register, NULL);

5.3.3. Shutdown

The SYSUNINIT() macro behaves similarly to the SYSINIT() macro except
that it adds the SYSINIT data to SYSINIT’s shutdown data set.

Example 3. Example of a SYSUNINIT()

    #include <sys/kernel.h>

    void foo_cleanup(void *unused)
    {
            foo_kill();
    }
    SYSUNINIT(foobar, SI_SUB_FOO, SI_ORDER_FOO, foo_cleanup, NULL);

    struct foo_stack foo_stack = {
            FOO_STACK_VOODOO;
    }

    void foo_flush(void *vdata)
    {
    }
    SYSUNINIT(barfoo, SI_SUB_FOO, SI_ORDER_FOO, foo_flush, &foo_stack);

------------------------------------------------------------------------

Last modified on: December 11, 2021 by Sergio Carlavilla Delgado

Prev

Home

Next

Table of Contents

-   5.1. Terminology
-   5.2. SYSINIT Operation
-   5.3. Using SYSINIT

------------------------------------------------------------------------

Resources

-   Download PDF
-   Edit this page
>>>>>>> b1bb5fd9 (Processing txt files in data/doc)

