
-    Part I. Kernel
-    Chapter 1. Bootstrapping and Kernel Initialization
    -   1.1. Synopsis
    -   1.2. Overview
    -   1.3. The BIOS
    -   1.4. The Master Boot Record (boot0)
    -   1.5. boot1 Stage
    -   1.6. The BTX Server
    -   1.7. boot2 Stage
    -   1.8. loader Stage
    -   1.9. Kernel Initialization
-    Chapter 2. Locking Notes
    -   2.1. Mutexes
    -   2.2. Shared Exclusive Locks
    -   2.3. Atomically Protected Variables
-    Chapter 3. Kernel Objects
    -   3.1. Terminology
    -   3.2. Kobj Operation
    -   3.3. Using Kobj
-    Chapter 4. The Jail Subsystem
    -   4.1. Architecture
    -   4.2. Restrictions
-    Chapter 5. The SYSINIT Framework
    -   5.1. Terminology
    -   5.2. SYSINIT Operation
    -   5.3. Using SYSINIT
-    Chapter 6. The TrustedBSD MAC Framework
    -   6.1. MAC Documentation Copyright
    -   6.2. Synopsis
    -   6.3. Introduction
    -   6.4. Policy Background
    -   6.5. MAC Framework Kernel Architecture
    -   6.6. MAC Policy Architecture
    -   6.7. MAC Policy Entry Point Reference
    -   6.8. Userland Architecture
    -   6.9. Conclusion
-    Chapter 7. Virtual Memory System
    -   7.1. Management of Physical Memory vm_page_t
    -   7.2. The Unified Buffer Cache vm_object_t
    -   7.3. Filesystem I/O struct buf
    -   7.4. Mapping Page Tables vm_map_t, vm_entry_t
    -   7.5. KVM Memory Mapping
    -   7.6. Tuning the FreeBSD VM System
-    Chapter 8. SMPng Design Document
    -   8.1. Introduction
    -   8.2. Basic Tools and Locking Fundamentals
    -   8.3. General Architecture and Design
    -   8.4. Specific Locking Strategies
    -   8.5. Implementation Notes
    -   8.6. Miscellaneous Topics
    -   Glossary
-    Part II. Device Drivers
-    Chapter 9. Writing FreeBSD Device Drivers
    -   9.1. Introduction
    -   9.2. Dynamic Kernel Linker Facility - KLD
    -   9.3. Character Devices
    -   9.4. Block Devices (Are Gone)
    -   9.5. Network Drivers
-    Chapter 10. ISA Device Drivers
    -   10.1. Synopsis
    -   10.2. Basic Information
    -   10.3. device_t Pointer
    -   10.4. Configuration File and the Order of Identifying and
        Probing During Auto-Configuration
<<<<<<< HEAD
=======
    -   10.5. Resources
    -   10.6. Bus Memory Mapping
    -   10.7. DMA
    -   10.8. xxx_isa_probe
    -   10.9. xxx_isa_attach
    -   10.10. xxx_isa_detach
    -   10.11. xxx_isa_shutdown
    -   10.12. xxx_intr
-    Chapter 11. PCI Devices
    -   11.1. Probe and Attach
    -   11.2. Bus Resources
-    Chapter 12. Common Access Method SCSI Controllers
    -   12.1. Synopsis
    -   12.2. General Architecture
    -   12.3. Globals and Boilerplate
    -   12.4. Device configuration: xxx_attach
    -   12.5. Processing CAM messages: xxx_action
    -   12.6. Polling xxx_poll
    -   12.7. Asynchronous Events
    -   12.8. Interrupts
    -   12.9. Errors Summary
    -   12.10. Timeout Handling
-    Chapter 13. USB Devices
    -   13.1. Introduction
    -   13.2. Host Controllers
    -   13.3. USB Device Information
    -   13.4. Device Probe and Attach
    -   13.5. USB Drivers Protocol Information
-    Chapter 14. Newbus
    -   14.1. Device Drivers
    -   14.2. Overview of Newbus
    -   14.3. Newbus API
-    Chapter 15. Sound Subsystem
    -   15.1. Introduction
    -   15.2. Files
    -   15.3. Probing, Attaching, etc.
    -   15.4. Interfaces
-    Chapter 16. PC Card
    -   16.1. Adding a Device
-    Part III. Appendices
-    Bibliography
-   

Book menu

Chapter 6. The TrustedBSD MAC Framework

Table of Contents

-   6.1. MAC Documentation Copyright
-   6.2. Synopsis
-   6.3. Introduction
-   6.4. Policy Background
-   6.5. MAC Framework Kernel Architecture
-   6.6. MAC Policy Architecture
-   6.7. MAC Policy Entry Point Reference
-   6.8. Userland Architecture
-   6.9. Conclusion

6.1. MAC Documentation Copyright

This documentation was developed for the FreeBSD Project by Chris
Costello at Safeport Network Services and Network Associates
Laboratories, the Security Research Division of Network Associates, Inc.
under DARPA/SPAWAR contract N66001-01-C-8035 ("CBOSS"), as part of the
DARPA CHATS research program.

Redistribution and use in source (SGML DocBook) and 'compiled' forms
(SGML, HTML, PDF, PostScript, RTF and so forth) with or without
modification, are permitted provided that the following conditions are
met:

1.  Redistributions of source code (SGML DocBook) must retain the above
    copyright notice, this list of conditions and the following
    disclaimer as the first lines of this file unmodified.

2.  Redistributions in compiled form (transformed to other DTDs,
    converted to PDF, PostScript, RTF and other formats) must reproduce
    the above copyright notice, this list of conditions and the
    following disclaimer in the documentation and/or other materials
    provided with the distribution.

+-----------------------------------+-----------------------------------+
|                                   | THIS DOCUMENTATION IS PROVIDED BY |
|                                   | THE NETWORKS ASSOCIATES           |
|                                   | TECHNOLOGY, INC "AS IS" AND ANY   |
|                                   | EXPRESS OR IMPLIED WARRANTIES,    |
|                                   | INCLUDING, BUT NOT LIMITED TO,    |
|                                   | THE IMPLIED WARRANTIES OF         |
|                                   | MERCHANTABILITY AND FITNESS FOR A |
|                                   | PARTICULAR PURPOSE ARE            |
|                                   | DISCLAIMED. IN NO EVENT SHALL     |
|                                   | NETWORKS ASSOCIATES TECHNOLOGY,   |
|                                   | INC BE LIABLE FOR ANY DIRECT,     |
|                                   | INDIRECT, INCIDENTAL, SPECIAL,    |
|                                   | EXEMPLARY, OR CONSEQUENTIAL       |
|                                   | DAMAGES (INCLUDING, BUT NOT       |
|                                   | LIMITED TO, PROCUREMENT OF        |
|                                   | SUBSTITUTE GOODS OR SERVICES;     |
|                                   | LOSS OF USE, DATA, OR PROFITS; OR |
|                                   | BUSINESS INTERRUPTION) HOWEVER    |
|                                   | CAUSED AND ON ANY THEORY OF       |
|                                   | LIABILITY, WHETHER IN CONTRACT,   |
|                                   | STRICT LIABILITY, OR TORT         |
|                                   | (INCLUDING NEGLIGENCE OR          |
|                                   | OTHERWISE) ARISING IN ANY WAY OUT |
|                                   | OF THE USE OF THIS DOCUMENTATION, |
|                                   | EVEN IF ADVISED OF THE            |
|                                   | POSSIBILITY OF SUCH DAMAGE.       |
+-----------------------------------+-----------------------------------+

6.2. Synopsis

FreeBSD includes experimental support for several mandatory access
control policies, as well as a framework for kernel security
extensibility, the TrustedBSD MAC Framework. The MAC Framework is a
pluggable access control framework, permitting new security policies to
be easily linked into the kernel, loaded at boot, or loaded dynamically
at run-time. The framework provides a variety of features to make it
easier to implement new security policies, including the ability to
easily tag security labels (such as confidentiality information) onto
system objects.

This chapter introduces the MAC policy framework and provides
documentation for a sample MAC policy module.

6.3. Introduction

The TrustedBSD MAC framework provides a mechanism to allow the
compile-time or run-time extension of the kernel access control model.
New system policies may be implemented as kernel modules and linked to
the kernel; if multiple policy modules are present, their results will
be composed. The MAC Framework provides a variety of access control
infrastructure services to assist policy writers, including support for
transient and persistent policy-agnostic object security labels. This
support is currently considered experimental.

This chapter provides information appropriate for developers of policy
modules, as well as potential consumers of MAC-enabled environments, to
learn about how the MAC Framework supports access control extension of
the kernel.

6.4. Policy Background

Mandatory Access Control (MAC), refers to a set of access control
policies that are mandatorily enforced on users by the operating system.
MAC policies may be contrasted with Discretionary Access Control (DAC)
protections, by which non-administrative users may (at their discretion)
protect objects. In traditional UNIX systems, DAC protections include
file permissions and access control lists; MAC protections include
process controls preventing inter-user debugging and firewalls. A
variety of MAC policies have been formulated by operating system
designers and security researches, including the Multi-Level Security
(MLS) confidentiality policy, the Biba integrity policy, Role-Based
Access Control (RBAC), Domain and Type Enforcement (DTE), and Type
Enforcement (TE). Each model bases decisions on a variety of factors,
including user identity, role, and security clearance, as well as
security labels on objects representing concepts such as data
sensitivity and integrity.

The TrustedBSD MAC Framework is capable of supporting policy modules
that implement all of these policies, as well as a broad class of system
hardening policies, which may use existing security attributes, such as
user and group IDs, as well as extended attributes on files, and other
system properties. In addition, despite the name, the MAC Framework can
also be used to implement purely discretionary policies, as policy
modules are given substantial flexibility in how they authorize
protections.

6.5. MAC Framework Kernel Architecture

The TrustedBSD MAC Framework permits kernel modules to extend the
operating system security policy, as well as providing infrastructure
functionality required by many access control modules. If multiple
policies are simultaneously loaded, the MAC Framework will usefully (for
some definition of useful) compose the results of the policies.

6.5.1. Kernel Elements

The MAC Framework contains a number of kernel elements:

-   Framework management interfaces

-   Concurrency and synchronization primitives.

-   Policy registration

-   Extensible security label for kernel objects

-   Policy entry point composition operators

-   Label management primitives

-   Entry point API invoked by kernel services

-   Entry point API to policy modules

-   Entry points implementations (policy life cycle, object life
    cycle/label management, access control checks).

-   Policy-agnostic label-management system calls

-   mac_syscall() multiplex system call

-   Various security policies implemented as MAC policy modules

6.5.2. Framework Management Interfaces

The TrustedBSD MAC Framework may be directly managed using sysctl’s,
loader tunables, and system calls.

In most cases, sysctl’s and loader tunables of the same name modify the
same parameters, and control behavior such as enforcement of protections
relating to various kernel subsystems. In addition, if MAC debugging
support is compiled into the kernel, several counters will be maintained
tracking label allocation. It is generally advisable that per-subsystem
enforcement controls not be used to control policy behavior in
production environments, as they broadly impact the operation of all
active policies. Instead, per-policy controls should be preferred, as
they provide greater granularity and greater operational consistency for
policy modules.

Loading and unloading of policy modules is performed using the system
module management system calls and other system interfaces, including
boot loader variables; policy modules will have the opportunity to
influence load and unload events, including preventing undesired
unloading of the policy.

6.5.3. Policy List Concurrency and Synchronization

As the set of active policies may change at run-time, and the invocation
of entry points is non-atomic, synchronization is required to prevent
loading or unloading of policies while an entry point invocation is in
progress, freezing the set of active policies for the duration. This is
accomplished by means of a framework busy count: whenever an entry point
is entered, the busy count is incremented; whenever it is exited, the
busy count is decremented. While the busy count is elevated, policy list
changes are not permitted, and threads attempting to modify the policy
list will sleep until the list is not busy. The busy count is protected
by a mutex, and a condition variable is used to wake up sleepers waiting
on policy list modifications. One side effect of this synchronization
model is that recursion into the MAC Framework from within a policy
module is permitted, although not generally used.

Various optimizations are used to reduce the overhead of the busy count,
including avoiding the full cost of incrementing and decrementing if the
list is empty or contains only static entries (policies that are loaded
before the system starts, and cannot be unloaded). A compile-time option
is also provided which prevents any change in the set of loaded policies
at run-time, which eliminates the mutex locking costs associated with
supporting dynamically loaded and unloaded policies as synchronization
is no longer required.

As the MAC Framework is not permitted to block in some entry points, a
normal sleep lock cannot be used; as a result, it is possible for the
load or unload attempt to block for a substantial period of time waiting
for the framework to become idle.

6.5.4. Label Synchronization

As kernel objects of interest may generally be accessed from more than
one thread at a time, and simultaneous entry of more than one thread
into the MAC Framework is permitted, security attribute storage
maintained by the MAC Framework is carefully synchronized. In general,
existing kernel synchronization on kernel object data is used to protect
MAC Framework security labels on the object: for example, MAC labels on
sockets are protected using the existing socket mutex. Likewise,
semantics for concurrent access are generally identical to those of the
container objects: for credentials, copy-on-write semantics are
maintained for label contents as with the remainder of the credential
structure. The MAC Framework asserts necessary locks on objects when
invoked with an object reference. Policy authors must be aware of these
synchronization semantics, as they will sometimes limit the types of
accesses permitted on labels: for example, when a read-only reference to
a credential is passed to a policy via an entry point, only read
operations are permitted on the label state attached to the credential.

6.5.5. Policy Synchronization and Concurrency

Policy modules must be written to assume that many kernel threads may
simultaneously enter one more policy entry points due to the parallel
and preemptive nature of the FreeBSD kernel. If the policy module makes
use of mutable state, this may require the use of synchronization
primitives within the policy to prevent inconsistent views on that state
resulting in incorrect operation of the policy. Policies will generally
be able to make use of existing FreeBSD synchronization primitives for
this purpose, including mutexes, sleep locks, condition variables, and
counting semaphores. However, policies should be written to employ these
primitives carefully, respecting existing kernel lock orders, and
recognizing that some entry points are not permitted to sleep, limiting
the use of primitives in those entry points to mutexes and wakeup
operations.

When policy modules call out to other kernel subsystems, they will
generally need to release any in-policy locks in order to avoid
violating the kernel lock order or risking lock recursion. This will
maintain policy locks as leaf locks in the global lock order, helping to
avoid deadlock.

6.5.6. Policy Registration

The MAC Framework maintains two lists of active policies: a static list,
and a dynamic list. The lists differ only with regards to their locking
semantics: an elevated reference count is not required to make use of
the static list. When kernel modules containing MAC Framework policies
are loaded, the policy module will use SYSINIT to invoke a registration
function; when a policy module is unloaded, SYSINIT will likewise invoke
a de-registration function. Registration may fail if a policy module is
loaded more than once, if insufficient resources are available for the
registration (for example, the policy might require labeling and
insufficient labeling state might be available), or other policy
prerequisites might not be met (some policies may only be loaded prior
to boot). Likewise, de-registration may fail if a policy is flagged as
not unloadable.

6.5.7. Entry Points

Kernel services interact with the MAC Framework in two ways: they invoke
a series of APIs to notify the framework of relevant events, and they
provide a policy-agnostic label structure pointer in security-relevant
objects. The label pointer is maintained by the MAC Framework via label
management entry points, and permits the Framework to offer a labeling
service to policy modules through relatively non-invasive changes to the
kernel subsystem maintaining the object. For example, label pointers
have been added to processes, process credentials, sockets, pipes,
vnodes, Mbufs, network interfaces, IP reassembly queues, and a variety
of other security-relevant structures. Kernel services also invoke the
MAC Framework when they perform important security decisions, permitting
policy modules to augment those decisions based on their own criteria
(possibly including data stored in security labels). Most of these
security critical decisions will be explicit access control checks;
however, some affect more general decision functions such as packet
matching for sockets and label transition at program execution.

6.5.8. Policy Composition

When more than one policy module is loaded into the kernel at a time,
the results of the policy modules will be composed by the framework
using a composition operator. This operator is currently hard-coded, and
requires that all active policies must approve a request for it to
return success. As policies may return a variety of error conditions
(success, access denied, object does not exist, …​), a precedence
operator selects the resulting error from the set of errors returned by
policies. In general, errors indicating that an object does not exist
will be preferred to errors indicating that access to an object is
denied. While it is not guaranteed that the resulting composition will
be useful or secure, we have found that it is for many useful selections
of policies. For example, traditional trusted systems often ship with
two or more policies using a similar composition.

6.5.9. Labeling Support

As many interesting access control extensions rely on security labels on
objects, the MAC Framework provides a set of policy-agnostic label
management system calls covering a variety of user-exposed objects.
Common label types include partition identifiers, sensitivity labels,
integrity labels, compartments, domains, roles, and types. By policy
agnostic, we mean that policy modules are able to completely define the
semantics of meta-data associated with an object. Policy modules
participate in the internalization and externalization of string-based
labels provides by user applications, and can expose multiple label
elements to applications if desired.

In-memory labels are stored in slab-allocated struct label, which
consists of a fixed-length array of unions, each holding a void *
pointer and a long. Policies registering for label storage will be
assigned a "slot" identifier, which may be used to dereference the label
storage. The semantics of the storage are left entirely up to the policy
module: modules are provided with a variety of entry points associated
with the kernel object life cycle, including initialization,
association/creation, and destruction. Using these interfaces, it is
possible to implement reference counting and other storage models.
Direct access to the object structure is generally not required by
policy modules to retrieve a label, as the MAC Framework generally
passes both a pointer to the object and a direct pointer to the object’s
label into entry points. The primary exception to this rule is the
process credential, which must be manually dereferenced to access the
credential label. This may change in future revisions of the MAC
Framework.

Initialization entry points frequently include a sleeping disposition
flag indicating whether or not an initialization is permitted to sleep;
if sleeping is not permitted, a failure may be returned to cancel
allocation of the label (and hence object). This may occur, for example,
in the network stack during interrupt handling, where sleeping is not
permitted, or while the caller holds a mutex. Due to the performance
cost of maintaining labels on in-flight network packets (Mbufs),
policies must specifically declare a requirement that Mbuf labels be
allocated. Dynamically loaded policies making use of labels must be able
to handle the case where their init function has not been called on an
object, as objects may already exist when the policy is loaded. The MAC
Framework guarantees that uninitialized label slots will hold a 0 or
NULL value, which policies may use to detect uninitialized values.
However, as allocation of Mbuf labels is conditional, policies must also
be able to handle a NULL label pointer for Mbufs if they have been
loaded dynamically.

In the case of file system labels, special support is provided for the
persistent storage of security labels in extended attributes. Where
available, extended attribute transactions are used to permit consistent
compound updates of security labels on vnodes—​currently this support is
present only in the UFS2 file system. Policy authors may choose to
implement multilabel file system object labels using one (or more)
extended attributes. For efficiency reasons, the vnode label (v_label)
is a cache of any on-disk label; policies are able to load values into
the cache when the vnode is instantiated, and update the cache as
needed. As a result, the extended attribute need not be directly
accessed with every access control check.

+-----------------------------------+-----------------------------------+
|                                   | Currently, if a labeled policy    |
|                                   | permits dynamic unloading, its    |
|                                   | state slot cannot be reclaimed,   |
|                                   | which places a strict (and        |
|                                   | relatively low) bound on the      |
|                                   | number of unload-reload           |
|                                   | operations for labeled policies.  |
+-----------------------------------+-----------------------------------+

6.5.10. System Calls

The MAC Framework implements a number of system calls: most of these
calls support the policy-agnostic label retrieval and manipulation APIs
exposed to user applications.

The label management calls accept a label description structure,
struct mac, which contains a series of MAC label elements. Each element
contains a character string name, and character string value. Each
policy will be given the chance to claim a particular element name,
permitting policies to expose multiple independent elements if desired.
Policy modules perform the internalization and externalization between
kernel labels and user-provided labels via entry points, permitting a
variety of semantics. Label management system calls are generally
wrapped by user library functions to perform memory allocation and error
handling, simplifying user applications that must manage labels.

The following MAC-related system calls are present in the FreeBSD
kernel:

-   mac_get_proc() may be used to retrieve the label of the current
    process.

-   mac_set_proc() may be used to request a change in the label of the
    current process.

-   mac_get_fd() may be used to retrieve the label of an object (file,
    socket, pipe, …​) referenced by a file descriptor.

-   mac_get_file() may be used to retrieve the label of an object
    referenced by a file system path.

-   mac_set_fd() may be used to request a change in the label of an
    object (file, socket, pipe, …​) referenced by a file descriptor.

-   mac_set_file() may be used to request a change in the label of an
    object referenced by a file system path.

-   mac_syscall() permits policy modules to create new system calls
    without modifying the system call table; it accepts a target policy
    name, operation number, and opaque argument for use by the policy.

-   mac_get_pid() may be used to request the label of another process by
    process id.

-   mac_get_link() is identical to mac_get_file(), only it will not
    follow a symbolic link if it is the final entry in the path, so may
    be used to retrieve the label on a symlink.

-   mac_set_link() is identical to mac_set_file(), only it will not
    follow a symbolic link if it is the final entry in a path, so may be
    used to manipulate the label on a symlink.

-   mac_execve() is identical to the execve() system call, only it also
    accepts a requested label to set the process label to when beginning
    execution of a new program. This change in label on execution is
    referred to as a "transition".

-   mac_get_peer(), actually implemented via a socket option, retrieves
    the label of a remote peer on a socket, if available.

In addition to these system calls, the SIOCSIGMAC and SIOCSIFMAC network
interface ioctls permit the labels on network interfaces to be retrieved
and set.

6.6. MAC Policy Architecture

Security policies are either linked directly into the kernel, or
compiled into loadable kernel modules that may be loaded at boot, or
dynamically using the module loading system calls at runtime. Policy
modules interact with the system through a set of declared entry points,
providing access to a stream of system events and permitting the policy
to influence access control decisions. Each policy contains a number of
elements:

-   Optional configuration parameters for policy.

-   Centralized implementation of the policy logic and parameters.

-   Optional implementation of policy life cycle events, such as
    initialization and destruction.

-   Optional support for initializing, maintaining, and destroying
    labels on selected kernel objects.

-   Optional support for user process inspection and modification of
    labels on selected objects.

-   Implementation of selected access control entry points that are of
    interest to the policy.

-   Declaration of policy identity, module entry points, and policy
    properties.

6.6.1. Policy Declaration

Modules may be declared using the MAC_POLICY_SET() macro, which names
the policy, provides a reference to the MAC entry point vector, provides
load-time flags determining how the policy framework should handle the
policy, and optionally requests the allocation of label state by the
framework.

    static struct mac_policy_ops mac_policy_ops =
    {
            .mpo_destroy = mac_policy_destroy,
            .mpo_init = mac_policy_init,
            .mpo_init_bpfdesc_label = mac_policy_init_bpfdesc_label,
            .mpo_init_cred_label = mac_policy_init_label,
    /* ... */
            .mpo_check_vnode_setutimes = mac_policy_check_vnode_setutimes,
            .mpo_check_vnode_stat = mac_policy_check_vnode_stat,
            .mpo_check_vnode_write = mac_policy_check_vnode_write,
    };

The MAC policy entry point vector, macpolicyops in this example,
associates functions defined in the module with specific entry points. A
complete listing of available entry points and their prototypes may be
found in the MAC entry point reference section. Of specific interest
during module registration are the .mpo_destroy and .mpo_init entry
points. .mpo_init will be invoked once a policy is successfully
registered with the module framework but prior to any other entry points
becoming active. This permits the policy to perform any policy-specific
allocation and initialization, such as initialization of any data or
locks. .mpo_destroy will be invoked when a policy module is unloaded to
permit releasing of any allocated memory and destruction of locks.
Currently, these two entry points are invoked with the MAC policy list
mutex held to prevent any other entry points from being invoked: this
will be changed, but in the mean time, policies should be careful about
what kernel primitives they invoke so as to avoid lock ordering or
sleeping problems.

The policy declaration’s module name field exists so that the module may
be uniquely identified for the purposes of module dependencies. An
appropriate string should be selected. The full string name of the
policy is displayed to the user via the kernel log during load and
unload events, and also exported when providing status information to
userland processes.

6.6.2. Policy Flags

The policy declaration flags field permits the module to provide the
framework with information about its capabilities at the time the module
is loaded. Currently, three flags are defined:

MPC_LOADTIME_FLAG_UNLOADOK

    This flag indicates that the policy module may be unloaded. If this
    flag is not provided, then the policy framework will reject requests
    to unload the module. This flag might be used by modules that
    allocate label state and are unable to free that state at runtime.

MPC_LOADTIME_FLAG_NOTLATE

    This flag indicates that the policy module must be loaded and
    initialized early in the boot process. If the flag is specified,
    attempts to register the module following boot will be rejected. The
    flag may be used by policies that require pervasive labeling of all
    system objects, and cannot handle objects that have not been
    properly initialized by the policy.

MPC_LOADTIME_FLAG_LABELMBUFS

    This flag indicates that the policy module requires labeling of
    Mbufs, and that memory should always be allocated for the storage of
    Mbuf labels. By default, the MAC Framework will not allocate label
    storage for Mbufs unless at least one loaded policy has this flag
    set. This measurably improves network performance when policies do
    not require Mbuf labeling. A kernel option, MAC_ALWAYS_LABEL_MBUF,
    exists to force the MAC Framework to allocate Mbuf label storage
    regardless of the setting of this flag, and may be useful in some
    environments.

+-----------------------------------+-----------------------------------+
|                                   | Policies using the                |
|                                   | MPC_LOADTIME_FLAG_LABELMBUFS      |
|                                   | without the                       |
|                                   | MPC_LOADTIME_FLAG_NOTLATE flag    |
|                                   | set must be able to correctly     |
|                                   | handle NULL Mbuf label pointers   |
|                                   | passed into entry points. This is |
|                                   | necessary as in-flight Mbufs      |
|                                   | without label storage may persist |
|                                   | after a policy enabling Mbuf      |
|                                   | labeling has been loaded. If a    |
|                                   | policy is loaded before the       |
|                                   | network subsystem is active       |
|                                   | (i.e., the policy is not being    |
|                                   | loaded late), then all Mbufs are  |
|                                   | guaranteed to have label storage. |
+-----------------------------------+-----------------------------------+

6.6.3. Policy Entry Points

Four classes of entry points are offered to policies registered with the
framework: entry points associated with the registration and management
of policies, entry points denoting initialization, creation,
destruction, and other life cycle events for kernel objects, events
associated with access control decisions that the policy module may
influence, and calls associated with the management of labels on
objects. In addition, a mac_syscall() entry point is provided so that
policies may extend the kernel interface without registering new system
calls.

Policy module writers should be aware of the kernel locking strategy, as
well as what object locks are available during which entry points.
Writers should attempt to avoid deadlock scenarios by avoiding grabbing
non-leaf locks inside of entry points, and also follow the locking
protocol for object access and modification. In particular, writers
should be aware that while necessary locks to access objects and their
labels are generally held, sufficient locks to modify an object or its
label may not be present for all entry points. Locking information for
arguments is documented in the MAC framework entry point document.

Policy entry points will pass a reference to the object label along with
the object itself. This permits labeled policies to be unaware of the
internals of the object yet still make decisions based on the label. The
exception to this is the process credential, which is assumed to be
understood by policies as a first class security object in the kernel.

6.7. MAC Policy Entry Point Reference

6.7.1. General-Purpose Module Entry Points

6.7.1.1. mpo_init

    void mpo_init(  conf);
    struct mac_policy_conf *conf;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| conf                 | MAC policy           |                       |
|                      | definition           |                       |
+----------------------+----------------------+-----------------------+

Policy load event. The policy list mutex is held, so sleep operations
cannot be performed, and calls out to other kernel subsystems must be
made with caution. If potentially sleeping memory allocations are
required during policy initialization, they should be made using a
separate module SYSINIT().

6.7.1.2. mpo_destroy

    void mpo_destroy(    conf);
    struct mac_policy_conf *conf;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| conf                 | MAC policy           |                       |
|                      | definition           |                       |
+----------------------+----------------------+-----------------------+

Policy load event. The policy list mutex is held, so caution should be
applied.

6.7.1.3. mpo_syscall

    int mpo_syscall( td,
        call,
        arg);
    struct thread *td;
    int call;
    void *arg;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| td                   | Calling thread       |                       |
+----------------------+----------------------+-----------------------+
| call                 | Policy-specific      |                       |
|                      | syscall number       |                       |
+----------------------+----------------------+-----------------------+
| arg                  | Pointer to syscall   |                       |
|                      | arguments            |                       |
+----------------------+----------------------+-----------------------+

This entry point provides a policy-multiplexed system call so that
policies may provide additional services to user processes without
registering specific system calls. The policy name provided during
registration is used to demultiplexer calls from userland, and the
arguments will be forwarded to this entry point. When implementing new
services, security modules should be sure to invoke appropriate access
control checks from the MAC framework as needed. For example, if a
policy implements an augmented signal functionality, it should call the
necessary signal access control checks to invoke the MAC framework and
other registered policies.

+-----------------------------------+-----------------------------------+
|                                   | Modules must currently perform    |
|                                   | the copyin() of the syscall data  |
|                                   | on their own.                     |
+-----------------------------------+-----------------------------------+

6.7.1.4. mpo_thread_userret

    void mpo_thread_userret(    td);
    struct thread *td;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| td                   | Returning thread     |                       |
+----------------------+----------------------+-----------------------+

This entry point permits policy modules to perform MAC-related events
when a thread returns to user space, via a system call return, trap
return, or otherwise. This is required for policies that have floating
process labels, as it is not always possible to acquire the process lock
at arbitrary points in the stack during system call processing; process
labels might represent traditional authentication data, process history
information, or other data. To employ this mechanism, intended changes
to the process credential label may be stored in the p_label protected
by a per-policy spin lock, and then set the per-thread TDF_ASTPENDING
flag and per-process PS_MACPENDM flag to schedule a call to the userret
entry point. From this entry point, the policy may create a replacement
credential with less concern about the locking context. Policy writers
are cautioned that event ordering relating to scheduling an AST and the
AST being performed may be complex and interlaced in multithreaded
applications.

6.7.2. Label Operations

6.7.2.1. mpo_init_bpfdesc_label

    void mpo_init_bpfdesc_label( label);
    struct label *label;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| label                | New label to apply   |                       |
+----------------------+----------------------+-----------------------+

Initialize the label on a newly instantiated bpfdesc (BPF descriptor).
Sleeping is permitted.

6.7.2.2. mpo_init_cred_label

    void mpo_init_cred_label(  label);
    struct label *label;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| label                | New label to         |                       |
|                      | initialize           |                       |
+----------------------+----------------------+-----------------------+

Initialize the label for a newly instantiated user credential. Sleeping
is permitted.

6.7.2.3. mpo_init_devfsdirent_label

    void mpo_init_devfsdirent_label(  label);
    struct label *label;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| label                | New label to apply   |                       |
+----------------------+----------------------+-----------------------+

Initialize the label on a newly instantiated devfs entry. Sleeping is
permitted.

6.7.2.4. mpo_init_ifnet_label

    void mpo_init_ifnet_label(  label);
    struct label *label;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| label                | New label to apply   |                       |
+----------------------+----------------------+-----------------------+

Initialize the label on a newly instantiated network interface. Sleeping
is permitted.

6.7.2.5. mpo_init_ipq_label

    void mpo_init_ipq_label(  label,
        flag);
    struct label *label;
    int flag;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| label                | New label to apply   |                       |
+----------------------+----------------------+-----------------------+
| flag                 | S                    |                       |
|                      | leeping/non-sleeping |                       |
|                      | malloc(9); see below |                       |
+----------------------+----------------------+-----------------------+

Initialize the label on a newly instantiated IP fragment reassembly
queue. The flag field may be one of M_WAITOK and M_NOWAIT, and should be
employed to avoid performing a sleeping malloc(9) during this
initialization call. IP fragment reassembly queue allocation frequently
occurs in performance sensitive environments, and the implementation
should be careful to avoid sleeping or long-lived operations. This entry
point is permitted to fail resulting in the failure to allocate the IP
fragment reassembly queue.

6.7.2.6. mpo_init_mbuf_label

    void mpo_init_mbuf_label(    flag,
        label);
    int flag;
    struct label *label;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| flag                 | S                    |                       |
|                      | leeping/non-sleeping |                       |
|                      | malloc(9); see below |                       |
+----------------------+----------------------+-----------------------+
| label                | Policy label to      |                       |
|                      | initialize           |                       |
+----------------------+----------------------+-----------------------+

Initialize the label on a newly instantiated mbuf packet header (mbuf).
The flag field may be one of M_WAITOK and M_NOWAIT, and should be
employed to avoid performing a sleeping malloc(9) during this
initialization call. Mbuf allocation frequently occurs in performance
sensitive environments, and the implementation should be careful to
avoid sleeping or long-lived operations. This entry point is permitted
to fail resulting in the failure to allocate the mbuf header.

6.7.2.7. mpo_init_mount_label

    void mpo_init_mount_label( mntlabel,
        fslabel);
    struct label *mntlabel;
    struct label *fslabel;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| mntlabel             | Policy label to be   |                       |
|                      | initialized for the  |                       |
|                      | mount itself         |                       |
+----------------------+----------------------+-----------------------+
| fslabel              | Policy label to be   |                       |
|                      | initialized for the  |                       |
|                      | file system          |                       |
+----------------------+----------------------+-----------------------+

Initialize the labels on a newly instantiated mount point. Sleeping is
permitted.

6.7.2.8. mpo_init_mount_fs_label

    void mpo_init_mount_fs_label(  label);
    struct label *label;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| label                | Label to be          |                       |
|                      | initialized          |                       |
+----------------------+----------------------+-----------------------+

Initialize the label on a newly mounted file system. Sleeping is
permitted

6.7.2.9. mpo_init_pipe_label

    void mpo_init_pipe_label(   label);
    struct label*label;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| label                | Label to be filled   |                       |
|                      | in                   |                       |
+----------------------+----------------------+-----------------------+

Initialize a label for a newly instantiated pipe. Sleeping is permitted.

6.7.2.10. mpo_init_socket_label

    void mpo_init_socket_label( label,
        flag);
    struct label *label;
    int flag;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| label                | New label to         |                       |
|                      | initialize           |                       |
+----------------------+----------------------+-----------------------+
| flag                 | malloc(9) flags      |                       |
+----------------------+----------------------+-----------------------+

Initialize a label for a newly instantiated socket. The flag field may
be one of M_WAITOK and M_NOWAIT, and should be employed to avoid
performing a sleeping malloc(9) during this initialization call.

6.7.2.11. mpo_init_socket_peer_label

    void mpo_init_socket_peer_label( label,
        flag);
    struct label *label;
    int flag;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| label                | New label to         |                       |
|                      | initialize           |                       |
+----------------------+----------------------+-----------------------+
| flag                 | malloc(9) flags      |                       |
+----------------------+----------------------+-----------------------+

Initialize the peer label for a newly instantiated socket. The flag
field may be one of M_WAITOK and M_NOWAIT, and should be employed to
avoid performing a sleeping malloc(9) during this initialization call.

6.7.2.12. mpo_init_proc_label

    void mpo_init_proc_label( label);
    struct label *label;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| label                | New label to         |                       |
|                      | initialize           |                       |
+----------------------+----------------------+-----------------------+

Initialize the label for a newly instantiated process. Sleeping is
permitted.

6.7.2.13. mpo_init_vnode_label

    void mpo_init_vnode_label( label);
    struct label *label;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| label                | New label to         |                       |
|                      | initialize           |                       |
+----------------------+----------------------+-----------------------+

Initialize the label on a newly instantiated vnode. Sleeping is
permitted.

6.7.2.14. mpo_destroy_bpfdesc_label

    void mpo_destroy_bpfdesc_label( label);
    struct label *label;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| label                | bpfdesc label        |                       |
+----------------------+----------------------+-----------------------+

Destroy the label on a BPF descriptor. In this entry point a policy
should free any internal storage associated with label so that it may be
destroyed.

6.7.2.15. mpo_destroy_cred_label

    void mpo_destroy_cred_label(  label);
    struct label *label;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| label                | Label being          |                       |
|                      | destroyed            |                       |
+----------------------+----------------------+-----------------------+

Destroy the label on a credential. In this entry point, a policy module
should free any internal storage associated with label so that it may be
destroyed.

6.7.2.16. mpo_destroy_devfsdirent_label

    void mpo_destroy_devfsdirent_label(  label);
    struct label *label;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| label                | Label being          |                       |
|                      | destroyed            |                       |
+----------------------+----------------------+-----------------------+

Destroy the label on a devfs entry. In this entry point, a policy module
should free any internal storage associated with label so that it may be
destroyed.

6.7.2.17. mpo_destroy_ifnet_label

    void mpo_destroy_ifnet_label(  label);
    struct label *label;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| label                | Label being          |                       |
|                      | destroyed            |                       |
+----------------------+----------------------+-----------------------+

Destroy the label on a removed interface. In this entry point, a policy
module should free any internal storage associated with label so that it
may be destroyed.

6.7.2.18. mpo_destroy_ipq_label

    void mpo_destroy_ipq_label(  label);
    struct label *label;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| label                | Label being          |                       |
|                      | destroyed            |                       |
+----------------------+----------------------+-----------------------+

Destroy the label on an IP fragment queue. In this entry point, a policy
module should free any internal storage associated with label so that it
may be destroyed.

6.7.2.19. mpo_destroy_mbuf_label

    void mpo_destroy_mbuf_label(  label);
    struct label *label;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| label                | Label being          |                       |
|                      | destroyed            |                       |
+----------------------+----------------------+-----------------------+

Destroy the label on an mbuf header. In this entry point, a policy
module should free any internal storage associated with label so that it
may be destroyed.

6.7.2.20. mpo_destroy_mount_label

    void mpo_destroy_mount_label(  label);
    struct label *label;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| label                | Mount point label    |                       |
|                      | being destroyed      |                       |
+----------------------+----------------------+-----------------------+

Destroy the labels on a mount point. In this entry point, a policy
module should free the internal storage associated with mntlabel so that
they may be destroyed.

6.7.2.21. mpo_destroy_mount_label

    void mpo_destroy_mount_label( mntlabel,
        fslabel);
    struct label *mntlabel;
    struct label *fslabel;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| mntlabel             | Mount point label    |                       |
|                      | being destroyed      |                       |
+----------------------+----------------------+-----------------------+
| fslabel              | File system label    |                       |
|                      | being destroyed>     |                       |
+----------------------+----------------------+-----------------------+

Destroy the labels on a mount point. In this entry point, a policy
module should free the internal storage associated with mntlabel and
fslabel so that they may be destroyed.

6.7.2.22. mpo_destroy_socket_label

    void mpo_destroy_socket_label(    label);
    struct label *label;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| label                | Socket label being   |                       |
|                      | destroyed            |                       |
+----------------------+----------------------+-----------------------+

Destroy the label on a socket. In this entry point, a policy module
should free any internal storage associated with label so that it may be
destroyed.

6.7.2.23. mpo_destroy_socket_peer_label

    void mpo_destroy_socket_peer_label(  peerlabel);
    struct label *peerlabel;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| peerlabel            | Socket peer label    |                       |
|                      | being destroyed      |                       |
+----------------------+----------------------+-----------------------+

Destroy the peer label on a socket. In this entry point, a policy module
should free any internal storage associated with label so that it may be
destroyed.

6.7.2.24. mpo_destroy_pipe_label

    void mpo_destroy_pipe_label(  label);
    struct label *label;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| label                | Pipe label           |                       |
+----------------------+----------------------+-----------------------+

Destroy the label on a pipe. In this entry point, a policy module should
free any internal storage associated with label so that it may be
destroyed.

6.7.2.25. mpo_destroy_proc_label

    void mpo_destroy_proc_label(  label);
    struct label *label;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| label                | Process label        |                       |
+----------------------+----------------------+-----------------------+

Destroy the label on a process. In this entry point, a policy module
should free any internal storage associated with label so that it may be
destroyed.

6.7.2.26. mpo_destroy_vnode_label

    void mpo_destroy_vnode_label(  label);
    struct label *label;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| label                | Process label        |                       |
+----------------------+----------------------+-----------------------+

Destroy the label on a vnode. In this entry point, a policy module
should free any internal storage associated with label so that it may be
destroyed.

6.7.2.27. mpo_copy_mbuf_label

    void mpo_copy_mbuf_label(  src,
        dest);
    struct label *src;
    struct label *dest;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| src                  | Source label         |                       |
+----------------------+----------------------+-----------------------+
| dest                 | Destination label    |                       |
+----------------------+----------------------+-----------------------+

Copy the label information in src into dest.

6.7.2.28. mpo_copy_pipe_label

    void mpo_copy_pipe_label( src,
        dest);
    struct label *src;
    struct label *dest;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| src                  | Source label         |                       |
+----------------------+----------------------+-----------------------+
| dest                 | Destination label    |                       |
+----------------------+----------------------+-----------------------+

Copy the label information in src into dest.

6.7.2.29. mpo_copy_vnode_label

    void mpo_copy_vnode_label( src,
        dest);
    struct label *src;
    struct label *dest;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| src                  | Source label         |                       |
+----------------------+----------------------+-----------------------+
| dest                 | Destination label    |                       |
+----------------------+----------------------+-----------------------+

Copy the label information in src into dest.

6.7.2.30. mpo_externalize_cred_label

    int mpo_externalize_cred_label(  label,
        element_name,
        sb,
        *claimed);
    struct label *label;
    char *element_name;
    struct sbuf *sb;
    int *claimed;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| label                | Label to be          |                       |
|                      | externalized         |                       |
+----------------------+----------------------+-----------------------+
| element_name         | Name of the policy   |                       |
|                      | whose label should   |                       |
|                      | be externalized      |                       |
+----------------------+----------------------+-----------------------+
| sb                   | String buffer to be  |                       |
|                      | filled with a text   |                       |
|                      | representation of    |                       |
|                      | label                |                       |
+----------------------+----------------------+-----------------------+
| claimed              | Should be            |                       |
|                      | incremented when     |                       |
|                      | element_data can be  |                       |
|                      | filled in.           |                       |
+----------------------+----------------------+-----------------------+

Produce an externalized label based on the label structure passed. An
externalized label consists of a text representation of the label
contents that can be used with userland applications and read by the
user. Currently, all policies' externalize entry points will be called,
so the implementation should check the contents of element_name before
attempting to fill in sb. If element_name does not match the name of
your policy, simply return 0. Only return nonzero if an error occurs
while externalizing the label data. Once the policy fills in
element_data, *claimed should be incremented.

6.7.2.31. mpo_externalize_ifnet_label

    int mpo_externalize_ifnet_label(    label,
        element_name,
        sb,
        *claimed);
    struct label *label;
    char *element_name;
    struct sbuf *sb;
    int *claimed;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| label                | Label to be          |                       |
|                      | externalized         |                       |
+----------------------+----------------------+-----------------------+
| element_name         | Name of the policy   |                       |
|                      | whose label should   |                       |
|                      | be externalized      |                       |
+----------------------+----------------------+-----------------------+
| sb                   | String buffer to be  |                       |
|                      | filled with a text   |                       |
|                      | representation of    |                       |
|                      | label                |                       |
+----------------------+----------------------+-----------------------+
| claimed              | Should be            |                       |
|                      | incremented when     |                       |
|                      | element_data can be  |                       |
|                      | filled in.           |                       |
+----------------------+----------------------+-----------------------+

Produce an externalized label based on the label structure passed. An
externalized label consists of a text representation of the label
contents that can be used with userland applications and read by the
user. Currently, all policies' externalize entry points will be called,
so the implementation should check the contents of element_name before
attempting to fill in sb. If element_name does not match the name of
your policy, simply return 0. Only return nonzero if an error occurs
while externalizing the label data. Once the policy fills in
element_data, *claimed should be incremented.

6.7.2.32. mpo_externalize_pipe_label

    int mpo_externalize_pipe_label(    label,
        element_name,
        sb,
        *claimed);
    struct label *label;
    char *element_name;
    struct sbuf *sb;
    int *claimed;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| label                | Label to be          |                       |
|                      | externalized         |                       |
+----------------------+----------------------+-----------------------+
| element_name         | Name of the policy   |                       |
|                      | whose label should   |                       |
|                      | be externalized      |                       |
+----------------------+----------------------+-----------------------+
| sb                   | String buffer to be  |                       |
|                      | filled with a text   |                       |
|                      | representation of    |                       |
|                      | label                |                       |
+----------------------+----------------------+-----------------------+
| claimed              | Should be            |                       |
|                      | incremented when     |                       |
|                      | element_data can be  |                       |
|                      | filled in.           |                       |
+----------------------+----------------------+-----------------------+

Produce an externalized label based on the label structure passed. An
externalized label consists of a text representation of the label
contents that can be used with userland applications and read by the
user. Currently, all policies' externalize entry points will be called,
so the implementation should check the contents of element_name before
attempting to fill in sb. If element_name does not match the name of
your policy, simply return 0. Only return nonzero if an error occurs
while externalizing the label data. Once the policy fills in
element_data, *claimed should be incremented.

6.7.2.33. mpo_externalize_socket_label

    int mpo_externalize_socket_label(    label,
        element_name,
        sb,
        *claimed);
    struct label *label;
    char *element_name;
    struct sbuf *sb;
    int *claimed;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| label                | Label to be          |                       |
|                      | externalized         |                       |
+----------------------+----------------------+-----------------------+
| element_name         | Name of the policy   |                       |
|                      | whose label should   |                       |
|                      | be externalized      |                       |
+----------------------+----------------------+-----------------------+
| sb                   | String buffer to be  |                       |
|                      | filled with a text   |                       |
|                      | representation of    |                       |
|                      | label                |                       |
+----------------------+----------------------+-----------------------+
| claimed              | Should be            |                       |
|                      | incremented when     |                       |
|                      | element_data can be  |                       |
|                      | filled in.           |                       |
+----------------------+----------------------+-----------------------+

Produce an externalized label based on the label structure passed. An
externalized label consists of a text representation of the label
contents that can be used with userland applications and read by the
user. Currently, all policies' externalize entry points will be called,
so the implementation should check the contents of element_name before
attempting to fill in sb. If element_name does not match the name of
your policy, simply return 0. Only return nonzero if an error occurs
while externalizing the label data. Once the policy fills in
element_data, *claimed should be incremented.

6.7.2.34. mpo_externalize_socket_peer_label

    int mpo_externalize_socket_peer_label(    label,
        element_name,
        sb,
        *claimed);
    struct label *label;
    char *element_name;
    struct sbuf *sb;
    int *claimed;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| label                | Label to be          |                       |
|                      | externalized         |                       |
+----------------------+----------------------+-----------------------+
| element_name         | Name of the policy   |                       |
|                      | whose label should   |                       |
|                      | be externalized      |                       |
+----------------------+----------------------+-----------------------+
| sb                   | String buffer to be  |                       |
|                      | filled with a text   |                       |
|                      | representation of    |                       |
|                      | label                |                       |
+----------------------+----------------------+-----------------------+
| claimed              | Should be            |                       |
|                      | incremented when     |                       |
|                      | element_data can be  |                       |
|                      | filled in.           |                       |
+----------------------+----------------------+-----------------------+

Produce an externalized label based on the label structure passed. An
externalized label consists of a text representation of the label
contents that can be used with userland applications and read by the
user. Currently, all policies' externalize entry points will be called,
so the implementation should check the contents of element_name before
attempting to fill in sb. If element_name does not match the name of
your policy, simply return 0. Only return nonzero if an error occurs
while externalizing the label data. Once the policy fills in
element_data, *claimed should be incremented.

6.7.2.35. mpo_externalize_vnode_label

    int mpo_externalize_vnode_label(    label,
        element_name,
        sb,
        *claimed);
    struct label *label;
    char *element_name;
    struct sbuf *sb;
    int *claimed;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| label                | Label to be          |                       |
|                      | externalized         |                       |
+----------------------+----------------------+-----------------------+
| element_name         | Name of the policy   |                       |
|                      | whose label should   |                       |
|                      | be externalized      |                       |
+----------------------+----------------------+-----------------------+
| sb                   | String buffer to be  |                       |
|                      | filled with a text   |                       |
|                      | representation of    |                       |
|                      | label                |                       |
+----------------------+----------------------+-----------------------+
| claimed              | Should be            |                       |
|                      | incremented when     |                       |
|                      | element_data can be  |                       |
|                      | filled in.           |                       |
+----------------------+----------------------+-----------------------+

Produce an externalized label based on the label structure passed. An
externalized label consists of a text representation of the label
contents that can be used with userland applications and read by the
user. Currently, all policies' externalize entry points will be called,
so the implementation should check the contents of element_name before
attempting to fill in sb. If element_name does not match the name of
your policy, simply return 0. Only return nonzero if an error occurs
while externalizing the label data. Once the policy fills in
element_data, *claimed should be incremented.

6.7.2.36. mpo_internalize_cred_label

    int mpo_internalize_cred_label(    label,
        element_name,
        element_data,
        claimed);
    struct label *label;
    char *element_name;
    char *element_data;
    int *claimed;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| label                | Label to be filled   |                       |
|                      | in                   |                       |
+----------------------+----------------------+-----------------------+
| element_name         | Name of the policy   |                       |
|                      | whose label should   |                       |
|                      | be internalized      |                       |
+----------------------+----------------------+-----------------------+
| element_data         | Text data to be      |                       |
|                      | internalized         |                       |
+----------------------+----------------------+-----------------------+
| claimed              | Should be            |                       |
|                      | incremented when     |                       |
|                      | data can be          |                       |
|                      | successfully         |                       |
|                      | internalized.        |                       |
+----------------------+----------------------+-----------------------+

Produce an internal label structure based on externalized label data in
text format. Currently, all policies' internalize entry points are
called when internalization is requested, so the implementation should
compare the contents of element_name to its own name in order to be sure
it should be internalizing the data in element_data. Just as in the
externalize entry points, the entry point should return 0 if
element_name does not match its own name, or when data can successfully
be internalized, in which case *claimed should be incremented.

6.7.2.37. mpo_internalize_ifnet_label

    int mpo_internalize_ifnet_label(   label,
        element_name,
        element_data,
        claimed);
    struct label *label;
    char *element_name;
    char *element_data;
    int *claimed;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| label                | Label to be filled   |                       |
|                      | in                   |                       |
+----------------------+----------------------+-----------------------+
| element_name         | Name of the policy   |                       |
|                      | whose label should   |                       |
|                      | be internalized      |                       |
+----------------------+----------------------+-----------------------+
| element_data         | Text data to be      |                       |
|                      | internalized         |                       |
+----------------------+----------------------+-----------------------+
| claimed              | Should be            |                       |
|                      | incremented when     |                       |
|                      | data can be          |                       |
|                      | successfully         |                       |
|                      | internalized.        |                       |
+----------------------+----------------------+-----------------------+

Produce an internal label structure based on externalized label data in
text format. Currently, all policies' internalize entry points are
called when internalization is requested, so the implementation should
compare the contents of element_name to its own name in order to be sure
it should be internalizing the data in element_data. Just as in the
externalize entry points, the entry point should return 0 if
element_name does not match its own name, or when data can successfully
be internalized, in which case *claimed should be incremented.

6.7.2.38. mpo_internalize_pipe_label

    int mpo_internalize_pipe_label(   label,
        element_name,
        element_data,
        claimed);
    struct label *label;
    char *element_name;
    char *element_data;
    int *claimed;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| label                | Label to be filled   |                       |
|                      | in                   |                       |
+----------------------+----------------------+-----------------------+
| element_name         | Name of the policy   |                       |
|                      | whose label should   |                       |
|                      | be internalized      |                       |
+----------------------+----------------------+-----------------------+
| element_data         | Text data to be      |                       |
|                      | internalized         |                       |
+----------------------+----------------------+-----------------------+
| claimed              | Should be            |                       |
|                      | incremented when     |                       |
|                      | data can be          |                       |
|                      | successfully         |                       |
|                      | internalized.        |                       |
+----------------------+----------------------+-----------------------+

Produce an internal label structure based on externalized label data in
text format. Currently, all policies' internalize entry points are
called when internalization is requested, so the implementation should
compare the contents of element_name to its own name in order to be sure
it should be internalizing the data in element_data. Just as in the
externalize entry points, the entry point should return 0 if
element_name does not match its own name, or when data can successfully
be internalized, in which case *claimed should be incremented.

6.7.2.39. mpo_internalize_socket_label

    int mpo_internalize_socket_label(   label,
        element_name,
        element_data,
        claimed);
    struct label *label;
    char *element_name;
    char *element_data;
    int *claimed;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| label                | Label to be filled   |                       |
|                      | in                   |                       |
+----------------------+----------------------+-----------------------+
| element_name         | Name of the policy   |                       |
|                      | whose label should   |                       |
|                      | be internalized      |                       |
+----------------------+----------------------+-----------------------+
| element_data         | Text data to be      |                       |
|                      | internalized         |                       |
+----------------------+----------------------+-----------------------+
| claimed              | Should be            |                       |
|                      | incremented when     |                       |
|                      | data can be          |                       |
|                      | successfully         |                       |
|                      | internalized.        |                       |
+----------------------+----------------------+-----------------------+

Produce an internal label structure based on externalized label data in
text format. Currently, all policies' internalize entry points are
called when internalization is requested, so the implementation should
compare the contents of element_name to its own name in order to be sure
it should be internalizing the data in element_data. Just as in the
externalize entry points, the entry point should return 0 if
element_name does not match its own name, or when data can successfully
be internalized, in which case *claimed should be incremented.

6.7.2.40. mpo_internalize_vnode_label

    int mpo_internalize_vnode_label(   label,
        element_name,
        element_data,
        claimed);
    struct label *label;
    char *element_name;
    char *element_data;
    int *claimed;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| label                | Label to be filled   |                       |
|                      | in                   |                       |
+----------------------+----------------------+-----------------------+
| element_name         | Name of the policy   |                       |
|                      | whose label should   |                       |
|                      | be internalized      |                       |
+----------------------+----------------------+-----------------------+
| element_data         | Text data to be      |                       |
|                      | internalized         |                       |
+----------------------+----------------------+-----------------------+
| claimed              | Should be            |                       |
|                      | incremented when     |                       |
|                      | data can be          |                       |
|                      | successfully         |                       |
|                      | internalized.        |                       |
+----------------------+----------------------+-----------------------+

Produce an internal label structure based on externalized label data in
text format. Currently, all policies' internalize entry points are
called when internalization is requested, so the implementation should
compare the contents of element_name to its own name in order to be sure
it should be internalizing the data in element_data. Just as in the
externalize entry points, the entry point should return 0 if
element_name does not match its own name, or when data can successfully
be internalized, in which case *claimed should be incremented.

6.7.3. Label Events

This class of entry points is used by the MAC framework to permit
policies to maintain label information on kernel objects. For each
labeled kernel object of interest to a MAC policy, entry points may be
registered for relevant life cycle events. All objects implement
initialization, creation, and destruction hooks. Some objects will also
implement relabeling, allowing user processes to change the labels on
objects. Some objects will also implement object-specific events, such
as label events associated with IP reassembly. A typical labeled object
will have the following life cycle of entry points:

    Label initialization          o
    (object-specific wait)         \
    Label creation                  o
                                     \
    Relabel events,                   o--<--.
    Various object-specific,          |     |
    Access control events             ~-->--o
                                             \
    Label destruction                         o

Label initialization permits policies to allocate memory and set initial
values for labels without context for the use of the object. The label
slot allocated to a policy will be zeroed by default, so some policies
may not need to perform initialization.

Label creation occurs when the kernel structure is associated with an
actual kernel object. For example, Mbufs may be allocated and remain
unused in a pool until they are required. mbuf allocation causes label
initialization on the mbuf to take place, but mbuf creation occurs when
the mbuf is associated with a datagram. Typically, context will be
provided for a creation event, including the circumstances of the
creation, and labels of other relevant objects in the creation process.
For example, when an mbuf is created from a socket, the socket and its
label will be presented to registered policies in addition to the new
mbuf and its label. Memory allocation in creation events is discouraged,
as it may occur in performance sensitive ports of the kernel; in
addition, creation calls are not permitted to fail so a failure to
allocate memory cannot be reported.

Object specific events do not generally fall into the other broad
classes of label events, but will generally provide an opportunity to
modify or update the label on an object based on additional context. For
example, the label on an IP fragment reassembly queue may be updated
during the MAC_UPDATE_IPQ entry point as a result of the acceptance of
an additional mbuf to that queue.

Access control events are discussed in detail in the following section.

Label destruction permits policies to release storage or state
associated with a label during its association with an object so that
the kernel data structures supporting the object may be reused or
released.

In addition to labels associated with specific kernel objects, an
additional class of labels exists: temporary labels. These labels are
used to store update information submitted by user processes. These
labels are initialized and destroyed as with other label types, but the
creation event is MAC_INTERNALIZE, which accepts a user label to be
converted to an in-kernel representation.

6.7.3.1. File System Object Labeling Event Operations

6.7.3.1.1. mpo_associate_vnode_devfs

    void mpo_associate_vnode_devfs(   mp,
        fslabel,
        de,
        delabel,
        vp,
        vlabel);
    struct mount *mp;
    struct label *fslabel;
    struct devfs_dirent *de;
    struct label *delabel;
    struct vnode *vp;
    struct label *vlabel;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| mp                   | Devfs mount point    |                       |
+----------------------+----------------------+-----------------------+
| fslabel              | Devfs file system    |                       |
|                      | label                |                       |
|                      | (mp→mnt_fslabel)     |                       |
+----------------------+----------------------+-----------------------+
| de                   | Devfs directory      |                       |
|                      | entry                |                       |
+----------------------+----------------------+-----------------------+
| delabel              | Policy label         |                       |
|                      | associated with de   |                       |
+----------------------+----------------------+-----------------------+
| vp                   | vnode associated     |                       |
|                      | with de              |                       |
+----------------------+----------------------+-----------------------+
| vlabel               | Policy label         |                       |
|                      | associated with vp   |                       |
+----------------------+----------------------+-----------------------+

Fill in the label (vlabel) for a newly created devfs vnode based on the
devfs directory entry passed in de and its label.

6.7.3.1.2. mpo_associate_vnode_extattr

    int mpo_associate_vnode_extattr(    mp,
        fslabel,
        vp,
        vlabel);
    struct mount *mp;
    struct label *fslabel;
    struct vnode *vp;
    struct label *vlabel;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| mp                   | File system mount    |                       |
|                      | point                |                       |
+----------------------+----------------------+-----------------------+
| fslabel              | File system label    |                       |
+----------------------+----------------------+-----------------------+
| vp                   | Vnode to label       |                       |
+----------------------+----------------------+-----------------------+
| vlabel               | Policy label         |                       |
|                      | associated with vp   |                       |
+----------------------+----------------------+-----------------------+

Attempt to retrieve the label for vp from the file system extended
attributes. Upon success, the value 0 is returned. Should extended
attribute retrieval not be supported, an accepted fallback is to copy
fslabel into vlabel. In the event of an error, an appropriate value for
errno should be returned.

6.7.3.1.3. mpo_associate_vnode_singlelabel

    void mpo_associate_vnode_singlelabel( mp,
        fslabel,
        vp,
        vlabel);
    struct mount *mp;
    struct label *fslabel;
    struct vnode *vp;
    struct label *vlabel;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| mp                   | File system mount    |                       |
|                      | point                |                       |
+----------------------+----------------------+-----------------------+
| fslabel              | File system label    |                       |
+----------------------+----------------------+-----------------------+
| vp                   | Vnode to label       |                       |
+----------------------+----------------------+-----------------------+
| vlabel               | Policy label         |                       |
|                      | associated with vp   |                       |
+----------------------+----------------------+-----------------------+

On non-multilabel file systems, this entry point is called to set the
policy label for vp based on the file system label, fslabel.

6.7.3.1.4. mpo_create_devfs_device

    void mpo_create_devfs_device(   dev,
        devfs_dirent,
        label);
    dev_t dev;
    struct devfs_dirent *devfs_dirent;
    struct label *label;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| dev                  | Device corresponding |                       |
|                      | with devfs_dirent    |                       |
+----------------------+----------------------+-----------------------+
| devfs_dirent         | Devfs directory      |                       |
|                      | entry to be labeled. |                       |
+----------------------+----------------------+-----------------------+
| label                | Label for            |                       |
|                      | devfs_dirent to be   |                       |
|                      | filled in.           |                       |
+----------------------+----------------------+-----------------------+

Fill out the label on a devfs_dirent being created for the passed
device. This call will be made when the device file system is mounted,
regenerated, or a new device is made available.

6.7.3.1.5. mpo_create_devfs_directory

    void mpo_create_devfs_directory(    dirname,
        dirnamelen,
        devfs_dirent,
        label);
    char *dirname;
    int dirnamelen;
    struct devfs_dirent *devfs_dirent;
    struct label *label;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| dirname              | Name of directory    |                       |
|                      | being created        |                       |
+----------------------+----------------------+-----------------------+
| namelen              | Length of string     |                       |
|                      | dirname              |                       |
+----------------------+----------------------+-----------------------+
| devfs_dirent         | Devfs directory      |                       |
|                      | entry for directory  |                       |
|                      | being created.       |                       |
+----------------------+----------------------+-----------------------+

Fill out the label on a devfs_dirent being created for the passed
directory. This call will be made when the device file system is
mounted, regenerated, or a new device requiring a specific directory
hierarchy is made available.

6.7.3.1.6. mpo_create_devfs_symlink

    void mpo_create_devfs_symlink(   cred,
        mp,
        dd,
        ddlabel,
        de,
        delabel);
    struct ucred *cred;
    struct mount *mp;
    struct devfs_dirent *dd;
    struct label *ddlabel;
    struct devfs_dirent *de;
    struct label *delabel;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| mp                   | Devfs mount point    |                       |
+----------------------+----------------------+-----------------------+
| dd                   | Link destination     |                       |
+----------------------+----------------------+-----------------------+
| ddlabel              | Label associated     |                       |
|                      | with dd              |                       |
+----------------------+----------------------+-----------------------+
| de                   | Symlink entry        |                       |
+----------------------+----------------------+-----------------------+
| delabel              | Label associated     |                       |
|                      | with de              |                       |
+----------------------+----------------------+-----------------------+

Fill in the label (delabel) for a newly created devfs(5) symbolic link
entry.

6.7.3.1.7. mpo_create_vnode_extattr

    int mpo_create_vnode_extattr(    cred,
        mp,
        fslabel,
        dvp,
        dlabel,
        vp,
        vlabel,
        cnp);
    struct ucred *cred;
    struct mount *mp;
    struct label *fslabel;
    struct vnode *dvp;
    struct label *dlabel;
    struct vnode *vp;
    struct label *vlabel;
    struct componentname *cnp;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| mount                | File system mount    |                       |
|                      | point                |                       |
+----------------------+----------------------+-----------------------+
| label                | File system label    |                       |
+----------------------+----------------------+-----------------------+
| dvp                  | Parent directory     |                       |
|                      | vnode                |                       |
+----------------------+----------------------+-----------------------+
| dlabel               | Label associated     |                       |
|                      | with dvp             |                       |
+----------------------+----------------------+-----------------------+
| vp                   | Newly created vnode  |                       |
+----------------------+----------------------+-----------------------+
| vlabel               | Policy label         |                       |
|                      | associated with vp   |                       |
+----------------------+----------------------+-----------------------+
| cnp                  | Component name for   |                       |
|                      | vp                   |                       |
+----------------------+----------------------+-----------------------+

Write out the label for vp to the appropriate extended attribute. If the
write succeeds, fill in vlabel with the label, and return 0. Otherwise,
return an appropriate error.

6.7.3.1.8. mpo_create_mount

    void mpo_create_mount(   cred,
        mp,
        mnt,
        fslabel);
    struct ucred *cred;
    struct mount *mp;
    struct label *mnt;
    struct label *fslabel;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| mp                   | Object; file system  |                       |
|                      | being mounted        |                       |
+----------------------+----------------------+-----------------------+
| mntlabel             | Policy label to be   |                       |
|                      | filled in for mp     |                       |
+----------------------+----------------------+-----------------------+
| fslabel              | Policy label for the |                       |
|                      | file system mp       |                       |
|                      | mounts.              |                       |
+----------------------+----------------------+-----------------------+

Fill out the labels on the mount point being created by the passed
subject credential. This call will be made when a new file system is
mounted.

6.7.3.1.9. mpo_create_root_mount

    void mpo_create_root_mount( cred,
        mp,
        mntlabel,
        fslabel);
    struct ucred *cred;
    struct mount *mp;
    struct label *mntlabel;
    struct label *fslabel;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| See                  |                      |                       |
| mpo_create_mount.    |                      |                       |
+----------------------+----------------------+-----------------------+

Fill out the labels on the mount point being created by the passed
subject credential. This call will be made when the root file system is
mounted, after mpo_create_mount;.

6.7.3.1.10. mpo_relabel_vnode

    void mpo_relabel_vnode(   cred,
        vp,
        vnodelabel,
        newlabel);
    struct ucred *cred;
    struct vnode *vp;
    struct label *vnodelabel;
    struct label *newlabel;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| vp                   | vnode to relabel     |                       |
+----------------------+----------------------+-----------------------+
| vnodelabel           | Existing policy      |                       |
|                      | label for vp         |                       |
+----------------------+----------------------+-----------------------+
| newlabel             | New, possibly        |                       |
|                      | partial label to     |                       |
|                      | replace vnodelabel   |                       |
+----------------------+----------------------+-----------------------+

Update the label on the passed vnode given the passed update vnode label
and the passed subject credential.

6.7.3.1.11. mpo_setlabel_vnode_extattr

    int mpo_setlabel_vnode_extattr(    cred,
        vp,
        vlabel,
        intlabel);
    struct ucred *cred;
    struct vnode *vp;
    struct label *vlabel;
    struct label *intlabel;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| vp                   | Vnode for which the  |                       |
|                      | label is being       |                       |
|                      | written              |                       |
+----------------------+----------------------+-----------------------+
| vlabel               | Policy label         |                       |
|                      | associated with vp   |                       |
+----------------------+----------------------+-----------------------+
| intlabel             | Label to write out   |                       |
+----------------------+----------------------+-----------------------+

Write out the policy from intlabel to an extended attribute. This is
called from vop_stdcreatevnode_ea.

6.7.3.1.12. mpo_update_devfsdirent

    void mpo_update_devfsdirent(  devfs_dirent,
        direntlabel,
        vp,
        vnodelabel);
    struct devfs_dirent *devfs_dirent;
    struct label *direntlabel;
    struct vnode *vp;
    struct label *vnodelabel;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| devfs_dirent         | Object; devfs        |                       |
|                      | directory entry      |                       |
+----------------------+----------------------+-----------------------+
| direntlabel          | Policy label for     |                       |
|                      | devfs_dirent to be   |                       |
|                      | updated.             |                       |
+----------------------+----------------------+-----------------------+
| vp                   | Parent vnode         | Locked                |
+----------------------+----------------------+-----------------------+
|                      | vnodelabel           | Policy label for vp   |
+----------------------+----------------------+-----------------------+

Update the devfs_dirent label from the passed devfs vnode label. This
call will be made when a devfs vnode has been successfully relabeled to
commit the label change such that it lasts even if the vnode is
recycled. It will also be made when a symlink is created in devfs,
following a call to mac_vnode_create_from_vnode to initialize the vnode
label.

6.7.3.2. IPC Object Labeling Event Operations

6.7.3.2.1. mpo_create_mbuf_from_socket

    void mpo_create_mbuf_from_socket(    so,
        socketlabel,
        m,
        mbuflabel);
    struct socket *so;
    struct label *socketlabel;
    struct mbuf *m;
    struct label *mbuflabel;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| socket               | Socket               | Socket locking WIP    |
+----------------------+----------------------+-----------------------+
| socketlabel          | Policy label for     |                       |
|                      | socket               |                       |
+----------------------+----------------------+-----------------------+
| m                    | Object; mbuf         |                       |
+----------------------+----------------------+-----------------------+
| mbuflabel            | Policy label to fill |                       |
|                      | in for m             |                       |
+----------------------+----------------------+-----------------------+

Set the label on a newly created mbuf header from the passed socket
label. This call is made when a new datagram or message is generated by
the socket and stored in the passed mbuf.

6.7.3.2.2. mpo_create_pipe

    void mpo_create_pipe(    cred,
        pipe,
        pipelabel);
    struct ucred *cred;
    struct pipe *pipe;
    struct label *pipelabel;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| pipe                 | Pipe                 |                       |
+----------------------+----------------------+-----------------------+
| pipelabel            | Policy label         |                       |
|                      | associated with pipe |                       |
+----------------------+----------------------+-----------------------+

Set the label on a newly created pipe from the passed subject
credential. This call is made when a new pipe is created.

6.7.3.2.3. mpo_create_socket

    void mpo_create_socket( cred,
        so,
        socketlabel);
    struct ucred *cred;
    struct socket *so;
    struct label *socketlabel;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   | Immutable             |
+----------------------+----------------------+-----------------------+
| so                   | Object; socket to    |                       |
|                      | label                |                       |
+----------------------+----------------------+-----------------------+
| socketlabel          | Label to fill in for |                       |
|                      | so                   |                       |
+----------------------+----------------------+-----------------------+

Set the label on a newly created socket from the passed subject
credential. This call is made when a socket is created.

6.7.3.2.4. mpo_create_socket_from_socket

    void mpo_create_socket_from_socket(   oldsocket,
        oldsocketlabel,
        newsocket,
        newsocketlabel);
    struct socket *oldsocket;
    struct label *oldsocketlabel;
    struct socket *newsocket;
    struct label *newsocketlabel;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| oldsocket            | Listening socket     |                       |
+----------------------+----------------------+-----------------------+
| oldsocketlabel       | Policy label         |                       |
|                      | associated with      |                       |
|                      | oldsocket            |                       |
+----------------------+----------------------+-----------------------+
| newsocket            | New socket           |                       |
+----------------------+----------------------+-----------------------+
| newsocketlabel       | Policy label         |                       |
|                      | associated with      |                       |
|                      | newsocketlabel       |                       |
+----------------------+----------------------+-----------------------+

Label a socket, newsocket, newly accept(2)ed, based on the listen(2)
socket, oldsocket.

6.7.3.2.5. mpo_relabel_pipe

    void mpo_relabel_pipe(    cred,
        pipe,
        oldlabel,
        newlabel);
    struct ucred *cred;
    struct pipe *pipe;
    struct label *oldlabel;
    struct label *newlabel;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| pipe                 | Pipe                 |                       |
+----------------------+----------------------+-----------------------+
| oldlabel             | Current policy label |                       |
|                      | associated with pipe |                       |
+----------------------+----------------------+-----------------------+
| newlabel             | Policy label update  |                       |
|                      | to apply to pipe     |                       |
+----------------------+----------------------+-----------------------+

Apply a new label, newlabel, to pipe.

6.7.3.2.6. mpo_relabel_socket

    void mpo_relabel_socket(    cred,
        so,
        oldlabel,
        newlabel);
    struct ucred *cred;
    struct socket *so;
    struct label *oldlabel;
    struct label *newlabel;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   | Immutable             |
+----------------------+----------------------+-----------------------+
| so                   | Object; socket       |                       |
+----------------------+----------------------+-----------------------+
| oldlabel             | Current label for so |                       |
+----------------------+----------------------+-----------------------+
| newlabel             | Label update for so  |                       |
+----------------------+----------------------+-----------------------+

Update the label on a socket from the passed socket label update.

6.7.3.2.7. mpo_set_socket_peer_from_mbuf

    void mpo_set_socket_peer_from_mbuf(   mbuf,
        mbuflabel,
        oldlabel,
        newlabel);
    struct mbuf *mbuf;
    struct label *mbuflabel;
    struct label *oldlabel;
    struct label *newlabel;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| mbuf                 | First datagram       |                       |
|                      | received over socket |                       |
+----------------------+----------------------+-----------------------+
| mbuflabel            | Label for mbuf       |                       |
+----------------------+----------------------+-----------------------+
| oldlabel             | Current label for    |                       |
|                      | the socket           |                       |
+----------------------+----------------------+-----------------------+
| newlabel             | Policy label to be   |                       |
|                      | filled out for the   |                       |
|                      | socket               |                       |
+----------------------+----------------------+-----------------------+

Set the peer label on a stream socket from the passed mbuf label. This
call will be made when the first datagram is received by the stream
socket, with the exception of Unix domain sockets.

6.7.3.2.8. mpo_set_socket_peer_from_socket

    void mpo_set_socket_peer_from_socket(   oldsocket,
        oldsocketlabel,
        newsocket,
        newsocketpeerlabel);
    struct socket *oldsocket;
    struct label *oldsocketlabel;
    struct socket *newsocket;
    struct label *newsocketpeerlabel;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| oldsocket            | Local socket         |                       |
+----------------------+----------------------+-----------------------+
| oldsocketlabel       | Policy label for     |                       |
|                      | oldsocket            |                       |
+----------------------+----------------------+-----------------------+
| newsocket            | Peer socket          |                       |
+----------------------+----------------------+-----------------------+
| newsocketpeerlabel   | Policy label to fill |                       |
|                      | in for newsocket     |                       |
+----------------------+----------------------+-----------------------+

Set the peer label on a stream UNIX domain socket from the passed remote
socket endpoint. This call will be made when the socket pair is
connected, and will be made for both endpoints.

6.7.3.3. Network Object Labeling Event Operations

6.7.3.3.1. mpo_create_bpfdesc

    void mpo_create_bpfdesc(    cred,
        bpf_d,
        bpflabel);
    struct ucred *cred;
    struct bpf_d *bpf_d;
    struct label *bpflabel;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   | Immutable             |
+----------------------+----------------------+-----------------------+
| bpf_d                | Object; bpf          |                       |
|                      | descriptor           |                       |
+----------------------+----------------------+-----------------------+
| bpf                  | Policy label to be   |                       |
|                      | filled in for bpf_d  |                       |
+----------------------+----------------------+-----------------------+

Set the label on a newly created BPF descriptor from the passed subject
credential. This call will be made when a BPF device node is opened by a
process with the passed subject credential.

6.7.3.3.2. mpo_create_ifnet

    void mpo_create_ifnet(  ifnet,
        ifnetlabel);
    struct ifnet *ifnet;
    struct label *ifnetlabel;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| ifnet                | Network interface    |                       |
+----------------------+----------------------+-----------------------+
| ifnetlabel           | Policy label to fill |                       |
|                      | in for ifnet         |                       |
+----------------------+----------------------+-----------------------+

Set the label on a newly created interface. This call may be made when a
new physical interface becomes available to the system, or when a
pseudo-interface is instantiated during the boot or as a result of a
user action.

6.7.3.3.3. mpo_create_ipq

    void mpo_create_ipq(  fragment,
        fragmentlabel,
        ipq,
        ipqlabel);
    struct mbuf *fragment;
    struct label *fragmentlabel;
    struct ipq *ipq;
    struct label *ipqlabel;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| fragment             | First received IP    |                       |
|                      | fragment             |                       |
+----------------------+----------------------+-----------------------+
| fragmentlabel        | Policy label for     |                       |
|                      | fragment             |                       |
+----------------------+----------------------+-----------------------+
| ipq                  | IP reassembly queue  |                       |
|                      | to be labeled        |                       |
+----------------------+----------------------+-----------------------+
| ipqlabel             | Policy label to be   |                       |
|                      | filled in for ipq    |                       |
+----------------------+----------------------+-----------------------+

Set the label on a newly created IP fragment reassembly queue from the
mbuf header of the first received fragment.

6.7.3.3.4. mpo_create_datagram_from_ipq

    void mpo_create_create_datagram_from_ipq( ipq,
        ipqlabel,
        datagram,
        datagramlabel);
    struct ipq *ipq;
    struct label *ipqlabel;
    struct mbuf *datagram;
    struct label *datagramlabel;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| ipq                  | IP reassembly queue  |                       |
+----------------------+----------------------+-----------------------+
| ipqlabel             | Policy label for ipq |                       |
+----------------------+----------------------+-----------------------+
| datagram             | Datagram to be       |                       |
|                      | labeled              |                       |
+----------------------+----------------------+-----------------------+
| datagramlabel        | Policy label to be   |                       |
|                      | filled in for        |                       |
|                      | datagramlabel        |                       |
+----------------------+----------------------+-----------------------+

Set the label on a newly reassembled IP datagram from the IP fragment
reassembly queue from which it was generated.

6.7.3.3.5. mpo_create_fragment

    void mpo_create_fragment(   datagram,
        datagramlabel,
        fragment,
        fragmentlabel);
    struct mbuf *datagram;
    struct label *datagramlabel;
    struct mbuf *fragment;
    struct label *fragmentlabel;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| datagram             | Datagram             |                       |
+----------------------+----------------------+-----------------------+
| datagramlabel        | Policy label for     |                       |
|                      | datagram             |                       |
+----------------------+----------------------+-----------------------+
| fragment             | Fragment to be       |                       |
|                      | labeled              |                       |
+----------------------+----------------------+-----------------------+
| fragmentlabel        | Policy label to be   |                       |
|                      | filled in for        |                       |
|                      | datagram             |                       |
+----------------------+----------------------+-----------------------+

Set the label on the mbuf header of a newly created IP fragment from the
label on the mbuf header of the datagram it was generate from.

6.7.3.3.6. mpo_create_mbuf_from_mbuf

    void mpo_create_mbuf_from_mbuf(    oldmbuf,
        oldmbuflabel,
        newmbuf,
        newmbuflabel);
    struct mbuf *oldmbuf;
    struct label *oldmbuflabel;
    struct mbuf *newmbuf;
    struct label *newmbuflabel;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| oldmbuf              | Existing (source)    |                       |
|                      | mbuf                 |                       |
+----------------------+----------------------+-----------------------+
| oldmbuflabel         | Policy label for     |                       |
|                      | oldmbuf              |                       |
+----------------------+----------------------+-----------------------+
| newmbuf              | New mbuf to be       |                       |
|                      | labeled              |                       |
+----------------------+----------------------+-----------------------+
| newmbuflabel         | Policy label to be   |                       |
|                      | filled in for        |                       |
|                      | newmbuf              |                       |
+----------------------+----------------------+-----------------------+

Set the label on the mbuf header of a newly created datagram from the
mbuf header of an existing datagram. This call may be made in a number
of situations, including when an mbuf is re-allocated for alignment
purposes.

6.7.3.3.7. mpo_create_mbuf_linklayer

    void mpo_create_mbuf_linklayer(   ifnet,
        ifnetlabel,
        mbuf,
        mbuflabel);
    struct ifnet *ifnet;
    struct label *ifnetlabel;
    struct mbuf *mbuf;
    struct label *mbuflabel;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| ifnet                | Network interface    |                       |
+----------------------+----------------------+-----------------------+
| ifnetlabel           | Policy label for     |                       |
|                      | ifnet                |                       |
+----------------------+----------------------+-----------------------+
| mbuf                 | mbuf header for new  |                       |
|                      | datagram             |                       |
+----------------------+----------------------+-----------------------+
| mbuflabel            | Policy label to be   |                       |
|                      | filled in for mbuf   |                       |
+----------------------+----------------------+-----------------------+

Set the label on the mbuf header of a newly created datagram generated
for the purposes of a link layer response for the passed interface. This
call may be made in a number of situations, including for ARP or ND6
responses in the IPv4 and IPv6 stacks.

6.7.3.3.8. mpo_create_mbuf_from_bpfdesc

    void mpo_create_mbuf_from_bpfdesc(  bpf_d,
        bpflabel,
        mbuf,
        mbuflabel);
    struct bpf_d *bpf_d;
    struct label *bpflabel;
    struct mbuf *mbuf;
    struct label *mbuflabel;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| bpf_d                | BPF descriptor       |                       |
+----------------------+----------------------+-----------------------+
| bpflabel             | Policy label for     |                       |
|                      | bpflabel             |                       |
+----------------------+----------------------+-----------------------+
| mbuf                 | New mbuf to be       |                       |
|                      | labeled              |                       |
+----------------------+----------------------+-----------------------+
| mbuflabel            | Policy label to fill |                       |
|                      | in for mbuf          |                       |
+----------------------+----------------------+-----------------------+

Set the label on the mbuf header of a newly created datagram generated
using the passed BPF descriptor. This call is made when a write is
performed to the BPF device associated with the passed BPF descriptor.

6.7.3.3.9. mpo_create_mbuf_from_ifnet

    void mpo_create_mbuf_from_ifnet(  ifnet,
        ifnetlabel,
        mbuf,
        mbuflabel);
    struct ifnet *ifnet;
    struct label *ifnetlabel;
    struct mbuf *mbuf;
    struct label *mbuflabel;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| ifnet                | Network interface    |                       |
+----------------------+----------------------+-----------------------+
| ifnetlabel           | Policy label for     |                       |
|                      | ifnetlabel           |                       |
+----------------------+----------------------+-----------------------+
| mbuf                 | mbuf header for new  |                       |
|                      | datagram             |                       |
+----------------------+----------------------+-----------------------+
| mbuflabel            | Policy label to be   |                       |
|                      | filled in for mbuf   |                       |
+----------------------+----------------------+-----------------------+

Set the label on the mbuf header of a newly created datagram generated
from the passed network interface.

6.7.3.3.10. mpo_create_mbuf_multicast_encap

    void mpo_create_mbuf_multicast_encap(  oldmbuf,
        oldmbuflabel,
        ifnet,
        ifnetlabel,
        newmbuf,
        newmbuflabel);
    struct mbuf *oldmbuf;
    struct label *oldmbuflabel;
    struct ifnet *ifnet;
    struct label *ifnetlabel;
    struct mbuf *newmbuf;
    struct label *newmbuflabel;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| oldmbuf              | mbuf header for      |                       |
|                      | existing datagram    |                       |
+----------------------+----------------------+-----------------------+
| oldmbuflabel         | Policy label for     |                       |
|                      | oldmbuf              |                       |
+----------------------+----------------------+-----------------------+
| ifnet                | Network interface    |                       |
+----------------------+----------------------+-----------------------+
| ifnetlabel           | Policy label for     |                       |
|                      | ifnet                |                       |
+----------------------+----------------------+-----------------------+
| newmbuf              | mbuf header to be    |                       |
|                      | labeled for new      |                       |
|                      | datagram             |                       |
+----------------------+----------------------+-----------------------+
| newmbuflabel         | Policy label to be   |                       |
|                      | filled in for        |                       |
|                      | newmbuf              |                       |
+----------------------+----------------------+-----------------------+

Set the label on the mbuf header of a newly created datagram generated
from the existing passed datagram when it is processed by the passed
multicast encapsulation interface. This call is made when an mbuf is to
be delivered using the virtual interface.

6.7.3.3.11. mpo_create_mbuf_netlayer

    void mpo_create_mbuf_netlayer(   oldmbuf,
        oldmbuflabel,
        newmbuf,
        newmbuflabel);
    struct mbuf *oldmbuf;
    struct label *oldmbuflabel;
    struct mbuf *newmbuf;
    struct label *newmbuflabel;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| oldmbuf              | Received datagram    |                       |
+----------------------+----------------------+-----------------------+
| oldmbuflabel         | Policy label for     |                       |
|                      | oldmbuf              |                       |
+----------------------+----------------------+-----------------------+
| newmbuf              | Newly created        |                       |
|                      | datagram             |                       |
+----------------------+----------------------+-----------------------+
| newmbuflabel         | Policy label for     |                       |
|                      | newmbuf              |                       |
+----------------------+----------------------+-----------------------+

Set the label on the mbuf header of a newly created datagram generated
by the IP stack in response to an existing received datagram (oldmbuf).
This call may be made in a number of situations, including when
responding to ICMP request datagrams.

6.7.3.3.12. mpo_fragment_match

    int mpo_fragment_match( fragment,
        fragmentlabel,
        ipq,
        ipqlabel);
    struct mbuf *fragment;
    struct label *fragmentlabel;
    struct ipq *ipq;
    struct label *ipqlabel;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| fragment             | IP datagram fragment |                       |
+----------------------+----------------------+-----------------------+
| fragmentlabel        | Policy label for     |                       |
|                      | fragment             |                       |
+----------------------+----------------------+-----------------------+
| ipq                  | IP fragment          |                       |
|                      | reassembly queue     |                       |
+----------------------+----------------------+-----------------------+
| ipqlabel             | Policy label for ipq |                       |
+----------------------+----------------------+-----------------------+

Determine whether an mbuf header containing an IP datagram (fragment)
fragment matches the label of the passed IP fragment reassembly queue
(ipq). Return (1) for a successful match, or (0) for no match. This call
is made when the IP stack attempts to find an existing fragment
reassembly queue for a newly received fragment; if this fails, a new
fragment reassembly queue may be instantiated for the fragment. Policies
may use this entry point to prevent the reassembly of otherwise matching
IP fragments if policy does not permit them to be reassembled based on
the label or other information.

6.7.3.3.13. mpo_relabel_ifnet

    void mpo_relabel_ifnet( cred,
        ifnet,
        ifnetlabel,
        newlabel);
    struct ucred *cred;
    struct ifnet *ifnet;
    struct label *ifnetlabel;
    struct label *newlabel;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| ifnet                | Object; Network      |                       |
|                      | interface            |                       |
+----------------------+----------------------+-----------------------+
| ifnetlabel           | Policy label for     |                       |
|                      | ifnet                |                       |
+----------------------+----------------------+-----------------------+
| newlabel             | Label update to      |                       |
|                      | apply to ifnet       |                       |
+----------------------+----------------------+-----------------------+

Update the label of network interface, ifnet, based on the passed update
label, newlabel, and the passed subject credential, cred.

6.7.3.3.14. mpo_update_ipq

    void mpo_update_ipq(  fragment,
        fragmentlabel,
        ipq,
        ipqlabel);
    struct mbuf *fragment;
    struct label *fragmentlabel;
    struct ipq *ipq;
    struct label *ipqlabel;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| mbuf                 | IP fragment          |                       |
+----------------------+----------------------+-----------------------+
| mbuflabel            | Policy label for     |                       |
|                      | mbuf                 |                       |
+----------------------+----------------------+-----------------------+
| ipq                  | IP fragment          |                       |
|                      | reassembly queue     |                       |
+----------------------+----------------------+-----------------------+
| ipqlabel             | Policy label to be   |                       |
|                      | updated for ipq      |                       |
+----------------------+----------------------+-----------------------+

Update the label on an IP fragment reassembly queue (ipq) based on the
acceptance of the passed IP fragment mbuf header (mbuf).

6.7.3.4. Process Labeling Event Operations

6.7.3.4.1. mpo_create_cred

    void mpo_create_cred(    parent_cred,
        child_cred);
    struct ucred *parent_cred;
    struct ucred *child_cred;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| parent_cred          | Parent subject       |                       |
|                      | credential           |                       |
+----------------------+----------------------+-----------------------+
| child_cred           | Child subject        |                       |
|                      | credential           |                       |
+----------------------+----------------------+-----------------------+

Set the label of a newly created subject credential from the passed
subject credential. This call will be made when crcopy(9) is invoked on
a newly created struct ucred. This call should not be confused with a
process forking or creation event.

6.7.3.4.2. mpo_execve_transition

    void mpo_execve_transition(    old,
        new,
        vp,
        vnodelabel);
    struct ucred *old;
    struct ucred *new;
    struct vnode *vp;
    struct label *vnodelabel;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| old                  | Existing subject     | Immutable             |
|                      | credential           |                       |
+----------------------+----------------------+-----------------------+
| new                  | New subject          |                       |
|                      | credential to be     |                       |
|                      | labeled              |                       |
+----------------------+----------------------+-----------------------+
| vp                   | File to execute      | Locked                |
+----------------------+----------------------+-----------------------+
| vnodelabel           | Policy label for vp  |                       |
+----------------------+----------------------+-----------------------+

Update the label of a newly created subject credential (new) from the
passed existing subject credential (old) based on a label transition
caused by executing the passed vnode (vp). This call occurs when a
process executes the passed vnode and one of the policies returns a
success from the mpo_execve_will_transition entry point. Policies may
choose to implement this call simply by invoking mpo_create_cred and
passing the two subject credentials so as not to implement a
transitioning event. Policies should not leave this entry point
unimplemented if they implement mpo_create_cred, even if they do not
implement mpo_execve_will_transition.

6.7.3.4.3. mpo_execve_will_transition

    int mpo_execve_will_transition(    old,
        vp,
        vnodelabel);
    struct ucred *old;
    struct vnode *vp;
    struct label *vnodelabel;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| old                  | Subject credential   | Immutable             |
|                      | prior to execve(2)   |                       |
+----------------------+----------------------+-----------------------+
| vp                   | File to execute      |                       |
+----------------------+----------------------+-----------------------+
| vnodelabel           | Policy label for vp  |                       |
+----------------------+----------------------+-----------------------+

Determine whether the policy will want to perform a transition event as
a result of the execution of the passed vnode by the passed subject
credential. Return 1 if a transition is required, 0 if not. Even if a
policy returns 0, it should behave correctly in the presence of an
unexpected invocation of mpo_execve_transition, as that call may happen
as a result of another policy requesting a transition.

6.7.3.4.4. mpo_create_proc0

    void mpo_create_proc0(  cred);
    struct ucred *cred;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
|                      | to be filled in      |                       |
+----------------------+----------------------+-----------------------+

Create the subject credential of process 0, the parent of all kernel
processes.

6.7.3.4.5. mpo_create_proc1

    void mpo_create_proc1(    cred);
    struct ucred *cred;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
|                      | to be filled in      |                       |
+----------------------+----------------------+-----------------------+

Create the subject credential of process 1, the parent of all user
processes.

6.7.3.4.6. mpo_relabel_cred

    void mpo_relabel_cred(  cred,
        newlabel);
    struct ucred *cred;
    struct label *newlabel;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| newlabel             | Label update to      |                       |
|                      | apply to cred        |                       |
+----------------------+----------------------+-----------------------+

Update the label on a subject credential from the passed update label.

6.7.4. Access Control Checks

Access control entry points permit policy modules to influence access
control decisions made by the kernel. Generally, although not always,
arguments to an access control entry point will include one or more
authorizing credentials, information (possibly including a label) for
any other objects involved in the operation. An access control entry
point may return 0 to permit the operation, or an errno(2) error value.
The results of invoking the entry point across various registered policy
modules will be composed as follows: if all modules permit the operation
to succeed, success will be returned. If one or modules returns a
failure, a failure will be returned. If more than one module returns a
failure, the errno value to return to the user will be selected using
the following precedence, implemented by the error_select() function in
kern_mac.c:

+-----------------------------------+-----------------------------------+
| Most precedence                   | EDEADLK                           |
+-----------------------------------+-----------------------------------+
|                                   | EINVAL                            |
+-----------------------------------+-----------------------------------+
|                                   | ESRCH                             |
+-----------------------------------+-----------------------------------+
|                                   | EACCES                            |
+-----------------------------------+-----------------------------------+
| Least precedence                  | EPERM                             |
+-----------------------------------+-----------------------------------+

If none of the error values returned by all modules are listed in the
precedence chart then an arbitrarily selected value from the set will be
returned. In general, the rules provide precedence to errors in the
following order: kernel failures, invalid arguments, object not present,
access not permitted, other.

6.7.4.1. mpo_check_bpfdesc_receive

    int mpo_check_bpfdesc_receive(  bpf_d,
        bpflabel,
        ifnet,
        ifnetlabel);
    struct bpf_d *bpf_d;
    struct label *bpflabel;
    struct ifnet *ifnet;
    struct label *ifnetlabel;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| bpf_d                | Subject; BPF         |                       |
|                      | descriptor           |                       |
+----------------------+----------------------+-----------------------+
| bpflabel             | Policy label for     |                       |
|                      | bpf_d                |                       |
+----------------------+----------------------+-----------------------+
| ifnet                | Object; network      |                       |
|                      | interface            |                       |
+----------------------+----------------------+-----------------------+
| ifnetlabel           | Policy label for     |                       |
|                      | ifnet                |                       |
+----------------------+----------------------+-----------------------+

Determine whether the MAC framework should permit datagrams from the
passed interface to be delivered to the buffers of the passed BPF
descriptor. Return (0) for success, or an errno value for failure
Suggested failure: EACCES for label mismatches, EPERM for lack of
privilege.

6.7.4.2. mpo_check_kenv_dump

    int mpo_check_kenv_dump(  cred);
    struct ucred *cred;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+

Determine whether the subject should be allowed to retrieve the kernel
environment (see kenv(2)).

6.7.4.3. mpo_check_kenv_get

    int mpo_check_kenv_get(  cred,
        name);
    struct ucred *cred;
    char *name;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| name                 | Kernel environment   |                       |
|                      | variable name        |                       |
+----------------------+----------------------+-----------------------+

Determine whether the subject should be allowed to retrieve the value of
the specified kernel environment variable.

6.7.4.4. mpo_check_kenv_set

    int mpo_check_kenv_set(    cred,
        name);
    struct ucred *cred;
    char *name;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| name                 | Kernel environment   |                       |
|                      | variable name        |                       |
+----------------------+----------------------+-----------------------+

Determine whether the subject should be allowed to set the specified
kernel environment variable.

6.7.4.5. mpo_check_kenv_unset

    int mpo_check_kenv_unset(  cred,
        name);
    struct ucred *cred;
    char *name;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| name                 | Kernel environment   |                       |
|                      | variable name        |                       |
+----------------------+----------------------+-----------------------+

Determine whether the subject should be allowed to unset the specified
kernel environment variable.

6.7.4.6. mpo_check_kld_load

    int mpo_check_kld_load(    cred,
        vp,
        vlabel);
    struct ucred *cred;
    struct vnode *vp;
    struct label *vlabel;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| vp                   | Kernel module vnode  |                       |
+----------------------+----------------------+-----------------------+
| vlabel               | Label associated     |                       |
|                      | with vp              |                       |
+----------------------+----------------------+-----------------------+

Determine whether the subject should be allowed to load the specified
module file.

6.7.4.7. mpo_check_kld_stat

    int mpo_check_kld_stat(    cred);
    struct ucred *cred;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+

Determine whether the subject should be allowed to retrieve a list of
loaded kernel module files and associated statistics.

6.7.4.8. mpo_check_kld_unload

    int mpo_check_kld_unload(   cred);
    struct ucred *cred;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+

Determine whether the subject should be allowed to unload a kernel
module.

6.7.4.9. mpo_check_pipe_ioctl

    int mpo_check_pipe_ioctl(    cred,
        pipe,
        pipelabel,
        cmd,
        data);
    struct ucred *cred;
    struct pipe *pipe;
    struct label *pipelabel;
    unsigned long cmd;
    void *data;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| pipe                 | Pipe                 |                       |
+----------------------+----------------------+-----------------------+
| pipelabel            | Policy label         |                       |
|                      | associated with pipe |                       |
+----------------------+----------------------+-----------------------+
| cmd                  | ioctl(2) command     |                       |
+----------------------+----------------------+-----------------------+
| data                 | ioctl(2) data        |                       |
+----------------------+----------------------+-----------------------+

Determine whether the subject should be allowed to make the specified
ioctl(2) call.

6.7.4.10. mpo_check_pipe_poll

    int mpo_check_pipe_poll(  cred,
        pipe,
        pipelabel);
    struct ucred *cred;
    struct pipe *pipe;
    struct label *pipelabel;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| pipe                 | Pipe                 |                       |
+----------------------+----------------------+-----------------------+
| pipelabel            | Policy label         |                       |
|                      | associated with pipe |                       |
+----------------------+----------------------+-----------------------+

Determine whether the subject should be allowed to poll pipe.

6.7.4.11. mpo_check_pipe_read

    int mpo_check_pipe_read( cred,
        pipe,
        pipelabel);
    struct ucred *cred;
    struct pipe *pipe;
    struct label *pipelabel;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| pipe                 | Pipe                 |                       |
+----------------------+----------------------+-----------------------+
| pipelabel            | Policy label         |                       |
|                      | associated with pipe |                       |
+----------------------+----------------------+-----------------------+

Determine whether the subject should be allowed read access to pipe.

6.7.4.12. mpo_check_pipe_relabel

    int mpo_check_pipe_relabel(  cred,
        pipe,
        pipelabel,
        newlabel);
    struct ucred *cred;
    struct pipe *pipe;
    struct label *pipelabel;
    struct label *newlabel;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| pipe                 | Pipe                 |                       |
+----------------------+----------------------+-----------------------+
| pipelabel            | Current policy label |                       |
|                      | associated with pipe |                       |
+----------------------+----------------------+-----------------------+
| newlabel             | Label update to      |                       |
|                      | pipelabel            |                       |
+----------------------+----------------------+-----------------------+

Determine whether the subject should be allowed to relabel pipe.

6.7.4.13. mpo_check_pipe_stat

    int mpo_check_pipe_stat(  cred,
        pipe,
        pipelabel);
    struct ucred *cred;
    struct pipe *pipe;
    struct label *pipelabel;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| pipe                 | Pipe                 |                       |
+----------------------+----------------------+-----------------------+
| pipelabel            | Policy label         |                       |
|                      | associated with pipe |                       |
+----------------------+----------------------+-----------------------+

Determine whether the subject should be allowed to retrieve statistics
related to pipe.

6.7.4.14. mpo_check_pipe_write

    int mpo_check_pipe_write(   cred,
        pipe,
        pipelabel);
    struct ucred *cred;
    struct pipe *pipe;
    struct label *pipelabel;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| pipe                 | Pipe                 |                       |
+----------------------+----------------------+-----------------------+
| pipelabel            | Policy label         |                       |
|                      | associated with pipe |                       |
+----------------------+----------------------+-----------------------+

Determine whether the subject should be allowed to write to pipe.

6.7.4.15. mpo_check_socket_bind

    int mpo_check_socket_bind(   cred,
        socket,
        socketlabel,
        sockaddr);
    struct ucred *cred;
    struct socket *socket;
    struct label *socketlabel;
    struct sockaddr *sockaddr;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| socket               | Socket to be bound   |                       |
+----------------------+----------------------+-----------------------+
| socketlabel          | Policy label for     |                       |
|                      | socket               |                       |
+----------------------+----------------------+-----------------------+
| sockaddr             | Address of socket    |                       |
+----------------------+----------------------+-----------------------+

6.7.4.16. mpo_check_socket_connect

    int mpo_check_socket_connect(    cred,
        socket,
        socketlabel,
        sockaddr);
    struct ucred *cred;
    struct socket *socket;
    struct label *socketlabel;
    struct sockaddr *sockaddr;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| socket               | Socket to be         |                       |
|                      | connected            |                       |
+----------------------+----------------------+-----------------------+
| socketlabel          | Policy label for     |                       |
|                      | socket               |                       |
+----------------------+----------------------+-----------------------+
| sockaddr             | Address of socket    |                       |
+----------------------+----------------------+-----------------------+

Determine whether the subject credential (cred) can connect the passed
socket (socket) to the passed socket address (sockaddr). Return 0 for
success, or an errno value for failure. Suggested failure: EACCES for
label mismatches, EPERM for lack of privilege.

6.7.4.17. mpo_check_socket_receive

    int mpo_check_socket_receive(    cred,
        so,
        socketlabel);
    struct ucred *cred;
    struct socket *so;
    struct label *socketlabel;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| so                   | Socket               |                       |
+----------------------+----------------------+-----------------------+
| socketlabel          | Policy label         |                       |
|                      | associated with so   |                       |
+----------------------+----------------------+-----------------------+

Determine whether the subject should be allowed to receive information
from the socket so.

6.7.4.18. mpo_check_socket_send

    int mpo_check_socket_send(  cred,
        so,
        socketlabel);
    struct ucred *cred;
    struct socket *so;
    struct label *socketlabel;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| so                   | Socket               |                       |
+----------------------+----------------------+-----------------------+
| socketlabel          | Policy label         |                       |
|                      | associated with so   |                       |
+----------------------+----------------------+-----------------------+

Determine whether the subject should be allowed to send information
across the socket so.

6.7.4.19. mpo_check_cred_visible

    int mpo_check_cred_visible(   u1,
        u2);
    struct ucred *u1;
    struct ucred *u2;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| u1                   | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| u2                   | Object credential    |                       |
+----------------------+----------------------+-----------------------+

Determine whether the subject credential u1 can "see" other subjects
with the passed subject credential u2. Return 0 for success, or an errno
value for failure. Suggested failure: EACCES for label mismatches, EPERM
for lack of privilege, or ESRCH to hide visibility. This call may be
made in a number of situations, including inter-process status sysctl’s
used by ps, and in procfs lookups.

6.7.4.20. mpo_check_socket_visible

    int mpo_check_socket_visible(  cred,
        socket,
        socketlabel);
    struct ucred *cred;
    struct socket *socket;
    struct label *socketlabel;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| socket               | Object; socket       |                       |
+----------------------+----------------------+-----------------------+
| socketlabel          | Policy label for     |                       |
|                      | socket               |                       |
+----------------------+----------------------+-----------------------+

6.7.4.21. mpo_check_ifnet_relabel

    int mpo_check_ifnet_relabel( cred,
        ifnet,
        ifnetlabel,
        newlabel);
    struct ucred *cred;
    struct ifnet *ifnet;
    struct label *ifnetlabel;
    struct label *newlabel;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| ifnet                | Object; network      |                       |
|                      | interface            |                       |
+----------------------+----------------------+-----------------------+
| ifnetlabel           | Existing policy      |                       |
|                      | label for ifnet      |                       |
+----------------------+----------------------+-----------------------+
| newlabel             | Policy label update  |                       |
|                      | to later be applied  |                       |
|                      | to ifnet             |                       |
+----------------------+----------------------+-----------------------+

Determine whether the subject credential can relabel the passed network
interface to the passed label update.

6.7.4.22. mpo_check_socket_relabel

    int mpo_check_socket_relabel(    cred,
        socket,
        socketlabel,
        newlabel);
    struct ucred *cred;
    struct socket *socket;
    struct label *socketlabel;
    struct label *newlabel;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| socket               | Object; socket       |                       |
+----------------------+----------------------+-----------------------+
| socketlabel          | Existing policy      |                       |
|                      | label for socket     |                       |
+----------------------+----------------------+-----------------------+
| newlabel             | Label update to      |                       |
|                      | later be applied to  |                       |
|                      | socketlabel          |                       |
+----------------------+----------------------+-----------------------+

Determine whether the subject credential can relabel the passed socket
to the passed label update.

6.7.4.23. mpo_check_cred_relabel

    int mpo_check_cred_relabel(    cred,
        newlabel);
    struct ucred *cred;
    struct label *newlabel;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| newlabel             | Label update to      |                       |
|                      | later be applied to  |                       |
|                      | cred                 |                       |
+----------------------+----------------------+-----------------------+

Determine whether the subject credential can relabel itself to the
passed label update.

6.7.4.24. mpo_check_vnode_relabel

    int mpo_check_vnode_relabel(    cred,
        vp,
        vnodelabel,
        newlabel);
    struct ucred *cred;
    struct vnode *vp;
    struct label *vnodelabel;
    struct label *newlabel;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   | Immutable             |
+----------------------+----------------------+-----------------------+
| vp                   | Object; vnode        | Locked                |
+----------------------+----------------------+-----------------------+
| vnodelabel           | Existing policy      |                       |
|                      | label for vp         |                       |
+----------------------+----------------------+-----------------------+
| newlabel             | Policy label update  |                       |
|                      | to later be applied  |                       |
|                      | to vp                |                       |
+----------------------+----------------------+-----------------------+

Determine whether the subject credential can relabel the passed vnode to
the passed label update.

6.7.4.25. mpo_check_mount_stat

    int mpo_check_mount_stat(  cred,
        mp,
        mountlabel);
    struct ucred *cred;
    struct mount *mp;
    struct label *mountlabel;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| mp                   | Object; file system  |                       |
|                      | mount                |                       |
+----------------------+----------------------+-----------------------+
| mountlabel           | Policy label for mp  |                       |
+----------------------+----------------------+-----------------------+

Determine whether the subject credential can see the results of a statfs
performed on the file system. Return 0 for success, or an errno value
for failure. Suggested failure: EACCES for label mismatches or EPERM for
lack of privilege. This call may be made in a number of situations,
including during invocations of statfs(2) and related calls, as well as
to determine what file systems to exclude from listings of file systems,
such as when getfsstat(2) is invoked.

6.7.4.26. mpo_check_proc_debug

    int mpo_check_proc_debug(  cred,
        proc);
    struct ucred *cred;
    struct proc *proc;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   | Immutable             |
+----------------------+----------------------+-----------------------+
| proc                 | Object; process      |                       |
+----------------------+----------------------+-----------------------+

Determine whether the subject credential can debug the passed process.
Return 0 for success, or an errno value for failure. Suggested failure:
EACCES for label mismatch, EPERM for lack of privilege, or ESRCH to hide
visibility of the target. This call may be made in a number of
situations, including use of the ptrace(2) and ktrace(2) APIs, as well
as for some types of procfs operations.

6.7.4.27. mpo_check_vnode_access

    int mpo_check_vnode_access( cred,
        vp,
        label,
        flags);
    struct ucred *cred;
    struct vnode *vp;
    struct label *label;
    int flags;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| vp                   | Object; vnode        |                       |
+----------------------+----------------------+-----------------------+
| label                | Policy label for vp  |                       |
+----------------------+----------------------+-----------------------+
| flags                | access(2) flags      |                       |
+----------------------+----------------------+-----------------------+

Determine how invocations of access(2) and related calls by the subject
credential should return when performed on the passed vnode using the
passed access flags. This should generally be implemented using the same
semantics used in mpo_check_vnode_open. Return 0 for success, or an
errno value for failure. Suggested failure: EACCES for label mismatches
or EPERM for lack of privilege.

6.7.4.28. mpo_check_vnode_chdir

    int mpo_check_vnode_chdir(    cred,
        dvp,
        dlabel);
    struct ucred *cred;
    struct vnode *dvp;
    struct label *dlabel;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| dvp                  | Object; vnode to     |                       |
|                      | chdir(2) into        |                       |
+----------------------+----------------------+-----------------------+
| dlabel               | Policy label for dvp |                       |
+----------------------+----------------------+-----------------------+

Determine whether the subject credential can change the process working
directory to the passed vnode. Return 0 for success, or an errno value
for failure. Suggested failure: EACCES for label mismatch, or EPERM for
lack of privilege.

6.7.4.29. mpo_check_vnode_chroot

    int mpo_check_vnode_chroot(   cred,
        dvp,
        dlabel);
    struct ucred *cred;
    struct vnode *dvp;
    struct label *dlabel;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| dvp                  | Directory vnode      |                       |
+----------------------+----------------------+-----------------------+
| dlabel               | Policy label         |                       |
|                      | associated with dvp  |                       |
+----------------------+----------------------+-----------------------+

Determine whether the subject should be allowed to chroot(2) into the
specified directory (dvp).

6.7.4.30. mpo_check_vnode_create

    int mpo_check_vnode_create(    cred,
        dvp,
        dlabel,
        cnp,
        vap);
    struct ucred *cred;
    struct vnode *dvp;
    struct label *dlabel;
    struct componentname *cnp;
    struct vattr *vap;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| dvp                  | Object; vnode        |                       |
+----------------------+----------------------+-----------------------+
| dlabel               | Policy label for dvp |                       |
+----------------------+----------------------+-----------------------+
| cnp                  | Component name for   |                       |
|                      | dvp                  |                       |
+----------------------+----------------------+-----------------------+
| vap                  | vnode attributes for |                       |
|                      | vap                  |                       |
+----------------------+----------------------+-----------------------+

Determine whether the subject credential can create a vnode with the
passed parent directory, passed name information, and passed attribute
information. Return 0 for success, or an errno value for failure.
Suggested failure: EACCES for label mismatch, or EPERM for lack of
privilege. This call may be made in a number of situations, including as
a result of calls to open(2) with O_CREAT, mkfifo(2), and others.

6.7.4.31. mpo_check_vnode_delete

    int mpo_check_vnode_delete(   cred,
        dvp,
        dlabel,
        vp,
        label,
        cnp);
    struct ucred *cred;
    struct vnode *dvp;
    struct label *dlabel;
    struct vnode *vp;
    void *label;
    struct componentname *cnp;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| dvp                  | Parent directory     |                       |
|                      | vnode                |                       |
+----------------------+----------------------+-----------------------+
| dlabel               | Policy label for dvp |                       |
+----------------------+----------------------+-----------------------+
| vp                   | Object; vnode to     |                       |
|                      | delete               |                       |
+----------------------+----------------------+-----------------------+
| label                | Policy label for vp  |                       |
+----------------------+----------------------+-----------------------+
| cnp                  | Component name for   |                       |
|                      | vp                   |                       |
+----------------------+----------------------+-----------------------+

Determine whether the subject credential can delete a vnode from the
passed parent directory and passed name information. Return 0 for
success, or an errno value for failure. Suggested failure: EACCES for
label mismatch, or EPERM for lack of privilege. This call may be made in
a number of situations, including as a result of calls to unlink(2) and
rmdir(2). Policies implementing this entry point should also implement
mpo_check_rename_to to authorize deletion of objects as a result of
being the target of a rename.

6.7.4.32. mpo_check_vnode_deleteacl

    int mpo_check_vnode_deleteacl(   cred,
        vp,
        label,
        type);
    struct ucred *cred;
    struct vnode *vp;
    struct label *label;
    acl_type_t type;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   | Immutable             |
+----------------------+----------------------+-----------------------+
| vp                   | Object; vnode        | Locked                |
+----------------------+----------------------+-----------------------+
| label                | Policy label for vp  |                       |
+----------------------+----------------------+-----------------------+
| type                 | ACL type             |                       |
+----------------------+----------------------+-----------------------+

Determine whether the subject credential can delete the ACL of passed
type from the passed vnode. Return 0 for success, or an errno value for
failure. Suggested failure: EACCES for label mismatch, or EPERM for lack
of privilege.

6.7.4.33. mpo_check_vnode_exec

    int mpo_check_vnode_exec( cred,
        vp,
        label);
    struct ucred *cred;
    struct vnode *vp;
    struct label *label;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| vp                   | Object; vnode to     |                       |
|                      | execute              |                       |
+----------------------+----------------------+-----------------------+
| label                | Policy label for vp  |                       |
+----------------------+----------------------+-----------------------+

Determine whether the subject credential can execute the passed vnode.
Determination of execute privilege is made separately from decisions
about any transitioning event. Return 0 for success, or an errno value
for failure. Suggested failure: EACCES for label mismatch, or EPERM for
lack of privilege.

6.7.4.34. mpo_check_vnode_getacl

    int mpo_check_vnode_getacl( cred,
        vp,
        label,
        type);
    struct ucred *cred;
    struct vnode *vp;
    struct label *label;
    acl_type_t type;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| vp                   | Object; vnode        |                       |
+----------------------+----------------------+-----------------------+
| label                | Policy label for vp  |                       |
+----------------------+----------------------+-----------------------+
| type                 | ACL type             |                       |
+----------------------+----------------------+-----------------------+

Determine whether the subject credential can retrieve the ACL of passed
type from the passed vnode. Return 0 for success, or an errno value for
failure. Suggested failure: EACCES for label mismatch, or EPERM for lack
of privilege.

6.7.4.35. mpo_check_vnode_getextattr

    int mpo_check_vnode_getextattr( cred,
        vp,
        label,
        attrnamespace,
        name,
        uio);
    struct ucred *cred;
    struct vnode *vp;
    struct label *label;
    int attrnamespace;
    const char *name;
    struct uio *uio;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| vp                   | Object; vnode        |                       |
+----------------------+----------------------+-----------------------+
| label                | Policy label for vp  |                       |
+----------------------+----------------------+-----------------------+
| attrnamespace        | Extended attribute   |                       |
|                      | namespace            |                       |
+----------------------+----------------------+-----------------------+
| name                 | Extended attribute   |                       |
|                      | name                 |                       |
+----------------------+----------------------+-----------------------+
| uio                  | I/O structure        |                       |
|                      | pointer; see uio(9)  |                       |
+----------------------+----------------------+-----------------------+

Determine whether the subject credential can retrieve the extended
attribute with the passed namespace and name from the passed vnode.
Policies implementing labeling using extended attributes may be
interested in special handling of operations on those extended
attributes. Return 0 for success, or an errno value for failure.
Suggested failure: EACCES for label mismatch, or EPERM for lack of
privilege.

6.7.4.36. mpo_check_vnode_link

    int mpo_check_vnode_link(   cred,
        dvp,
        dlabel,
        vp,
        label,
        cnp);
    struct ucred *cred;
    struct vnode *dvp;
    struct label *dlabel;
    struct vnode *vp;
    struct label *label;
    struct componentname *cnp;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| dvp                  | Directory vnode      |                       |
+----------------------+----------------------+-----------------------+
| dlabel               | Policy label         |                       |
|                      | associated with dvp  |                       |
+----------------------+----------------------+-----------------------+
| vp                   | Link destination     |                       |
|                      | vnode                |                       |
+----------------------+----------------------+-----------------------+
| label                | Policy label         |                       |
|                      | associated with vp   |                       |
+----------------------+----------------------+-----------------------+
| cnp                  | Component name for   |                       |
|                      | the link being       |                       |
|                      | created              |                       |
+----------------------+----------------------+-----------------------+

Determine whether the subject should be allowed to create a link to the
vnode vp with the name specified by cnp.

6.7.4.37. mpo_check_vnode_mmap

    int mpo_check_vnode_mmap(   cred,
        vp,
        label,
        prot);
    struct ucred *cred;
    struct vnode *vp;
    struct label *label;
    int prot;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| vp                   | Vnode to map         |                       |
+----------------------+----------------------+-----------------------+
| label                | Policy label         |                       |
|                      | associated with vp   |                       |
+----------------------+----------------------+-----------------------+
| prot                 | Mmap protections     |                       |
|                      | (see mmap(2))        |                       |
+----------------------+----------------------+-----------------------+

Determine whether the subject should be allowed to map the vnode vp with
the protections specified in prot.

6.7.4.38. mpo_check_vnode_mmap_downgrade

    void mpo_check_vnode_mmap_downgrade( cred,
        vp,
        label,
        prot);
    struct ucred *cred;
    struct vnode *vp;
    struct label *label;
    int *prot;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | See                  |                       |
|                      | m                    |                       |
|                      | po_check_vnode_mmap. |                       |
+----------------------+----------------------+-----------------------+
| vp                   |                      |                       |
+----------------------+----------------------+-----------------------+
| label                |                      |                       |
+----------------------+----------------------+-----------------------+
| prot                 | Mmap protections to  |                       |
|                      | be downgraded        |                       |
+----------------------+----------------------+-----------------------+

Downgrade the mmap protections based on the subject and object labels.

6.7.4.39. mpo_check_vnode_mprotect

    int mpo_check_vnode_mprotect( cred,
        vp,
        label,
        prot);
    struct ucred *cred;
    struct vnode *vp;
    struct label *label;
    int prot;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| vp                   | Mapped vnode         |                       |
+----------------------+----------------------+-----------------------+
| prot                 | Memory protections   |                       |
+----------------------+----------------------+-----------------------+

Determine whether the subject should be allowed to set the specified
memory protections on memory mapped from the vnode vp.

6.7.4.40. mpo_check_vnode_poll

    int mpo_check_vnode_poll(  active_cred,
        file_cred,
        vp,
        label);
    struct ucred *active_cred;
    struct ucred *file_cred;
    struct vnode *vp;
    struct label *label;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| active_cred          | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| file_cred            | Credential           |                       |
|                      | associated with the  |                       |
|                      | struct file          |                       |
+----------------------+----------------------+-----------------------+
| vp                   | Polled vnode         |                       |
+----------------------+----------------------+-----------------------+
| label                | Policy label         |                       |
|                      | associated with vp   |                       |
+----------------------+----------------------+-----------------------+

Determine whether the subject should be allowed to poll the vnode vp.

6.7.4.41. mpo_check_vnode_rename_from

    int mpo_vnode_rename_from(  cred,
        dvp,
        dlabel,
        vp,
        label,
        cnp);
    struct ucred *cred;
    struct vnode *dvp;
    struct label *dlabel;
    struct vnode *vp;
    struct label *label;
    struct componentname *cnp;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| dvp                  | Directory vnode      |                       |
+----------------------+----------------------+-----------------------+
| dlabel               | Policy label         |                       |
|                      | associated with dvp  |                       |
+----------------------+----------------------+-----------------------+
| vp                   | Vnode to be renamed  |                       |
+----------------------+----------------------+-----------------------+
| label                | Policy label         |                       |
|                      | associated with vp   |                       |
+----------------------+----------------------+-----------------------+
| cnp                  | Component name for   |                       |
|                      | vp                   |                       |
+----------------------+----------------------+-----------------------+

Determine whether the subject should be allowed to rename the vnode vp
to something else.

6.7.4.42. mpo_check_vnode_rename_to

    int mpo_check_vnode_rename_to( cred,
        dvp,
        dlabel,
        vp,
        label,
        samedir,
        cnp);
    struct ucred *cred;
    struct vnode *dvp;
    struct label *dlabel;
    struct vnode *vp;
    struct label *label;
    int samedir;
    struct componentname *cnp;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| dvp                  | Directory vnode      |                       |
+----------------------+----------------------+-----------------------+
| dlabel               | Policy label         |                       |
|                      | associated with dvp  |                       |
+----------------------+----------------------+-----------------------+
| vp                   | Overwritten vnode    |                       |
+----------------------+----------------------+-----------------------+
| label                | Policy label         |                       |
|                      | associated with vp   |                       |
+----------------------+----------------------+-----------------------+
| samedir              | Boolean; 1 if the    |                       |
|                      | source and           |                       |
|                      | destination          |                       |
|                      | directories are the  |                       |
|                      | same                 |                       |
+----------------------+----------------------+-----------------------+
| cnp                  | Destination          |                       |
|                      | component name       |                       |
+----------------------+----------------------+-----------------------+

Determine whether the subject should be allowed to rename to the vnode
vp, into the directory dvp, or to the name represented by cnp. If there
is no existing file to overwrite, vp and label will be NULL.

6.7.4.43. mpo_check_socket_listen

    int mpo_check_socket_listen(   cred,
        socket,
        socketlabel);
    struct ucred *cred;
    struct socket *socket;
    struct label *socketlabel;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| socket               | Object; socket       |                       |
+----------------------+----------------------+-----------------------+
| socketlabel          | Policy label for     |                       |
|                      | socket               |                       |
+----------------------+----------------------+-----------------------+

Determine whether the subject credential can listen on the passed
socket. Return 0 for success, or an errno value for failure. Suggested
failure: EACCES for label mismatch, or EPERM for lack of privilege.

6.7.4.44. mpo_check_vnode_lookup

    int mpo_check_vnode_lookup( ,
        ,
        ,
        cnp);
    struct ucred *cred;
    struct vnode *dvp;
    struct label *dlabel;
    struct componentname *cnp;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| dvp                  | Object; vnode        |                       |
+----------------------+----------------------+-----------------------+
| dlabel               | Policy label for dvp |                       |
+----------------------+----------------------+-----------------------+
| cnp                  | Component name being |                       |
|                      | looked up            |                       |
+----------------------+----------------------+-----------------------+

Determine whether the subject credential can perform a lookup in the
passed directory vnode for the passed name. Return 0 for success, or an
errno value for failure. Suggested failure: EACCES for label mismatch,
or EPERM for lack of privilege.

6.7.4.45. mpo_check_vnode_open

    int mpo_check_vnode_open( cred,
        vp,
        label,
        acc_mode);
    struct ucred *cred;
    struct vnode *vp;
    struct label *label;
    int acc_mode;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| vp                   | Object; vnode        |                       |
+----------------------+----------------------+-----------------------+
| label                | Policy label for vp  |                       |
+----------------------+----------------------+-----------------------+
| acc_mode             | open(2) access mode  |                       |
+----------------------+----------------------+-----------------------+

Determine whether the subject credential can perform an open operation
on the passed vnode with the passed access mode. Return 0 for success,
or an errno value for failure. Suggested failure: EACCES for label
mismatch, or EPERM for lack of privilege.

6.7.4.46. mpo_check_vnode_readdir

    int mpo_check_vnode_readdir( ,
        ,
        );
    struct ucred *cred;
    struct vnode *dvp;
    struct label *dlabel;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| dvp                  | Object; directory    |                       |
|                      | vnode                |                       |
+----------------------+----------------------+-----------------------+
| dlabel               | Policy label for dvp |                       |
+----------------------+----------------------+-----------------------+

Determine whether the subject credential can perform a readdir operation
on the passed directory vnode. Return 0 for success, or an errno value
for failure. Suggested failure: EACCES for label mismatch, or EPERM for
lack of privilege.

6.7.4.47. mpo_check_vnode_readlink

    int mpo_check_vnode_readlink( cred,
        vp,
        label);
    struct ucred *cred;
    struct vnode *vp;
    struct label *label;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| vp                   | Object; vnode        |                       |
+----------------------+----------------------+-----------------------+
| label                | Policy label for vp  |                       |
+----------------------+----------------------+-----------------------+

Determine whether the subject credential can perform a readlink
operation on the passed symlink vnode. Return 0 for success, or an errno
value for failure. Suggested failure: EACCES for label mismatch, or
EPERM for lack of privilege. This call may be made in a number of
situations, including an explicit readlink call by the user process, or
as a result of an implicit readlink during a name lookup by the process.

6.7.4.48. mpo_check_vnode_revoke

    int mpo_check_vnode_revoke(   cred,
        vp,
        label);
    struct ucred *cred;
    struct vnode *vp;
    struct label *label;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| vp                   | Object; vnode        |                       |
+----------------------+----------------------+-----------------------+
| label                | Policy label for vp  |                       |
+----------------------+----------------------+-----------------------+

Determine whether the subject credential can revoke access to the passed
vnode. Return 0 for success, or an errno value for failure. Suggested
failure: EACCES for label mismatch, or EPERM for lack of privilege.

6.7.4.49. mpo_check_vnode_setacl

    int mpo_check_vnode_setacl( cred,
        vp,
        label,
        type,
        acl);
    struct ucred *cred;
    struct vnode *vp;
    struct label *label;
    acl_type_t type;
    struct acl *acl;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| vp                   | Object; vnode        |                       |
+----------------------+----------------------+-----------------------+
| label                | Policy label for vp  |                       |
+----------------------+----------------------+-----------------------+
| type                 | ACL type             |                       |
+----------------------+----------------------+-----------------------+
| acl                  | ACL                  |                       |
+----------------------+----------------------+-----------------------+

Determine whether the subject credential can set the passed ACL of
passed type on the passed vnode. Return 0 for success, or an errno value
for failure. Suggested failure: EACCES for label mismatch, or EPERM for
lack of privilege.

6.7.4.50. mpo_check_vnode_setextattr

    int mpo_check_vnode_setextattr( cred,
        vp,
        label,
        attrnamespace,
        name,
        uio);
    struct ucred *cred;
    struct vnode *vp;
    struct label *label;
    int attrnamespace;
    const char *name;
    struct uio *uio;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| vp                   | Object; vnode        |                       |
+----------------------+----------------------+-----------------------+
| label                | Policy label for vp  |                       |
+----------------------+----------------------+-----------------------+
| attrnamespace        | Extended attribute   |                       |
|                      | namespace            |                       |
+----------------------+----------------------+-----------------------+
| name                 | Extended attribute   |                       |
|                      | name                 |                       |
+----------------------+----------------------+-----------------------+
| uio                  | I/O structure        |                       |
|                      | pointer; see uio(9)  |                       |
+----------------------+----------------------+-----------------------+

Determine whether the subject credential can set the extended attribute
of passed name and passed namespace on the passed vnode. Policies
implementing security labels backed into extended attributes may want to
provide additional protections for those attributes. Additionally,
policies should avoid making decisions based on the data referenced from
uio, as there is a potential race condition between this check and the
actual operation. The uio may also be NULL if a delete operation is
being performed. Return 0 for success, or an errno value for failure.
Suggested failure: EACCES for label mismatch, or EPERM for lack of
privilege.

6.7.4.51. mpo_check_vnode_setflags

    int mpo_check_vnode_setflags( cred,
        vp,
        label,
        flags);
    struct ucred *cred;
    struct vnode *vp;
    struct label *label;
    u_long flags;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| vp                   | Object; vnode        |                       |
+----------------------+----------------------+-----------------------+
| label                | Policy label for vp  |                       |
+----------------------+----------------------+-----------------------+
| flags                | File flags; see      |                       |
|                      | chflags(2)           |                       |
+----------------------+----------------------+-----------------------+

Determine whether the subject credential can set the passed flags on the
passed vnode. Return 0 for success, or an errno value for failure.
Suggested failure: EACCES for label mismatch, or EPERM for lack of
privilege.

6.7.4.52. mpo_check_vnode_setmode

    int mpo_check_vnode_setmode( cred,
        vp,
        label,
        mode);
    struct ucred *cred;
    struct vnode *vp;
    struct label *label;
    mode_t mode;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| vp                   | Object; vnode        |                       |
+----------------------+----------------------+-----------------------+
| label                | Policy label for vp  |                       |
+----------------------+----------------------+-----------------------+
| mode                 | File mode; see       |                       |
|                      | chmod(2)             |                       |
+----------------------+----------------------+-----------------------+

Determine whether the subject credential can set the passed mode on the
passed vnode. Return 0 for success, or an errno value for failure.
Suggested failure: EACCES for label mismatch, or EPERM for lack of
privilege.

6.7.4.53. mpo_check_vnode_setowner

    int mpo_check_vnode_setowner( cred,
        vp,
        label,
        uid,
        gid);
    struct ucred *cred;
    struct vnode *vp;
    struct label *label;
    uid_t uid;
    gid_t gid;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| vp                   | Object; vnode        |                       |
+----------------------+----------------------+-----------------------+
| label                | Policy label for vp  |                       |
+----------------------+----------------------+-----------------------+
| uid                  | User ID              |                       |
+----------------------+----------------------+-----------------------+
| gid                  | Group ID             |                       |
+----------------------+----------------------+-----------------------+

Determine whether the subject credential can set the passed uid and
passed gid as file uid and file gid on the passed vnode. The IDs may be
set to (-1) to request no update. Return 0 for success, or an errno
value for failure. Suggested failure: EACCES for label mismatch, or
EPERM for lack of privilege.

6.7.4.54. mpo_check_vnode_setutimes

    int mpo_check_vnode_setutimes( ,
        ,
        ,
        ,
        );
    struct ucred *cred;
    struct vnode *vp;
    struct label *label;
    struct timespec atime;
    struct timespec mtime;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| vp                   | Object; vp           |                       |
+----------------------+----------------------+-----------------------+
| label                | Policy label for vp  |                       |
+----------------------+----------------------+-----------------------+
| atime                | Access time; see     |                       |
|                      | utimes(2)            |                       |
+----------------------+----------------------+-----------------------+
| mtime                | Modification time;   |                       |
|                      | see utimes(2)        |                       |
+----------------------+----------------------+-----------------------+

Determine whether the subject credential can set the passed access
timestamps on the passed vnode. Return 0 for success, or an errno value
for failure. Suggested failure: EACCES for label mismatch, or EPERM for
lack of privilege.

6.7.4.55. mpo_check_proc_sched

    int mpo_check_proc_sched( ucred,
        proc);
    struct ucred *ucred;
    struct proc *proc;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| proc                 | Object; process      |                       |
+----------------------+----------------------+-----------------------+

Determine whether the subject credential can change the scheduling
parameters of the passed process. Return 0 for success, or an errno
value for failure. Suggested failure: EACCES for label mismatch, EPERM
for lack of privilege, or ESRCH to limit visibility.

See setpriority(2) for more information.

6.7.4.56. mpo_check_proc_signal

    int mpo_check_proc_signal(  cred,
        proc,
        signal);
    struct ucred *cred;
    struct proc *proc;
    int signal;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| proc                 | Object; process      |                       |
+----------------------+----------------------+-----------------------+
| signal               | Signal; see kill(2)  |                       |
+----------------------+----------------------+-----------------------+

Determine whether the subject credential can deliver the passed signal
to the passed process. Return 0 for success, or an errno value for
failure. Suggested failure: EACCES for label mismatch, EPERM for lack of
privilege, or ESRCH to limit visibility.

6.7.4.57. mpo_check_vnode_stat

    int mpo_check_vnode_stat(  cred,
        vp,
        label);
    struct ucred *cred;
    struct vnode *vp;
    struct label *label;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| vp                   | Object; vnode        |                       |
+----------------------+----------------------+-----------------------+
| label                | Policy label for vp  |                       |
+----------------------+----------------------+-----------------------+

Determine whether the subject credential can stat the passed vnode.
Return 0 for success, or an errno value for failure. Suggested failure:
EACCES for label mismatch, or EPERM for lack of privilege.

See stat(2) for more information.

6.7.4.58. mpo_check_ifnet_transmit

    int mpo_check_ifnet_transmit(   cred,
        ifnet,
        ifnetlabel,
        mbuf,
        mbuflabel);
    struct ucred *cred;
    struct ifnet *ifnet;
    struct label *ifnetlabel;
    struct mbuf *mbuf;
    struct label *mbuflabel;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| ifnet                | Network interface    |                       |
+----------------------+----------------------+-----------------------+
| ifnetlabel           | Policy label for     |                       |
|                      | ifnet                |                       |
+----------------------+----------------------+-----------------------+
| mbuf                 | Object; mbuf to be   |                       |
|                      | sent                 |                       |
+----------------------+----------------------+-----------------------+
| mbuflabel            | Policy label for     |                       |
|                      | mbuf                 |                       |
+----------------------+----------------------+-----------------------+

Determine whether the network interface can transmit the passed mbuf.
Return 0 for success, or an errno value for failure. Suggested failure:
EACCES for label mismatch, or EPERM for lack of privilege.

6.7.4.59. mpo_check_socket_deliver

    int mpo_check_socket_deliver( cred,
        ifnet,
        ifnetlabel,
        mbuf,
        mbuflabel);
    struct ucred *cred;
    struct ifnet *ifnet;
    struct label *ifnetlabel;
    struct mbuf *mbuf;
    struct label *mbuflabel;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| ifnet                | Network interface    |                       |
+----------------------+----------------------+-----------------------+
| ifnetlabel           | Policy label for     |                       |
|                      | ifnet                |                       |
+----------------------+----------------------+-----------------------+
| mbuf                 | Object; mbuf to be   |                       |
|                      | delivered            |                       |
+----------------------+----------------------+-----------------------+
| mbuflabel            | Policy label for     |                       |
|                      | mbuf                 |                       |
+----------------------+----------------------+-----------------------+

Determine whether the socket may receive the datagram stored in the
passed mbuf header. Return 0 for success, or an errno value for failure.
Suggested failures: EACCES for label mismatch, or EPERM for lack of
privilege.

6.7.4.60. mpo_check_socket_visible

    int mpo_check_socket_visible(  cred,
        so,
        socketlabel);
    struct ucred *cred;
    struct socket *so;
    struct label *socketlabel;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   | Immutable             |
+----------------------+----------------------+-----------------------+
| so                   | Object; socket       |                       |
+----------------------+----------------------+-----------------------+
| socketlabel          | Policy label for so  |                       |
+----------------------+----------------------+-----------------------+

Determine whether the subject credential cred can "see" the passed
socket (socket) using system monitoring functions, such as those
employed by netstat(8) and sockstat(1). Return 0 for success, or an
errno value for failure. Suggested failure: EACCES for label mismatches,
EPERM for lack of privilege, or ESRCH to hide visibility.

6.7.4.61. mpo_check_system_acct

    int mpo_check_system_acct(   ucred,
        vp,
        vlabel);
    struct ucred *ucred;
    struct vnode *vp;
    struct label *vlabel;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| ucred                | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| vp                   | Accounting file;     |                       |
|                      | acct(5)              |                       |
+----------------------+----------------------+-----------------------+
| vlabel               | Label associated     |                       |
|                      | with vp              |                       |
+----------------------+----------------------+-----------------------+

Determine whether the subject should be allowed to enable accounting,
based on its label and the label of the accounting log file.

6.7.4.62. mpo_check_system_nfsd

    int mpo_check_system_nfsd(  cred);
    struct ucred *cred;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+

Determine whether the subject should be allowed to call nfssvc(2).

6.7.4.63. mpo_check_system_reboot

    int mpo_check_system_reboot(  cred,
        howto);
    struct ucred *cred;
    int howto;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| howto                | howto parameter from |                       |
|                      | reboot(2)            |                       |
+----------------------+----------------------+-----------------------+

Determine whether the subject should be allowed to reboot the system in
the specified manner.

6.7.4.64. mpo_check_system_settime

    int mpo_check_system_settime(  cred);
    struct ucred *cred;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+

Determine whether the user should be allowed to set the system clock.

6.7.4.65. mpo_check_system_swapon

    int mpo_check_system_swapon(    cred,
        vp,
        vlabel);
    struct ucred *cred;
    struct vnode *vp;
    struct label *vlabel;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| vp                   | Swap device          |                       |
+----------------------+----------------------+-----------------------+
| vlabel               | Label associated     |                       |
|                      | with vp              |                       |
+----------------------+----------------------+-----------------------+

Determine whether the subject should be allowed to add vp as a swap
device.

6.7.4.66. mpo_check_system_sysctl

    int mpo_check_system_sysctl( cred,
        name,
        namelen,
        old,
        oldlenp,
        inkernel,
        new,
        newlen);
    struct ucred *cred;
    int *name;
    u_int *namelen;
    void *old;
    size_t *oldlenp;
    int inkernel;
    void *new;
    size_t newlen;

+----------------------+----------------------+-----------------------+
| Parameter            | Description          | Locking               |
+======================+======================+=======================+
| cred                 | Subject credential   |                       |
+----------------------+----------------------+-----------------------+
| name                 | See sysctl(3)        |                       |
+----------------------+----------------------+-----------------------+
| namelen              |                      |                       |
+----------------------+----------------------+-----------------------+
| old                  |                      |                       |
+----------------------+----------------------+-----------------------+
| oldlenp              |                      |                       |
+----------------------+----------------------+-----------------------+
| inkernel             | Boolean; 1 if called |                       |
|                      | from kernel          |                       |
+----------------------+----------------------+-----------------------+
| new                  | See sysctl(3)        |                       |
+----------------------+----------------------+-----------------------+
| newlen               |                      |                       |
+----------------------+----------------------+-----------------------+

Determine whether the subject should be allowed to make the specified
sysctl(3) transaction.

6.7.5. Label Management Calls

Relabel events occur when a user process has requested that the label on
an object be modified. A two-phase update occurs: first, an access
control check will be performed to determine if the update is both valid
and permitted, and then the update itself is performed via a separate
entry point. Relabel entry points typically accept the object, object
label reference, and an update label submitted by the process. Memory
allocation during relabel is discouraged, as relabel calls are not
permitted to fail (failure should be reported earlier in the relabel
check).

6.8. Userland Architecture

The TrustedBSD MAC Framework includes a number of policy-agnostic
elements, including MAC library interfaces for abstractly managing
labels, modifications to the system credential management and login
libraries to support the assignment of MAC labels to users, and a set of
tools to monitor and modify labels on processes, files, and network
interfaces. More details on the user architecture will be added to this
section in the near future.

6.8.1. APIs for Policy-Agnostic Label Management

The TrustedBSD MAC Framework provides a number of library and system
calls permitting applications to manage MAC labels on objects using a
policy-agnostic interface. This permits applications to manipulate
labels for a variety of policies without being written to support
specific policies. These interfaces are used by general-purpose tools
such as ifconfig(8), ls(1) and ps(1) to view labels on network
interfaces, files, and processes. The APIs also support MAC management
tools including getfmac(8), getpmac(8), setfmac(8), setfsmac(8), and
setpmac(8). The MAC APIs are documented in mac(3).

Applications handle MAC labels in two forms: an internalized form used
to return and set labels on processes and objects (mac_t), and
externalized form based on C strings appropriate for storage in
configuration files, display to the user, or input from the user. Each
MAC label contains a number of elements, each consisting of a name and
value pair. Policy modules in the kernel bind to specific names and
interpret the values in policy-specific ways. In the externalized string
form, labels are represented by a comma-delimited list of name and value
pairs separated by the / character. Labels may be directly converted to
and from text using provided APIs; when retrieving labels from the
kernel, internalized label storage must first be prepared for the
desired label element set. Typically, this is done in one of two ways:
using mac_prepare(3) and an arbitrary list of desired label elements, or
one of the variants of the call that loads a default element set from
the mac.conf(5) configuration file. Per-object defaults permit
application writers to usefully display labels associated with objects
without being aware of the policies present in the system.

+-----------------------------------+-----------------------------------+
|                                   | Currently, direct manipulation of |
|                                   | label elements other than by      |
|                                   | conversion to a text string,      |
|                                   | string editing, and conversion    |
|                                   | back to an internalized label is  |
|                                   | not supported by the MAC library. |
|                                   | Such interfaces may be added in   |
|                                   | the future if they prove          |
|                                   | necessary for application         |
|                                   | writers.                          |
+-----------------------------------+-----------------------------------+

6.8.2. Binding of Labels to Users

The standard user context management interface, setusercontext(3), has
been modified to retrieve MAC labels associated with a user’s class from
login.conf(5). These labels are then set along with other user context
when either LOGIN_SETALL is specified, or when LOGIN_SETMAC is
explicitly specified.

+-----------------------------------+-----------------------------------+
|                                   | It is expected that, in a future  |
|                                   | version of FreeBSD, the MAC label |
|                                   | database will be separated from   |
|                                   | the login.conf user class         |
|                                   | abstraction, and be maintained in |
|                                   | a separate database. However, the |
|                                   | setusercontext(3) API should      |
|                                   | remain the same following such a  |
|                                   | change.                           |
+-----------------------------------+-----------------------------------+

6.9. Conclusion

The TrustedBSD MAC framework permits kernel modules to augment the
system security policy in a highly integrated manner. They may do this
based on existing object properties, or based on label data that is
maintained with the assistance of the MAC framework. The framework is
sufficiently flexible to implement a variety of policy types, including
information flow security policies such as MLS and Biba, as well as
policies based on existing BSD credentials or file protections. Policy
authors may wish to consult this documentation as well as existing
security modules when implementing a new security service.

------------------------------------------------------------------------

Last modified on: May 4, 2023 by Muhammad Moinur Rahman

Prev

Home

Next

Table of Contents

-   6.1. MAC Documentation Copyright
-   6.2. Synopsis
-   6.3. Introduction
-   6.4. Policy Background
-   6.5. MAC Framework Kernel Architecture
-   6.6. MAC Policy Architecture
-   6.7. MAC Policy Entry Point Reference
-   6.8. Userland Architecture
-   6.9. Conclusion

------------------------------------------------------------------------

Resources

-   Download PDF
-   Edit this page
>>>>>>> b1bb5fd9 (Processing txt files in data/doc)

