
-    Part I. Kernel
-    Chapter 1. Bootstrapping and Kernel Initialization
    -   1.1. Synopsis
    -   1.2. Overview
    -   1.3. The BIOS
    -   1.4. The Master Boot Record (boot0)
    -   1.5. boot1 Stage
    -   1.6. The BTX Server
    -   1.7. boot2 Stage
    -   1.8. loader Stage
    -   1.9. Kernel Initialization
-    Chapter 2. Locking Notes
    -   2.1. Mutexes
    -   2.2. Shared Exclusive Locks
    -   2.3. Atomically Protected Variables
-    Chapter 3. Kernel Objects
    -   3.1. Terminology
    -   3.2. Kobj Operation
    -   3.3. Using Kobj
-    Chapter 4. The Jail Subsystem
    -   4.1. Architecture
    -   4.2. Restrictions
-    Chapter 5. The SYSINIT Framework
    -   5.1. Terminology
    -   5.2. SYSINIT Operation
    -   5.3. Using SYSINIT
-    Chapter 6. The TrustedBSD MAC Framework
    -   6.1. MAC Documentation Copyright
    -   6.2. Synopsis
    -   6.3. Introduction
    -   6.4. Policy Background
    -   6.5. MAC Framework Kernel Architecture
    -   6.6. MAC Policy Architecture
    -   6.7. MAC Policy Entry Point Reference
    -   6.8. Userland Architecture
    -   6.9. Conclusion
-    Chapter 7. Virtual Memory System
    -   7.1. Management of Physical Memory vm_page_t
    -   7.2. The Unified Buffer Cache vm_object_t
    -   7.3. Filesystem I/O struct buf
    -   7.4. Mapping Page Tables vm_map_t, vm_entry_t
    -   7.5. KVM Memory Mapping
    -   7.6. Tuning the FreeBSD VM System
-    Chapter 8. SMPng Design Document
    -   8.1. Introduction
    -   8.2. Basic Tools and Locking Fundamentals
    -   8.3. General Architecture and Design
    -   8.4. Specific Locking Strategies
    -   8.5. Implementation Notes
    -   8.6. Miscellaneous Topics
    -   Glossary
-    Part II. Device Drivers
-    Chapter 9. Writing FreeBSD Device Drivers
    -   9.1. Introduction
    -   9.2. Dynamic Kernel Linker Facility - KLD
    -   9.3. Character Devices
    -   9.4. Block Devices (Are Gone)
    -   9.5. Network Drivers
-    Chapter 10. ISA Device Drivers
    -   10.1. Synopsis
    -   10.2. Basic Information
    -   10.3. device_t Pointer
    -   10.4. Configuration File and the Order of Identifying and
        Probing During Auto-Configuration
<<<<<<< HEAD
=======
    -   10.5. Resources
    -   10.6. Bus Memory Mapping
    -   10.7. DMA
    -   10.8. xxx_isa_probe
    -   10.9. xxx_isa_attach
    -   10.10. xxx_isa_detach
    -   10.11. xxx_isa_shutdown
    -   10.12. xxx_intr
-    Chapter 11. PCI Devices
    -   11.1. Probe and Attach
    -   11.2. Bus Resources
-    Chapter 12. Common Access Method SCSI Controllers
    -   12.1. Synopsis
    -   12.2. General Architecture
    -   12.3. Globals and Boilerplate
    -   12.4. Device configuration: xxx_attach
    -   12.5. Processing CAM messages: xxx_action
    -   12.6. Polling xxx_poll
    -   12.7. Asynchronous Events
    -   12.8. Interrupts
    -   12.9. Errors Summary
    -   12.10. Timeout Handling
-    Chapter 13. USB Devices
    -   13.1. Introduction
    -   13.2. Host Controllers
    -   13.3. USB Device Information
    -   13.4. Device Probe and Attach
    -   13.5. USB Drivers Protocol Information
-    Chapter 14. Newbus
    -   14.1. Device Drivers
    -   14.2. Overview of Newbus
    -   14.3. Newbus API
-    Chapter 15. Sound Subsystem
    -   15.1. Introduction
    -   15.2. Files
    -   15.3. Probing, Attaching, etc.
    -   15.4. Interfaces
-    Chapter 16. PC Card
    -   16.1. Adding a Device
-    Part III. Appendices
-    Bibliography
-   

Book menu

Chapter 14. Newbus

Table of Contents

-   14.1. Device Drivers
-   14.2. Overview of Newbus
-   14.3. Newbus API

Special thanks to Matthew N. Dodd, Warner Losh, Bill Paul, Doug Rabson,
Mike Smith, Peter Wemm and Scott Long.

This chapter explains the Newbus device framework in detail.

14.1. Device Drivers

14.1.1. Purpose of a Device Driver

A device driver is a software component which provides the interface
between the kernel’s generic view of a peripheral (e.g., disk, network
adapter) and the actual implementation of the peripheral. The device
driver interface (DDI) is the defined interface between the kernel and
the device driver component.

14.1.2. Types of Device Drivers

There used to be days in UNIX®, and thus FreeBSD, in which there were
four types of devices defined:

-   block device drivers

-   character device drivers

-   network device drivers

-   pseudo-device drivers

Block devices performed in a way that used fixed size blocks [of data].
This type of driver depended on the so-called buffer cache, which had
cached accessed blocks of data in a dedicated part of memory. Often this
buffer cache was based on write-behind, which meant that when data was
modified in memory it got synced to disk whenever the system did its
periodical disk flushing, thus optimizing writes.

14.1.3. Character Devices

However, in the versions of FreeBSD 4.0 and onward the distinction
between block and character devices became non-existent.

14.2. Overview of Newbus

Newbus is the implementation of a new bus architecture based on
abstraction layers which saw its introduction in FreeBSD 3.0 when the
Alpha port was imported into the source tree. It was not until 4.0
before it became the default system to use for device drivers. Its goals
are to provide a more object-oriented means of interconnecting the
various busses and devices which a host system provides to the Operating
System.

Its main features include amongst others:

-   dynamic attaching

-   easy modularization of drivers

-   pseudo-busses

One of the most prominent changes is the migration from the flat and
ad-hoc system to a device tree layout.

At the top level resides the "root" device which is the parent to hang
all other devices on. For each architecture, there is typically a single
child of "root" which has such things as host-to-PCI bridges, etc.
attached to it. For x86, this "root" device is the "nexus" device. For
Alpha, various different models of Alpha have different top-level
devices corresponding to the different hardware chipsets, including lca,
apecs, cia and tsunami.

A device in the Newbus context represents a single hardware entity in
the system. For instance each PCI device is represented by a Newbus
device. Any device in the system can have children; a device which has
children is often called a "bus". Examples of common busses in the
system are ISA and PCI, which manage lists of devices attached to ISA
and PCI busses respectively.

Often, a connection between different kinds of bus is represented by a
"bridge" device, which normally has one child for the attached bus. An
example of this is a PCI-to-PCI bridge which is represented by a device
pcibN on the parent PCI bus and has a child pciN for the attached bus.
This layout simplifies the implementation of the PCI bus tree, allowing
common code to be used for both top-level and bridged busses.

Each device in the Newbus architecture asks its parent to map its
resources. The parent then asks its own parent until the nexus is
reached. So, basically the nexus is the only part of the Newbus system
which knows about all resources.

+-----------------------------------+-----------------------------------+
|                                   | An ISA device might want to map   |
|                                   | its IO port at 0x230, so it asks  |
|                                   | its parent, in this case the ISA  |
|                                   | bus. The ISA bus hands it over to |
|                                   | the PCI-to-ISA bridge which in    |
|                                   | its turn asks the PCI bus, which  |
|                                   | reaches the host-to-PCI bridge    |
|                                   | and finally the nexus. The beauty |
|                                   | of this transition upwards is     |
|                                   | that there is room to translate   |
|                                   | the requests. For example, the    |
|                                   | 0x230 IO port request might       |
|                                   | become memory-mapped at           |
|                                   | 0xb0000230 on a MIPS box by the   |
|                                   | PCI bridge.                       |
+-----------------------------------+-----------------------------------+

Resource allocation can be controlled at any place in the device tree.
For instance on many Alpha platforms, ISA interrupts are managed
separately from PCI interrupts and resource allocations for ISA
interrupts are managed by the Alpha’s ISA bus device. On IA-32, ISA and
PCI interrupts are both managed by the top-level nexus device. For both
ports, memory and port address space is managed by a single entity -
nexus for IA-32 and the relevant chipset driver on Alpha (e.g., CIA or
tsunami).

In order to normalize access to memory and port mapped resources, Newbus
integrates the bus_space APIs from NetBSD. These provide a single API to
replace inb/outb and direct memory reads/writes. The advantage of this
is that a single driver can easily use either memory-mapped registers or
port-mapped registers (some hardware supports both).

This support is integrated into the resource allocation mechanism. When
a resource is allocated, a driver can retrieve the associated
bus_space_tag_t and bus_space_handle_t from the resource.

Newbus also allows for definitions of interface methods in files
dedicated to this purpose. These are the .m files that are found under
the src/sys hierarchy.

The core of the Newbus system is an extensible "object-based
programming" model. Each device in the system has a table of methods
which it supports. The system and other devices uses those methods to
control the device and request services. The different methods supported
by a device are defined by a number of "interfaces". An "interface" is
simply a group of related methods which can be implemented by a device.

In the Newbus system, the methods for a device are provided by the
various device drivers in the system. When a device is attached to a
driver during auto-configuration, it uses the method table declared by
the driver. A device can later detach from its driver and re-attach to a
new driver with a new method table. This allows dynamic replacement of
drivers which can be useful for driver development.

The interfaces are described by an interface definition language similar
to the language used to define vnode operations for file systems. The
interface would be stored in a methods file (which would normally be
named foo_if.m).

Example 1. Newbus Methods

          # Foo subsystem/driver (a comment...)

          INTERFACE foo

        METHOD int doit {
            device_t dev;
        };

        # DEFAULT is the method that will be used, if a method was not
        # provided via: DEVMETHOD()

        METHOD void doit_to_child {
            device_t dev;
            driver_t child;
        } DEFAULT doit_generic_to_child;

When this interface is compiled, it generates a header file "foo_if.h"
which contains function declarations:

          int FOO_DOIT(device_t dev);
          int FOO_DOIT_TO_CHILD(device_t dev, device_t child);

A source file, "foo_if.c" is also created to accompany the automatically
generated header file; it contains implementations of those functions
which look up the location of the relevant functions in the object’s
method table and call that function.

The system defines two main interfaces. The first fundamental interface
is called "device" and includes methods which are relevant to all
devices. Methods in the "device" interface include "probe", "attach" and
"detach" to control detection of hardware and "shutdown", "suspend" and
"resume" for critical event notification.

The second, more complex interface is "bus". This interface contains
methods suitable for devices which have children, including methods to
access bus specific per-device information ^([1]), event notification
(child_detached, driver_added) and resource management (alloc_resource,
activate_resource, deactivate_resource, release_resource).

Many methods in the "bus" interface are performing services for some
child of the bus device. These methods would normally use the first two
arguments to specify the bus providing the service and the child device
which is requesting the service. To simplify driver code, many of these
methods have accessor functions which lookup the parent and call a
method on the parent. For instance the method
BUS_TEARDOWN_INTR(device_t dev, device_t child, …​) can be called using
the function bus_teardown_intr(device_t child, …​).

Some bus types in the system define additional interfaces to provide
access to bus-specific functionality. For instance, the PCI bus driver
defines the "pci" interface which has two methods read_config and
write_config for accessing the configuration registers of a PCI device.

14.3. Newbus API

As the Newbus API is huge, this section makes some effort at documenting
it. More information to come in the next revision of this document.

14.3.1. Important Locations in the Source Hierarchy

src/sys/[arch]/[arch] - Kernel code for a specific machine architecture
resides in this directory. For example, the i386 architecture, or the
SPARC64 architecture.

src/sys/dev/[bus] - device support for a specific [bus] resides in this
directory.

src/sys/dev/pci - PCI bus support code resides in this directory.

src/sys/[isa|pci] - PCI/ISA device drivers reside in this directory. The
PCI/ISA bus support code used to exist in this directory in FreeBSD
version 4.0.

14.3.2. Important Structures and Type Definitions

devclass_t - This is a type definition of a pointer to a
struct devclass.

device_method_t - This is the same as kobj_method_t (see
src/sys/kobj.h).

device_t - This is a type definition of a pointer to a struct device.
device_t represents a device in the system. It is a kernel object. See
src/sys/sys/bus_private.h for implementation details.

driver_t - This is a type definition which references struct driver. The
driver struct is a class of the device kernel object; it also holds data
private to the driver.

driver_t Implementation

        struct driver {
            KOBJ_CLASS_FIELDS;
            void    *priv;          /* driver private data */
          };

A device_state_t type, which is an enumeration, device_state. It
contains the possible states of a Newbus device before and after the
autoconfiguration process.

Device States _device_state_t

       /*
           * src/sys/sys/bus.h
           */
          typedef enum device_state {
            DS_NOTPRESENT,  /* not probed or probe failed */
            DS_ALIVE,       /* probe succeeded */
            DS_ATTACHED,    /* attach method called */
            DS_BUSY         /* device is open */
          } device_state_t;

------------------------------------------------------------------------

1. bus_generic_read_ivar(9) and bus_generic_write_ivar(9)

------------------------------------------------------------------------

Last modified on: December 11, 2021 by Sergio Carlavilla Delgado

Prev

Home

Next

Table of Contents

-   14.1. Device Drivers
-   14.2. Overview of Newbus
-   14.3. Newbus API

------------------------------------------------------------------------

Resources

-   Download PDF
-   Edit this page
>>>>>>> b1bb5fd9 (Processing txt files in data/doc)

