
-    Part I. Kernel
-    Chapter 1. Bootstrapping and Kernel Initialization
    -   1.1. Synopsis
    -   1.2. Overview
    -   1.3. The BIOS
    -   1.4. The Master Boot Record (boot0)
    -   1.5. boot1 Stage
    -   1.6. The BTX Server
    -   1.7. boot2 Stage
    -   1.8. loader Stage
    -   1.9. Kernel Initialization
-    Chapter 2. Locking Notes
    -   2.1. Mutexes
    -   2.2. Shared Exclusive Locks
    -   2.3. Atomically Protected Variables
-    Chapter 3. Kernel Objects
    -   3.1. Terminology
    -   3.2. Kobj Operation
    -   3.3. Using Kobj
-    Chapter 4. The Jail Subsystem
    -   4.1. Architecture
    -   4.2. Restrictions
-    Chapter 5. The SYSINIT Framework
    -   5.1. Terminology
    -   5.2. SYSINIT Operation
    -   5.3. Using SYSINIT
-    Chapter 6. The TrustedBSD MAC Framework
    -   6.1. MAC Documentation Copyright
    -   6.2. Synopsis
    -   6.3. Introduction
    -   6.4. Policy Background
    -   6.5. MAC Framework Kernel Architecture
    -   6.6. MAC Policy Architecture
    -   6.7. MAC Policy Entry Point Reference
    -   6.8. Userland Architecture
    -   6.9. Conclusion
-    Chapter 7. Virtual Memory System
    -   7.1. Management of Physical Memory vm_page_t
    -   7.2. The Unified Buffer Cache vm_object_t
    -   7.3. Filesystem I/O struct buf
    -   7.4. Mapping Page Tables vm_map_t, vm_entry_t
    -   7.5. KVM Memory Mapping
    -   7.6. Tuning the FreeBSD VM System
-    Chapter 8. SMPng Design Document
    -   8.1. Introduction
    -   8.2. Basic Tools and Locking Fundamentals
    -   8.3. General Architecture and Design
    -   8.4. Specific Locking Strategies
    -   8.5. Implementation Notes
    -   8.6. Miscellaneous Topics
    -   Glossary
-    Part II. Device Drivers
-    Chapter 9. Writing FreeBSD Device Drivers
    -   9.1. Introduction
    -   9.2. Dynamic Kernel Linker Facility - KLD
    -   9.3. Character Devices
    -   9.4. Block Devices (Are Gone)
    -   9.5. Network Drivers
-    Chapter 10. ISA Device Drivers
    -   10.1. Synopsis
    -   10.2. Basic Information
    -   10.3. device_t Pointer
    -   10.4. Configuration File and the Order of Identifying and
        Probing During Auto-Configuration
<<<<<<< HEAD
=======
    -   10.5. Resources
    -   10.6. Bus Memory Mapping
    -   10.7. DMA
    -   10.8. xxx_isa_probe
    -   10.9. xxx_isa_attach
    -   10.10. xxx_isa_detach
    -   10.11. xxx_isa_shutdown
    -   10.12. xxx_intr
-    Chapter 11. PCI Devices
    -   11.1. Probe and Attach
    -   11.2. Bus Resources
-    Chapter 12. Common Access Method SCSI Controllers
    -   12.1. Synopsis
    -   12.2. General Architecture
    -   12.3. Globals and Boilerplate
    -   12.4. Device configuration: xxx_attach
    -   12.5. Processing CAM messages: xxx_action
    -   12.6. Polling xxx_poll
    -   12.7. Asynchronous Events
    -   12.8. Interrupts
    -   12.9. Errors Summary
    -   12.10. Timeout Handling
-    Chapter 13. USB Devices
    -   13.1. Introduction
    -   13.2. Host Controllers
    -   13.3. USB Device Information
    -   13.4. Device Probe and Attach
    -   13.5. USB Drivers Protocol Information
-    Chapter 14. Newbus
    -   14.1. Device Drivers
    -   14.2. Overview of Newbus
    -   14.3. Newbus API
-    Chapter 15. Sound Subsystem
    -   15.1. Introduction
    -   15.2. Files
    -   15.3. Probing, Attaching, etc.
    -   15.4. Interfaces
-    Chapter 16. PC Card
    -   16.1. Adding a Device
-    Part III. Appendices
-    Bibliography
-   

Book menu

Chapter 9. Writing FreeBSD Device Drivers

Table of Contents

-   9.1. Introduction
-   9.2. Dynamic Kernel Linker Facility - KLD
-   9.3. Character Devices
-   9.4. Block Devices (Are Gone)
-   9.5. Network Drivers

9.1. Introduction

This chapter provides a brief introduction to writing device drivers for
FreeBSD. A device in this context is a term used mostly for
hardware-related stuff that belongs to the system, like disks, printers,
or a graphics display with its keyboard. A device driver is the software
component of the operating system that controls a specific device. There
are also so-called pseudo-devices where a device driver emulates the
behavior of a device in software without any particular underlying
hardware. Device drivers can be compiled into the system statically or
loaded on demand through the dynamic kernel linker facility `kld'.

Most devices in a UNIX®-like operating system are accessed through
device-nodes, sometimes also called special files. These files are
usually located under the directory /dev in the filesystem hierarchy.

Device drivers can roughly be broken down into two categories; character
and network device drivers.

9.2. Dynamic Kernel Linker Facility - KLD

The kld interface allows system administrators to dynamically add and
remove functionality from a running system. This allows device driver
writers to load their new changes into a running kernel without
constantly rebooting to test changes.

The kld interface is used through:

-   kldload - loads a new kernel module

-   kldunload - unloads a kernel module

-   kldstat - lists loaded modules

Skeleton Layout of a kernel module

    /*
     * KLD Skeleton
     * Inspired by Andrew Reiter's Daemonnews article
     */

    #include <sys/types.h>
    #include <sys/systm.h>  /* uprintf */
    #include <sys/errno.h>
    #include <sys/param.h>  /* defines used in kernel.h */
    #include <sys/module.h>
    #include <sys/kernel.h> /* types used in module initialization */

    /*
     * Load handler that deals with the loading and unloading of a KLD.
     */

    static int
    skel_loader(struct module *m, int what, void *arg)
    {
      int err = 0;

      switch (what) {
      case MOD_LOAD:                /* kldload */
        uprintf("Skeleton KLD loaded.\n");
        break;
      case MOD_UNLOAD:
        uprintf("Skeleton KLD unloaded.\n");
        break;
      default:
        err = EOPNOTSUPP;
        break;
      }
      return(err);
    }

    /* Declare this module to the rest of the kernel */

    static moduledata_t skel_mod = {
      "skel",
      skel_loader,
      NULL
    };

    DECLARE_MODULE(skeleton, skel_mod, SI_SUB_KLD, SI_ORDER_ANY);

9.2.1. Makefile

FreeBSD provides a system makefile to simplify compiling a kernel
module.

    SRCS=skeleton.c
    KMOD=skeleton

    .include <bsd.kmod.mk>

Running make with this makefile will create a file skeleton.ko that can
be loaded into the kernel by typing:

    # kldload -v ./skeleton.ko

9.3. Character Devices

A character device driver is one that transfers data directly to and
from a user process. This is the most common type of device driver and
there are plenty of simple examples in the source tree.

This simple example pseudo-device remembers whatever values are written
to it and can then echo them back when read.

Example 1. Example of a Sample Echo Pseudo-Device Driver for FreeBSD
10.X - 12.X

    /*
     * Simple Echo pseudo-device KLD
     *
     * Murray Stokely
     * Søren (Xride) Straarup
     * Eitan Adler
     */

    #include <sys/types.h>
    #include <sys/systm.h>  /* uprintf */
    #include <sys/param.h>  /* defines used in kernel.h */
    #include <sys/module.h>
    #include <sys/kernel.h> /* types used in module initialization */
    #include <sys/conf.h>   /* cdevsw struct */
    #include <sys/uio.h>    /* uio struct */
    #include <sys/malloc.h>

    #define BUFFERSIZE 255

    /* Function prototypes */
    static d_open_t      echo_open;
    static d_close_t     echo_close;
    static d_read_t      echo_read;
    static d_write_t     echo_write;

    /* Character device entry points */
    static struct cdevsw echo_cdevsw = {
        .d_version = D_VERSION,
        .d_open = echo_open,
        .d_close = echo_close,
        .d_read = echo_read,
        .d_write = echo_write,
        .d_name = "echo",
    };

    struct s_echo {
        char msg[BUFFERSIZE + 1];
        int len;
    };

    /* vars */
    static struct cdev *echo_dev;
    static struct s_echo *echomsg;

    MALLOC_DECLARE(M_ECHOBUF);
    MALLOC_DEFINE(M_ECHOBUF, "echobuffer", "buffer for echo module");

    /*
     * This function is called by the kld[un]load(2) system calls to
     * determine what actions to take when a module is loaded or unloaded.
     */
    static int
    echo_loader(struct module *m __unused, int what, void *arg __unused)
    {
        int error = 0;

        switch (what) {
        case MOD_LOAD:                /* kldload */
            error = make_dev_p(MAKEDEV_CHECKNAME | MAKEDEV_WAITOK,
                &echo_dev,
                &echo_cdevsw,
                0,
                UID_ROOT,
                GID_WHEEL,
                0600,
                "echo");
            if (error != 0)
                break;

            echomsg = malloc(sizeof(*echomsg), M_ECHOBUF, M_WAITOK |
                M_ZERO);
            printf("Echo device loaded.\n");
            break;
        case MOD_UNLOAD:
            destroy_dev(echo_dev);
            free(echomsg, M_ECHOBUF);
            printf("Echo device unloaded.\n");
            break;
        default:
            error = EOPNOTSUPP;
            break;
        }
        return (error);
    }

    static int
    echo_open(struct cdev *dev __unused, int oflags __unused, int devtype __unused,
        struct thread *td __unused)
    {
        int error = 0;

        uprintf("Opened device \"echo\" successfully.\n");
        return (error);
    }

    static int
    echo_close(struct cdev *dev __unused, int fflag __unused, int devtype __unused,
        struct thread *td __unused)
    {

        uprintf("Closing device \"echo\".\n");
        return (0);
    }

    /*
     * The read function just takes the buf that was saved via
     * echo_write() and returns it to userland for accessing.
     * uio(9)
     */
    static int
    echo_read(struct cdev *dev __unused, struct uio *uio, int ioflag __unused)
    {
        size_t amt;
        int error;

        /*
         * How big is this read operation?  Either as big as the user wants,
         * or as big as the remaining data.  Note that the 'len' does not
         * include the trailing null character.
         */
        amt = MIN(uio->uio_resid, uio->uio_offset >= echomsg->len + 1 ? 0 :
            echomsg->len + 1 - uio->uio_offset);

        if ((error = uiomove(echomsg->msg, amt, uio)) != 0)
            uprintf("uiomove failed!\n");

        return (error);
    }

    /*
     * echo_write takes in a character string and saves it
     * to buf for later accessing.
     */
    static int
    echo_write(struct cdev *dev __unused, struct uio *uio, int ioflag __unused)
    {
        size_t amt;
        int error;

        /*
         * We either write from the beginning or are appending -- do
         * not allow random access.
         */
        if (uio->uio_offset != 0 && (uio->uio_offset != echomsg->len))
            return (EINVAL);

        /* This is a new message, reset length */
        if (uio->uio_offset == 0)
            echomsg->len = 0;

        /* Copy the string in from user memory to kernel memory */
        amt = MIN(uio->uio_resid, (BUFFERSIZE - echomsg->len));

        error = uiomove(echomsg->msg + uio->uio_offset, amt, uio);

        /* Now we need to null terminate and record the length */
        echomsg->len = uio->uio_offset;
        echomsg->msg[echomsg->len] = 0;

        if (error != 0)
            uprintf("Write failed: bad address!\n");
        return (error);
    }

    DEV_MODULE(echo, echo_loader, NULL);

With this driver loaded try:

    # echo -n "Test Data" > /dev/echo
    # cat /dev/echo
    Opened device "echo" successfully.
    Test Data
    Closing device "echo".

Real hardware devices are described in the next chapter.

9.4. Block Devices (Are Gone)

Other UNIX® systems may support a second type of disk device known as
block devices. Block devices are disk devices for which the kernel
provides caching. This caching makes block-devices almost unusable, or
at least dangerously unreliable. The caching will reorder the sequence
of write operations, depriving the application of the ability to know
the exact disk contents at any one instant in time.

This makes predictable and reliable crash recovery of on-disk data
structures (filesystems, databases, etc.) impossible. Since writes may
be delayed, there is no way the kernel can report to the application
which particular write operation encountered a write error, this further
compounds the consistency problem.

For this reason, no serious applications rely on block devices, and in
fact, almost all applications which access disks directly take great
pains to specify that character (or "raw") devices should always be
used. As the implementation of the aliasing of each disk (partition) to
two devices with different semantics significantly complicated the
relevant kernel code, FreeBSD dropped support for cached disk devices as
part of the modernization of the disk I/O infrastructure.

9.5. Network Drivers

Drivers for network devices do not use device nodes in order to be
accessed. Their selection is based on other decisions made inside the
kernel and instead of calling open(), use of a network device is
generally introduced by using the system call socket(2).

For more information see ifnet(9), the source of the loopback device,
and Bill Paul’s network drivers.

------------------------------------------------------------------------

Last modified on: January 10, 2022 by blitztide

Prev

Home

Next

Table of Contents

-   9.1. Introduction
-   9.2. Dynamic Kernel Linker Facility - KLD
-   9.3. Character Devices
-   9.4. Block Devices (Are Gone)
-   9.5. Network Drivers

------------------------------------------------------------------------

Resources

-   Download PDF
-   Edit this page
>>>>>>> b1bb5fd9 (Processing txt files in data/doc)

